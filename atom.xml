<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kirago杂谈</title>
  
  
  <link href="http://kiragoo.github.com/atom.xml" rel="self"/>
  
  <link href="http://kiragoo.github.com/"/>
  <updated>2023-04-23T03:23:34.460Z</updated>
  <id>http://kiragoo.github.com/</id>
  
  <author>
    <name>kirago</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>containerd存储驱动一探究竟</title>
    <link href="http://kiragoo.github.com/archives/32158f45.html"/>
    <id>http://kiragoo.github.com/archives/32158f45.html</id>
    <published>2023-04-23T03:16:44.000Z</published>
    <updated>2023-04-23T03:23:34.460Z</updated>
    
    <content type="html"><![CDATA[<p>番外篇，简单讲讲容器镜像的存储驱动，为简单演示，以 overlay 存储驱动为例。</p><p>可以通过 <code>Linux kennel</code> 查看 <a href="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html"><code>Overlay Filesystem</code></a>  的相关明细介绍，以下内容主要以演示为主，加深理解，且此内容的理解是对后续 <code>Containerd</code> 中  <code>Snapshotter Service`` 和 </code>DiffApplier Service` 必备的基础。</p><p>模拟<br>[1-1] 模拟已经存在一个 layer 包含单一文件 <code>file_a</code> 的 <code>snapshot</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/a/1/fs</span><br><span class="line">touch /tmp/a/1/fs/file_a</span><br></pre></td></tr></table></figure><p>[1-2] 如若这个时候接收到再创建 <code>layer</code> 的请求，具体内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/a/2/fs</span><br><span class="line">mkdir -p /tmp/a/2/workdir</span><br></pre></td></tr></table></figure><p>[1-3] 此时存储驱动 <code>overlay</code> 将进行如下处理，且将最终序列化好的 <code>mount</code> 进行返回，表意如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type: Overlay</span><br><span class="line">Source: Overlay</span><br><span class="line">Options:</span><br><span class="line">  lowerdir&#x3D;&#x2F;tmp&#x2F;a&#x2F;1&#x2F;fs   &lt;-- list of all parents</span><br><span class="line">  uperdir&#x3D;&#x2F;tmp&#x2F;a&#x2F;2&#x2F;fs    &lt;-- fs dir we just created</span><br><span class="line">  workdir&#x3D;&#x2F;tmp&#x2F;a&#x2F;2&#x2F;workdir &lt;-- work dir we just created</span><br></pre></td></tr></table></figure><p>[1-1…1-3]逻辑处理在 <code>containerd</code> 服务中，通过 <code>Snapshotter Service</code> 处理。</p><p>[2-1] <code>mount</code> 挂载模拟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /tmp/mount</span><br><span class="line">mount -t overlay -o lowerdir=/tmp/a/1/fs,upperdir=/tmp/a/2/fs,workdir=/tmp/a/2/workdir overlay /tmp/mount</span><br></pre></td></tr></table></figure><p>查看挂载点 <code>mount</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-slave tmp]<span class="comment"># tree mount/</span></span><br><span class="line">mount/</span><br><span class="line">└── file_a</span><br><span class="line"></span><br><span class="line">0 directories, 1 file</span><br></pre></td></tr></table></figure><p>[2-2] 添加测试文件 <code>file_b</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /mount/file_b</span><br></pre></td></tr></table></figure><p>由于 <code>upperdir</code> 配置为 <code>/tmp/a/2/fs</code> ，验证 <code>file_b</code> 的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-slave tmp]<span class="comment"># ls -al a/2/fs/</span></span><br><span class="line">总用量 8</span><br><span class="line">drwxr-xr-x 2 root root 4096 4月  23 11:00 .</span><br><span class="line">drwxr-xr-x 4 root root 4096 4月  23 10:37 ..</span><br><span class="line">c--------- 1 root root 0, 0 4月  23 11:00 file_a</span><br><span class="line">-rw-r--r-- 1 root root    0 4月  23 11:00 file_b</span><br></pre></td></tr></table></figure><p>同时请注意关于 <code>file_a</code> 的描述，其实这代表着对于上一层的 <code>COMMIT</code>。</p><p>[2-1…2-2] 逻辑处理在 <code>containerd</code> 服务中，通过 <code>DiffAplier Service</code> 处理。</p><p>[3-1] 对 <code>mount</code> 进行挂载点的卸载，看看 <code>file_b</code> 文件的真实添加位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">umount overlay</span><br><span class="line">[root@k8s-slave fs]<span class="comment"># pwd</span></span><br><span class="line">/tmp/a/2/fs</span><br><span class="line">[root@k8s-slave fs]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── file_a</span><br><span class="line">└── file_b</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br></pre></td></tr></table></figure><p>在 overlay mount如果再加一层 layer的话，该如何处理，感兴趣的可以自己模拟下看看最终表现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;番外篇，简单讲讲容器镜像的存储驱动，为简单演示，以 overlay 存储驱动为例。&lt;/p&gt;
&lt;p&gt;可以通过 &lt;code&gt;Linux kennel&lt;/code&gt; 查看 &lt;a href=&quot;https://www.kernel.org/doc/html/latest/filesy</summary>
      
    
    
    
    <category term="containerd" scheme="http://kiragoo.github.com/categories/containerd/"/>
    
    
    <category term="containerd" scheme="http://kiragoo.github.com/tags/containerd/"/>
    
    <category term="snapshot" scheme="http://kiragoo.github.com/tags/snapshot/"/>
    
  </entry>
  
  <entry>
    <title>NRI:下一代节点细粒度资源控制方案</title>
    <link href="http://kiragoo.github.com/archives/9ed9f81c.html"/>
    <id>http://kiragoo.github.com/archives/9ed9f81c.html</id>
    <published>2023-04-18T13:00:44.000Z</published>
    <updated>2023-04-18T13:33:43.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自 <a href="https://juejin.cn/post/7221357811288293432">NRI:下一代节点细粒度资源控制方案</a></p><p><a href="https://github.com/containerd/containerd/pull/4411">相关PR</a></p><p><a href="https://static.sched.com/hosted_files/kccncna2022/cc/KubeCon-NA-2022-NRI-presentation.pdf">KubeCon-NA-2022-NRI-presentation.pdf</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为了满足不同业务应用场景的需求，特别是在在线任务与离线任务混布的场景下，在提高资源利用率的同时，也要保证延迟敏感服务可以得到充分的资源保证，这就需要Kubernetes提供更加细粒度的资源管理功能，增强容器的隔离性，减少容器之间的互相干扰。例如，CPU编排，内存分层，缓存管理，IO管理等。目前有很多方案，但是都有其一定的局限性。</p><p>截至目前，Kubernetes并没有提供一个非常完善的资源管理方案，很多Kubernetes周边的开源项目通过一些自己的方式修改Pod的部署和管理流程，实现资源分配的细粒度管理。例如<a href="https://link.juejin.cn/?target=https://github.com/intel/cri-resource-manager">CRI-RM</a>，<a href="https://link.juejin.cn/?target=https://koordinator.sh">Koordinator</a>，<a href="https://link.juejin.cn/?target=https://gocrane.io">Crane</a>等项目。</p><p>这些项目对Kubernetes创建和更新Pod的流程的优化可以大致分为两种模式，一种是 Proxy模式，一种是Standalone模式。</p><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/oci-runtime.png" alt="pod 生命周期流程"></p><p>在目前的K8s架构中，如图a，Kubelet通过调用CRI兼容的容器运行时创建和管理Pod。CRI Runtime再通过调用OCI兼容的Low-level Runtime创建Container。</p><h2 id="Proxy-模式"><a href="#Proxy-模式" class="headerlink" title="Proxy 模式"></a>Proxy 模式</h2><p>Proxy模式(如图b)则是在客户端(Kubelet)和CRI Runtime(containerd,CRI-O等) 之间增加一个CRI Proxy中继请求和响应，在Proxy中劫持Pod以及Container的创建&#x2F;更新&#x2F;删除事件，对Pod的Spec进行修改或者完善，将硬件感知的资源分配策略应用于容器中。</p><h2 id="Standalone-模式"><a href="#Standalone-模式" class="headerlink" title="Standalone 模式"></a>Standalone 模式</h2><p>Standalone模式(如图c)则是在每一个Work Node上创建一个Agent，当这个Agent监听到在本节点的Pod创建或者修改事件的时候，再根据Pod Spec中的annotation，转换成细粒度资源配置的Spec，然后调用CRI Runtime实现对Pod的更新。<br>这两种方式在满足特定业务需求的同时也存在一定的缺点, 两种方式都需要依赖额外的组件，来捕获Pod的生命周期事件。Proxy 模式增加了Pod创建管理流程的链路以及部署和维护成本，Standalone 模式是在侦听到Pod创建以及修改的事件后，才会对Pod进行更新，会有一定的延迟。</p><h1 id="NRI-简介"><a href="#NRI-简介" class="headerlink" title="NRI 简介"></a>NRI 简介</h1><p>为了解决现有方案的问题，让开发者有一种更统一的实现方式，从而尽可能的提高资源调度插件的复用能力，<a href="https://link.juejin.cn/?target=https://github.com/containerd/nri">NRI</a>应运而出。NRI的概念于<a href="https://link.juejin.cn/?target=https://kccnceu2021.sched.com/event/iE1Y/maximizing-workloads-performance-with-smarter-runtimes-krisztian-litkey-alexander-kanevskiy-intel">2021 Europe Kubecon</a>首次被提出，到现在已经经历了<a href="https://link.juejin.cn/?target=https://kccncna2022.sched.com/event/182JT">两个版本</a>的迭代。</p><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/CRI-request-with-nri.png" alt="CRI-request-processing-with-nri"></p><p>上图显示了NRI 以及NRI插件在整个Kubernetes的Pod创建流程的位置。NRI 插件(NRI Plugin)与NRI Adaptation之间是通过Unix Domain Socket 进行通信。<br>目前，NRI已经演进到了2.0 版本，相对于1.0版本进行了重构，增加了更加丰富的hook函数。<br>NRI是Containerd的一个子项目， NRI允许将自定义的业务逻辑插入到CRI兼容的运行时中，例如，Containerd, CRI-O。 在容器的生命周期中，这些逻辑可以对容器的Spec进行修改，或者在确定的hook点做一些OCI范围之外的操作。NRI可以用于进一步完善设备或者其他资源的分配和管理。NRI本身对任何容器运行时(CRI Runtime)的内部实现细节是不感知的。它为CRI运行时提供了一个适配库，用于集成NRI和扩展插件进行交互。<br>NRI提供了接口定义和基础组件，可以实现可插拔的CRI运行时插件，这些插件就是NRI 插件(NRI Plugin)。这些NRI插件是与运行时类型无关的，插件既可以应用于Containerd，也可以应用CRI-O。原则上，任何NRI插件(NRI Plugin)都应该能够和启用NRI的运行时(NRI-enabled CRI Runtimes)正常协作。<br>NRI 插件是一个类似守护进程的实例。插件的单个实例会处理NRI所有的事件和请求，使用Unix-domain socket来进行数据传输和通信，NRI定义了一套基于protobuf的协议–NRI plugin protocal–并通过ttRPC进行实现。这样可以通过降低每条信息的开销提高通信效率，并且可以实现有状态的NRI插件。</p><h1 id="NRI组件以及工作原理"><a href="#NRI组件以及工作原理" class="headerlink" title="NRI组件以及工作原理"></a>NRI组件以及工作原理</h1><p>NRI的实现包含多个组件，每个组件组件对于在运行时中实现端到端的NRI支持都至关重要。最主要的两个组件是，NRI API 和NRI运行时适配器(NRI Runtime Adaptation)。这些组件共同建立了运行时如何与NRI交互，NRI插件如何与Runtime的容器进行交互的模型。同时还定义了插件可以在哪些条件下对容器进行修改以及可以更改的范围。</p><h2 id="NRI-API"><a href="#NRI-API" class="headerlink" title="NRI API"></a>NRI API</h2><p>NRI底层的核心是由protobuf协议定义的底层插件API。这个API定义了两个服务， 运行时服务(Runtime Service)和 插件服务(Plugin Service)。<br>运行时服务(NRI Runtime Service)是CRI运行时暴露给NRI插件的公共接口。这个接口上所有的请求都由NRI插件发起的。这个接口提供了以下功能。</p><ul><li>启动插件注册</li><li>请求主动更新容器</li></ul><p>插件服务(NRI Plugin Service)是运行时和NRI插件进行交互的公共接口。这个接口上请求都是由NRI插件或者Runtime发起的。这个接口提供了以下功能。</p><ul><li>配置NRI插件</li><li>获取已经存在的Pod和Contaienr的初始列表</li><li>把插件挂载到Pod&#x2F;contaienr 的生命周期事件中</li><li>关闭插件</li></ul><p>在NRI插件开始接受和处理容器事件之前，它需要向NRI注册自己。在注册过程中，NRI 插件和NRI之间会执行一个握手过程， 这个过程包含以下几步：</p><ol><li>插件向运行时标识自己</li><li>NRI为插件提供特定的配置</li><li>插件根据需求订阅Pod或者Container的生命周期事件</li><li>NRI向插件发送现有的pod或Container的列表</li><li>插件请求对现有容器的更新</li></ol><p>NRI插件通过唯一的索引和插件名向NRI 服务标识自己。NRI会通过插件的索引来决定插件的调用顺序。</p><p>NRI插件名称用于NRI服务从默认插件配置路径<code>/etc/nri/conf.d</code>选择对应插件的配置文件发送给NRI插件。只有当对应的NRI插件被NRI服务内部调用时，才会读取对应的配置文件。如果NRI插件是从外部启动的，那么它也可以通过其他方式获取配置。NRI插件可以根据需要订阅Pod和Container的生命周期，并且返回修改的配置。NRI插件如果采用预注册的方式运行时，需要将可执行文件的命名规则需要符合<code>xx-plugin_name</code>，例如<code>01-logger</code>。其中<code>xx</code>必须为两位数字，作为NRI插件的索引，决定了插件的的执行顺序。</p><p>在注册和握手的最后一步，NRI发送CRI 运行时已知的所有的Pod和Contaienr的信息。此时插件可以对任何已经存在的Pod和Container进行更新。<br>一旦握手结束，并且NRI插件成功向NRI服务注册之后，它将开始根据自己的订阅接收Pod和Container 的生命周期事件。</p><h2 id="运行时适配器"><a href="#运行时适配器" class="headerlink" title="运行时适配器"></a>运行时适配器</h2><p>NRI 运行时适配器(NRI Runtime Adaptation)是CRI运行时集成到NRI和与NRI交互的接口。它实现了插件发现，启动和配置。它还提供了将NRI插件插入到CRI运行时的Pod和Container的生命周期事件中的必要功能。<br>运行时适配器实现了多个NRI插件可能在处理同一个Pod或者Container的生命周期事件。它负责按照索引顺序依次调用插件，并把插件的修改内容合并后返回。在合并插件修改的OCI Spec时，当检测到到多个NRI插件对同一个Container产生了冲突的修改，就会返回一个错误。</p><h2 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h2><p>NRI还包含一个NRI插件Stub库(NRI Plugin Stub Library)，为NRI 插件的实现提供了一个简洁易用的框架。NRI插件Stub库隐藏了NRI插件的底层实现细节，它负责连接建立、插件注册、配置和事件订阅。<br>同时NRI也提供了一些NRI 插件的示例，这些示例都是结合实际使用场景创建的，其中一些示例非常适合调试场景。目前，NRI提供的所有示例插件都基于Stub库实现的。这些示例插件的实现都可以用作学习使用Stub库的教程。<br>另外，NRI还包含一个OCI规范生成器(Wrapped OCI Spec Generator)主要用于NRI 插件用来调整和更新OCI Spec, 然后更新到Container。</p><h1 id="NRI-订阅的的Pod-x2F-Container的元信息和事件"><a href="#NRI-订阅的的Pod-x2F-Container的元信息和事件" class="headerlink" title="NRI 订阅的的Pod&#x2F;Container的元信息和事件"></a>NRI 订阅的的Pod&#x2F;Container的元信息和事件</h1><h2 id="Pod元信息和可用的生命周期事件"><a href="#Pod元信息和可用的生命周期事件" class="headerlink" title="Pod元信息和可用的生命周期事件"></a>Pod元信息和可用的生命周期事件</h2><p>NRI插件可以订阅的Pod生命周期事件目前有3个：<code>RunPodSandbox</code>,<code>StopPodSandbox</code>和<code>RemovePodSandbox</code>.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> handlers <span class="keyword">struct</span> &#123;</span><br><span class="line">   RunPodSandbox       <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox)</span></span> <span class="type">error</span></span><br><span class="line">   StopPodSandbox      <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox)</span></span> <span class="type">error</span></span><br><span class="line">   RemovePodSandbox    <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox)</span></span> <span class="type">error</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以下代码中我们可以看到在事件中可以获得的Pod的元信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containerd/nri/blob/v0.3.0/pkg/api/api.pb.go#L1015</span></span><br><span class="line"><span class="keyword">type</span> PodSandbox <span class="keyword">struct</span> &#123;</span><br><span class="line">Id             <span class="type">string</span>           </span><br><span class="line">Name           <span class="type">string</span>            </span><br><span class="line">Uid            <span class="type">string</span>           </span><br><span class="line">Namespace      <span class="type">string</span>           </span><br><span class="line">Labels         <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> </span><br><span class="line">Annotations    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> </span><br><span class="line">RuntimeHandler <span class="type">string</span>            </span><br><span class="line">Linux          *LinuxPodSandbox  </span><br><span class="line">Pid            <span class="type">uint32</span>            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LinuxPodSandbox <span class="keyword">struct</span> &#123;</span><br><span class="line">CgroupParent <span class="type">string</span> </span><br><span class="line">CgroupsPath  <span class="type">string</span>            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Container-元信息和可用生命周期事件"><a href="#Container-元信息和可用生命周期事件" class="headerlink" title="Container 元信息和可用生命周期事件"></a>Container 元信息和可用生命周期事件</h2><p>NRI插件可以订阅的Container生命周期事件目前有8个：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> handlers <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">CreateContainer     <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox, *api.Container)</span></span> (*api.ContainerAdjustment, []*api.ContainerUpdate, <span class="type">error</span>)</span><br><span class="line">StartContainer      <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox, *api.Container)</span></span> <span class="type">error</span></span><br><span class="line">UpdateContainer     <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox, *api.Container)</span></span> ([]*api.ContainerUpdate, <span class="type">error</span>)</span><br><span class="line">StopContainer       <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox, *api.Container)</span></span> ([]*api.ContainerUpdate, <span class="type">error</span>)</span><br><span class="line">RemoveContainer     <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox, *api.Container)</span></span> <span class="type">error</span></span><br><span class="line">PostCreateContainer <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox, *api.Container)</span></span> <span class="type">error</span></span><br><span class="line">PostStartContainer  <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox, *api.Container)</span></span> <span class="type">error</span></span><br><span class="line">PostUpdateContainer <span class="function"><span class="keyword">func</span><span class="params">(*api.PodSandbox, *api.Container)</span></span> <span class="type">error</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以下代码中我们可以看到在事件中可以获得的Container 的元信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containerd/nri/blob/v0.3.0/pkg/api/api.pb.go#L1215</span></span><br><span class="line"><span class="comment">// Container metadata that is considered relevant for a plugin.</span></span><br><span class="line"><span class="keyword">type</span> Container <span class="keyword">struct</span> &#123;</span><br><span class="line">Id <span class="type">string</span> </span><br><span class="line">PodSandboxId <span class="type">string</span> </span><br><span class="line">Name <span class="type">string</span> </span><br><span class="line">State ContainerState </span><br><span class="line">Labels <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> </span><br><span class="line">Annotations <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> </span><br><span class="line">Args []<span class="type">string</span> </span><br><span class="line">Env []<span class="type">string</span> </span><br><span class="line">Mounts []*Mount </span><br><span class="line">Hooks *Hooks </span><br><span class="line">Linux *LinuxContainer </span><br><span class="line">Pid <span class="type">uint32</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LinuxContainer <span class="keyword">struct</span> &#123;  </span><br><span class="line">Namespaces  []*LinuxNamespace </span><br><span class="line">Devices     []*LinuxDevice    </span><br><span class="line">Resources   *LinuxResources   </span><br><span class="line">OomScoreAdj *OptionalInt      </span><br><span class="line">CgroupsPath <span class="type">string</span>            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LinuxResources <span class="keyword">struct</span> &#123;</span><br><span class="line">Memory         *LinuxMemory         </span><br><span class="line">Cpu            *LinuxCPU            </span><br><span class="line">HugepageLimits []*HugepageLimit     </span><br><span class="line">BlockioClass   *OptionalString      </span><br><span class="line">RdtClass       *OptionalString       </span><br><span class="line">Devices        []*LinuxDeviceCgroup </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Container-调整和更新"><a href="#Container-调整和更新" class="headerlink" title="Container 调整和更新"></a>Container 调整和更新</h2><p>在Container 创建过程中可以调整Container的参数，在Container创建后，任何生命周期事件都可以更新Container的参数，但是调整参数和更新参数的范围是不同的，Container创建时支持更多的参数设置，Container创建完成后，只有部分参数可以修改。<br>创建过程中, Container 可以被调整的参数,如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containerd/nri/blob/v0.3.0/pkg/api/api.pb.go#L2246</span></span><br><span class="line"><span class="comment">// Requested adjustments to a container being created.</span></span><br><span class="line"><span class="keyword">type</span> ContainerAdjustment <span class="keyword">struct</span> &#123;</span><br><span class="line">Annotations <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>         </span><br><span class="line">Mounts      []*Mount                  </span><br><span class="line">Env         []*KeyValue               </span><br><span class="line">Hooks       *Hooks                    </span><br><span class="line">Linux       *LinuxContainerAdjustment </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LinuxContainerAdjustment <span class="keyword">struct</span> &#123;</span><br><span class="line">Devices     []*LinuxDevice  </span><br><span class="line">Resources   *LinuxResources </span><br><span class="line">CgroupsPath <span class="type">string</span>          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Container 创建完成后，NRI插件可以对Container进行更新。这个更新操作也可以由其他任何Container创建，更新或者停止的事件触发，或者可以主动更新Container参数。更新过程中，可以改的Container的参数要少于创建时可修改的参数，不包含<code>annotation</code>,<code>mounts</code>,<code>env</code>,<code>oci hooks</code>以及<code>devices</code>.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/containerd/nri/blob/v0.3.0/pkg/api/api.pb.go#L231</span></span><br><span class="line"><span class="comment">// Requested update to an already created container.</span></span><br><span class="line"><span class="keyword">type</span> ContainerUpdate <span class="keyword">struct</span> &#123;</span><br><span class="line">ContainerId   <span class="type">string</span>                </span><br><span class="line">Linux         *LinuxContainerUpdate </span><br><span class="line">IgnoreFailure <span class="type">bool</span>                  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LinuxContainerUpdate <span class="keyword">struct</span> &#123;</span><br><span class="line">  Resources *LinuxResources </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Containerd-集成NRI"><a href="#Containerd-集成NRI" class="headerlink" title="Containerd 集成NRI"></a>Containerd 集成NRI</h1><p>目前<a href="https://link.juejin.cn/?target=https://github.com/containerd/containerd/blob/main/docs/NRI.md">Containerd1.7.0</a>的正式版本中已经包含的NRI的基本功能。<br>Contained对NRI的支持分成两部分。 其中一个是一个通用NRI插件(Common Plugin, pkg&#x2F;nri&#x2F;*)，又称为Containerd NRI插件，用于与NRI整合。另外一个是CRI特定NRI实现(&#x2F;pkg&#x2F;cri&#x2F;server&#x2F;nri.go), 用来在运行时不可知的NRI表示和CRI 插件的内部表示之间进行数据转换。<br>NRI 通用插件是通过内置插件的方式融合到Containerd项目中的。</p><p>Containerd NRI插件实现了与NRI集成和交互的核心逻辑。但Containerd NRI插件 并不了解 Pod或者Container在Containerd中的内部表示。Containerd NRI插件定义了一个附加的接口，域(Domain),每当将内部的Pod和Container的表示形式转换为Runtime不感知的NRI的表示形式时，或者当外部的NRI插件发起一个修改配置的请求需要应用到Containerd管理的容器时，会被使用到。<br>Domain-Namespace(简称，Domain)实现了Containerd NRI插件的接口的函数，通Domain处理指定Containerd命名空间的Pod和Container。Containerd 的命名空间隔离了client和containerd， 例如”k8s.io” 是服务Kubernetes CRI client的，”moby“是 服务于Docker clinet的， ”containerd”是默认的Domain，服务于containerd和ctr.<br>Containerd CRI插件将把自己注册在NRI Domain的”k8s.io”的命名空间中，允许外部NRI插件自定义容器配置。目前这个域(Domain)只对原生的CRI(pkg&#x2F;cri&#x2F;server)做了实现。更多的试验性的工作还在持续开发中。<br>这种使用Domian功能分离的主要原因是允许NRI插件用于其他类型的Sandbox和其他容器客户端，而不仅仅用于“k8s.io”命名空间中的CRI容器,例如,未来可能兼容Docker。</p><h2 id="在Containerd中启用对NRI的支持"><a href="#在Containerd中启用对NRI的支持" class="headerlink" title="在Containerd中启用对NRI的支持"></a>在Containerd中启用对NRI的支持</h2><p>通过启用或者禁用通用的Containerd NRI 插件来开启或者关闭Containerd 对NRI的支持。默认情况下NRI插件功能是被关闭的。可以在Containerd的配置文件中，默认路径为<code>/etc/containerd/config.toml</code>，通过编辑<code>[plugins.&quot;io.containerd.nri.v1.nri&quot;]</code>这个Section来启用控制NRI的状态， <code>disable=true</code> 或者<code>disable=false</code>.<br>以下是NRI配置的详细说明:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[plugins.&quot;io.containerd.nri.v1.nri&quot;]</span><br><span class="line">  # 是否禁用NRI</span><br><span class="line">  disable = false</span><br><span class="line">  # 是否允许外部启用的NRI连接</span><br><span class="line">  disable_connections = false</span><br><span class="line">  # 插件配置文件路径</span><br><span class="line">  plugin_config_path = &quot;/etc/nri/conf.d&quot;</span><br><span class="line">  # 启动时加载NRI插件的默认路径</span><br><span class="line">  plugin_path = &quot;/opt/nri/plugins&quot;</span><br><span class="line">  # NRI插件连接后注册超时时间</span><br><span class="line">  plugin_registration_timeout = &quot;5s&quot;</span><br><span class="line">  # NRI插件处理事件/请求超时时间</span><br><span class="line">  plugin_request_timeout = &quot;2s&quot;</span><br><span class="line">  # NRI socket的存储路径</span><br><span class="line">  socket_path = &quot;/var/run/nri/nri.sock&quot;</span><br></pre></td></tr></table></figure><p>NRI插件的启动有两种方式。</p><p>第一种是预注册(Pre-Registered), 在这种方式下当NRI适配器(NRI Adaptation)实例化时，NRI插件就会自动启动。预注册就是将NRI的可执行文件放置到NRI 插件的指定路径中，默认路径就是<code>/opt/nri/plugins</code>。在使用Containerd的场景下且使用默认配置时，就是当Containerd启动时，就会自动加载并运行在<code>/opt/nri/plugins</code>路径下注册的NRI插件。</p><p>第二种是NRI插件外部运行，这种方式下NRI插件进程可以由systemd创建，或者运行在Pod中。只要保证NRI插件可以通过NRI socket和Containerd进行通信即可，默认的NRI socket存储路径为<code>/var/run/nri/nri.sock</code>。</p><p>预注册的插件是通过一个预先连接到NRI的Socket启动，外部运行的插件通过NRI Socket往NRI适配器注册自己。预注册插件和外部启动插件，这两种运行方式唯一的不同点就是如何启动以及如何连接到NRI。一旦建立了连接，所有的NRI插件都是相同的。</p><p>NRI 可以禁用外部运行插件的连接。在这种情况下NRI socket将不会被创建。上文中Containerd的配置开启了外部插件的连接。这对测试来说非常方便，可以随时连接、断开以及重新连接插件。</p><blockquote><p>注意： 不可以在同一个节点上运行两个启用NRI的Runtime，并且没有分别修改默认的NRI socket 路径。这种情况下，你需要禁用其中一个Runtime的NRI功能，或者修改其中一个Runtime的默认路径，让两个Runtime的NRI Socket路径保持不同。</p></blockquote><h1 id="NRI-成为下一代节点资源细粒度管理方案"><a href="#NRI-成为下一代节点资源细粒度管理方案" class="headerlink" title="NRI 成为下一代节点资源细粒度管理方案"></a>NRI 成为下一代节点资源细粒度管理方案</h1><p>使用NRI可以将Kubelet的Resource Manager下沉到CRI Runtime层进行管理。Kubelet当前不适合处理多种需求的扩展，在Kubelet层增加细粒度的资源分配会导致Kubelet和CRI的界限越来越模糊。<br>而NRI，则是在CRI生命周期间做调用，更适合做资源绑定和节点的拓扑感知。并且在CRI内部做插件定义和迭代，可以做到上层 Kubenetes 以最小的代价来适配变化。<br>到现在为止，已经有越来越多的节点资源细粒度管理方案开始探索使用NRI实现的可能性。当NRI 成为节点细粒度资源分配管理方案后，可以进一步提高资源管理方案的标准化，提高相关组件的可复用性。<br>目前我们已经开源了一些<a href="https://link.juejin.cn/?target=https://github.com/containers/nri-plugins">NRI插件</a>用于节点资源拓扑感知以及细粒度的资源绑定，接下来还有很多工作要做，欢迎各位<a href="https://link.juejin.cn/?target=https://github.com/airren">联系我们</a>一起推动NRI的发展，一起构建NRI的周边生态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自 &lt;a href=&quot;https://juejin.cn/post/7221357811288293432&quot;&gt;NRI:下一代节点细粒度资源控制方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/container</summary>
      
    
    
    
    <category term="containerd" scheme="http://kiragoo.github.com/categories/containerd/"/>
    
    
    <category term="containerd" scheme="http://kiragoo.github.com/tags/containerd/"/>
    
  </entry>
  
  <entry>
    <title>从0构建web测试框架</title>
    <link href="http://kiragoo.github.com/archives/b783defe.html"/>
    <id>http://kiragoo.github.com/archives/b783defe.html</id>
    <published>2023-04-14T09:04:45.000Z</published>
    <updated>2023-04-14T09:52:47.361Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做项目设计的时候，考虑到实际项目与传统意义上的测试有些现实的差距。目前CI部分并不是对每次的测试环境都有一个新环境的准备，在实际的自动化测试中会糅合一部分QA人工的操作，在此背景下需要在自动化测试代码层面中控制，<strong>需要注意的是，e2e测试最好的设计还是能够有个干净的单独环境用于随时拉起与清除资源，以避免不要的脏数据保证与实际功能迭代相匹配</strong>。</p><p>鉴于以上的上下文，顺便设计了个简单的可扩展的测试框架，便于项目集成。</p><h2 id="功能拆分"><a href="#功能拆分" class="headerlink" title="功能拆分"></a>功能拆分</h2><p><code>[package]core</code> 设计<br>关键元素拆分：</p><ul><li>group：以功能组为最上层测试用例注册维度</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BaseGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// group name</span></span><br><span class="line">    Name   <span class="keyword">string</span> </span><br><span class="line">    <span class="comment">// group description</span></span><br><span class="line">Desc   <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Reqs list of features interfaces</span></span><br><span class="line">Reqs []req.Req</span><br><span class="line">    <span class="comment">// rest api client</span></span><br><span class="line">Client *restclient.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>group</code> 抽象接口的设计:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// client init</span></span><br><span class="line">InitC()</span><br><span class="line">    <span class="comment">// group init</span></span><br><span class="line">Init()</span><br><span class="line">    <span class="comment">// start group test</span></span><br><span class="line">Start() error</span><br><span class="line">    <span class="comment">// clean up resources</span></span><br><span class="line">Cleanup() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>req：实际功能</li></ul><p>这里又要提一句的是，架构在设计 <code>struct</code> 的时候，尽量考虑复用。这里是因为在实际项目过程中，私有代码仓库中的 <code>module</code> 无法被引用，主要是因为历史原因在做整个大工程项目的时候没有做好很好的切分与独立，所以只能退而求其次来解决问题，考虑搞 <code>sync</code> 项目中的部分代码独立出一个库，但是这个高级功能在 <code>gitlab</code> 中需要付费版才支持，所以折中就出现如下架构设计。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BaseReq <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// req name</span></span><br><span class="line">Name        <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// req uri</span></span><br><span class="line">Uri         <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// req method</span></span><br><span class="line">Method      <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// req body</span></span><br><span class="line">Body  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// req query</span></span><br><span class="line">Query <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">Runtime runtime.GroupRuntime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Req for test request</span></span><br><span class="line"><span class="keyword">type</span> Req <span class="keyword">interface</span> &#123;</span><br><span class="line">Init()</span><br><span class="line">Do(c *restclient.Client) error</span><br><span class="line">Prepare() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreReq for prepare request</span></span><br><span class="line"><span class="keyword">type</span> PreReq <span class="keyword">interface</span> &#123;</span><br><span class="line">Init()</span><br><span class="line">PreCheck() <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里抽象两个 <code>req</code>，主要是为了便于处理资源准备接口的区分，在实际的资源准备中，对于请求之后的状态码其实不应该在设计的结构体中进行描述，为了更好的表意语义。</p><ul><li>restclient：<code>http</code> 请求库构造，有了如上的测试元素的实例，还需要存在 <code>http</code> 客户端进行具体请求的执行，此次设计使用的 <code>client</code> 库<a href="https://github.com/go-resty/resty">resty</a>，虽然最近不维护了，但是看了下 <code>star</code> 和源码实现都是可控的。<strong>切记在选型时，要根据实际情况选择，如果社区活跃且支持较好，复杂点的库也可使用，如果社区活跃度一般，但是评估之后可控也可以适当尝试，具体看实际需求。</strong></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">Rclient *resty.Client</span><br><span class="line">config.Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">()</span> *<span class="title">Client</span></span> &#123;</span><br><span class="line">conf := config.NewConfig()</span><br><span class="line">c := &amp;Client&#123;&#125;</span><br><span class="line">c.Rclient = resty.New()</span><br><span class="line">c.Server = conf.Server</span><br><span class="line">c.Port = conf.Port</span><br><span class="line">c.User = conf.User</span><br><span class="line">c.Passwd = conf.Passwd</span><br><span class="line">c.Restries = conf.Restries</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Request</span><span class="params">(method, uri <span class="keyword">string</span>, body <span class="keyword">interface</span>&#123;&#125;, query <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">r := c.Rclient.R()</span><br><span class="line">r.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">token, err := c.getToken(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t, err := util.GetValueFromJson(token, <span class="string">&quot;token&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r.SetAuthToken(t)</span><br><span class="line"></span><br><span class="line">url := fmt.Sprintf(<span class="string">&quot;http://%s:%s%s&quot;</span>, c.Server, c.Port, uri)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> method &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">resp, err := get(r, url, query)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;POST&quot;</span>:</span><br><span class="line"><span class="comment">// TODO implement client</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;PUT&quot;</span>:</span><br><span class="line"><span class="comment">// TODO implement client</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;DELETE&quot;</span>:</span><br><span class="line"><span class="comment">// TODO implement client</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;implement me&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unsupported method: %s&quot;</span>, method)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">getToken</span><span class="params">(r *resty.Request)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> token <span class="keyword">string</span></span><br><span class="line">path := fmt.Sprintf(<span class="string">&quot;http://%s:%s/login&quot;</span>, c.Server, c.Port)</span><br><span class="line"></span><br><span class="line">resp, err := r.SetBody(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;userid&quot;</span>: <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;Password&quot;</span>&#125;).</span><br><span class="line">Post(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;get token failed with gui web : %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">token = resp.String()</span><br><span class="line"><span class="keyword">return</span> token, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(r *resty.Request, url <span class="keyword">string</span>, query <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> resp *resty.Response</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">if</span> query != <span class="literal">nil</span> &#123;</span><br><span class="line">resp, err = r.SetQueryParams(query).</span><br><span class="line">Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;get request failed with gui web : %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">resp, err = r.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;get request failed with gui web : %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>config: <code>web server</code> 配置定义</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c *Config</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">Server   <span class="keyword">string</span> <span class="string">`yaml:&quot;server&quot;`</span></span><br><span class="line">Port     <span class="keyword">string</span> <span class="string">`yaml:&quot;port&quot;`</span></span><br><span class="line">User     <span class="keyword">string</span> <span class="string">`yaml:&quot;user&quot;`</span></span><br><span class="line">Passwd   <span class="keyword">string</span> <span class="string">`yaml:&quot;password&quot;`</span></span><br><span class="line">Restries <span class="keyword">int</span>    <span class="string">`yaml:&quot;restries&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConfig</span><span class="params">()</span> *<span class="title">Config</span></span> &#123;</span><br><span class="line">dir, _ := os.Getwd()</span><br><span class="line">filePath := path.Join(dir, <span class="string">&quot;config.yaml&quot;</span>)</span><br><span class="line">config, err := ioutil.ReadFile(filePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">err = yaml.Unmarshal(config, &amp;c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.Restries &lt;= <span class="number">0</span> &#123;</span><br><span class="line">c.Restries = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>扩展设计与支持： 由于忙于工作其他项目的解决方案的设计，对于测试中间日志的显示和最终结果的汇总暂时还没做，这也是一个需要注意的点，先跳过此设计。</li></ul><h2 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h2><p>既然具体功能元素已经拆分结束，下面就是需要设计入口来实现具体测试用例的注册与调用了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GuiApiTest <span class="keyword">struct</span> &#123;</span><br><span class="line">Groups []group.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGuiApiTest</span><span class="params">()</span> *<span class="title">GuiApiTest</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;GuiApiTest&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对需要进行测试 group 注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GuiApiTest)</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.Groups = []group.Interface&#123;</span><br><span class="line">groups.NewFilesystemGroup(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际测试元素的处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GuiApiTest)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> g.Groups &#123;</span><br><span class="line">g.Groups[i].Init()</span><br><span class="line"><span class="keyword">if</span> err := g.Groups[i].Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// group 维度资源清除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GuiApiTest)</span> <span class="title">Cleanup</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> g.Groups &#123;</span><br><span class="line"><span class="keyword">if</span> err := g.Groups[i].Cleanup(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看，看看 <code>FilesystemGroup</code> 中有啥？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GetFileSystemList <span class="keyword">struct</span> &#123;</span><br><span class="line">req.BaseReq</span><br><span class="line">    <span class="comment">// 姑且是一个冗余设计</span></span><br><span class="line">prepares   []req.PreReq</span><br><span class="line">    <span class="comment">// 这里可以看到，这是一个非资源准备 req，是实际的需要测试的功能接口，所以需要对  assert 做一个期望描述</span></span><br><span class="line">StatusCode <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GetFileSystemList)</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.Name = <span class="string">&quot;Get_FileSystemList_Success&quot;</span></span><br><span class="line">g.Url = <span class="string">&quot;/v1/storage/filesystem/N9000&quot;</span></span><br><span class="line">g.Method = <span class="string">&quot;GET&quot;</span></span><br><span class="line"><span class="comment">// g.ContentType = &quot;application/json&quot;</span></span><br><span class="line"><span class="comment">// g.Authenticated = true</span></span><br><span class="line">g.StatusCode = <span class="number">200</span></span><br><span class="line">g.prepares = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GetFileSystemList)</span> <span class="title">Prepare</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GetFileSystemList)</span> <span class="title">Do</span><span class="params">(c *restclient.Client)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实际 http request 请求，对业务接口进行测试，为避免网络抖动，可根据之前 conf配置的 重试次数进行多次请求验证， resty 库原生支持，这里暂且没实现。</span></span><br><span class="line">resp, err := c.Request(g.Method, g.Url, <span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;[%s] test not passed&quot;</span>, g.Name)</span><br><span class="line">&#125;</span><br><span class="line">statusCode := resp.(*resty.Response).StatusCode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> statusCode != g.StatusCode &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;[%s] test not passed. want status code: %d, got status code: %d&quot;</span>, g.Name, g.StatusCode, statusCode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上 <code>c.Request(g.Method, g.Url,nil,nil)</code> 具体逻辑可以看 <code>Client</code> 的设计。</p><p>最后剩下的就是对整个入口的启动调用了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">tests := pkg.NewGuiApiTest()</span><br><span class="line">tests.Init()</span><br><span class="line">err := tests.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = tests.Cleanup()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此一个雏形设计就出来了，可在此基础上继续扩展实现实际的项目需求了。^_^</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在做项目设计的时候，考虑到实际项目与传统意义上的测试有些现实的差距。目前CI部分并不是对每次的测试环境都有一个新环境的准备，在实际的自动化测试中会糅合一部分QA人工的操作，在此背景下需要在自动化测试代码层面中控制，&lt;strong&gt;需要注意的是，e2e测试最好的设计还是能</summary>
      
    
    
    
    <category term="golang" scheme="http://kiragoo.github.com/categories/golang/"/>
    
    <category term="测试" scheme="http://kiragoo.github.com/categories/golang/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="golang" scheme="http://kiragoo.github.com/tags/golang/"/>
    
    <category term="e2e 测试" scheme="http://kiragoo.github.com/tags/e2e-%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>containerd源码分析-[2]cri插件</title>
    <link href="http://kiragoo.github.com/archives/436e2913.html"/>
    <id>http://kiragoo.github.com/archives/436e2913.html</id>
    <published>2023-04-03T13:04:54.000Z</published>
    <updated>2023-04-19T04:38:51.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>containerd-v1.7.0<br>此篇正式开启插件启用流程分析。</p></blockquote><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="初始化入口"><a href="#初始化入口" class="headerlink" title="初始化入口"></a>初始化入口</h2><p><code>pkg/cri/cri.go:42</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register CRI service plugin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 默认配置</span></span><br><span class="line">config := criconfig.DefaultConfig()</span><br><span class="line">    <span class="comment">// 必要信息注册</span></span><br><span class="line">plugin.Register(&amp;plugin.Registration&#123;</span><br><span class="line">        <span class="comment">// GRPC Plugin</span></span><br><span class="line">Type:   plugin.GRPCPlugin, </span><br><span class="line">ID:     <span class="string">&quot;cri&quot;</span>,</span><br><span class="line">Config: &amp;config,</span><br><span class="line">        <span class="comment">// Requires 插件，对于顶层 `app.Run()` 中</span></span><br><span class="line">Requires: []plugin.Type&#123;</span><br><span class="line">plugin.EventPlugin,</span><br><span class="line">plugin.ServicePlugin,</span><br><span class="line">plugin.NRIApiPlugin,</span><br><span class="line">&#125;,</span><br><span class="line">        <span class="comment">// 初始化函数</span></span><br><span class="line">InitFn: initCRIService,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CRIService-初始化流程"><a href="#CRIService-初始化流程" class="headerlink" title="CRIService 初始化流程"></a>CRIService 初始化流程</h2><p><code>pkg/cri/cri.go:57</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initCRIService</span><span class="params">(ic *plugin.InitContext)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 上下文传递</span></span><br><span class="line">ctx := ic.Context</span><br><span class="line"><span class="comment">// plugin 配置</span></span><br><span class="line">pluginConfig := ic.Config.(*criconfig.PluginConfig)</span><br><span class="line"><span class="comment">// 校验 plugin 配置</span></span><br><span class="line"><span class="keyword">if</span> err := criconfig.ValidatePluginConfig(ctx, pluginConfig); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid plugin config: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化 criconfig</span></span><br><span class="line">c := criconfig.Config&#123;</span><br><span class="line">PluginConfig:       *pluginConfig,</span><br><span class="line">ContainerdRootDir:  filepath.Dir(ic.Root),</span><br><span class="line">ContainerdEndpoint: ic.Address,</span><br><span class="line">RootDir:            ic.Root,</span><br><span class="line">StateDir:           ic.State,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 构造 contaninerd client</span></span><br><span class="line">client, err := containerd.New(</span><br><span class="line"><span class="string">&quot;&quot;</span>,</span><br><span class="line">containerd.WithDefaultNamespace(constants.K8sContainerdNamespace),</span><br><span class="line">containerd.WithDefaultPlatform(platforms.Default()),</span><br><span class="line"><span class="comment">// WithInMemoryServices适用于需要从另一个（内存）containerd插件（如CRI）使用containerd客户端的情况。</span></span><br><span class="line">containerd.WithInMemoryServices(ic),</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 根据环境变量 ENABLE_CRI_SANDDBOXES 配置构造 CRIService</span></span><br><span class="line"><span class="keyword">var</span> s server.CRIService</span><br><span class="line"><span class="keyword">if</span> os.Getenv(<span class="string">&quot;ENABLE_CRI_SANDBOXES&quot;</span>) != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">log.G(ctx).Info(<span class="string">&quot;using experimental CRI Sandbox server - unset ENABLE_CRI_SANDBOXES to disable&quot;</span>)</span><br><span class="line">s, err = sbserver.NewCRIService(c, client, getNRIAPI(ic))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.G(ctx).Info(<span class="string">&quot;using legacy CRI server&quot;</span>)</span><br><span class="line">s, err = server.NewCRIService(c, client, getNRIAPI(ic))</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 启动协程运行 CRIService</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := s.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.G(ctx).WithError(err).Fatal(<span class="string">&quot;Failed to run CRI service&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TODO(random-liu): Whether and how we can stop containerd.</span></span><br><span class="line">&#125;()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 <code>NRI</code> 的介绍详见 <a href="https://kiragoo.github.io/archives/9ed9f81c.html">NRI:下一代节点细粒度资源控制方案</a></p><h2 id="构造-CRIService-服务"><a href="#构造-CRIService-服务" class="headerlink" title="构造 CRIService 服务"></a>构造 <code>CRIService</code> 服务</h2><h3 id="criService-结构体定义"><a href="#criService-结构体定义" class="headerlink" title="criService 结构体定义"></a><code>criService</code> 结构体定义</h3><p><code>pkg/cri/server/service.go:71</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> criService <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// cri 配置</span></span><br><span class="line">config criconfig.Config</span><br><span class="line"><span class="comment">// 镜像文件系统路径</span></span><br><span class="line">imageFSPath <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 模拟操作系统级操作</span></span><br><span class="line">os osinterface.OS</span><br><span class="line"><span class="comment">// sandboxes 相关资源</span></span><br><span class="line">sandboxStore *sandboxstore.Store</span><br><span class="line"><span class="comment">// 存储所有 sandbox name 保证其唯一性</span></span><br><span class="line">sandboxNameIndex *registrar.Registrar</span><br><span class="line"><span class="comment">// 存储 containers 相关资源</span></span><br><span class="line">containerStore *containerstore.Store</span><br><span class="line"><span class="comment">// 存储所有 container name 保证其唯一性</span></span><br><span class="line">containerNameIndex *registrar.Registrar</span><br><span class="line"><span class="comment">// 存储 images 相关资源</span></span><br><span class="line">imageStore *imagestore.Store</span><br><span class="line"><span class="comment">// 存储所有 snapshots 信息</span></span><br><span class="line">snapshotStore *snapshotstore.Store</span><br><span class="line"><span class="comment">// netPlugin 用于运行/停止 pod sandbox 时 配置/清除 网络</span></span><br><span class="line">netPlugin <span class="keyword">map</span>[<span class="keyword">string</span>]cni.CNI</span><br><span class="line"><span class="comment">// client 为 containerd 客户端实例</span></span><br><span class="line">client *containerd.Client</span><br><span class="line"><span class="comment">// streamServer 为处理 container streaming 请求的服务端</span></span><br><span class="line">streamServer streaming.Server</span><br><span class="line"><span class="comment">// eventMonitor 为监控 containerd events 的监视器</span></span><br><span class="line">eventMonitor *eventMonitor</span><br><span class="line"><span class="comment">// initialized 表明所有服务是否已经初始化了，在 server 被初始化之前，所有的 GRPC 服务必须返回 error</span></span><br><span class="line">initialized atomic.Bool</span><br><span class="line"><span class="comment">// cniNetConfMonitor 用于重载 cni network 配置，当位于 network conf dir 中的配置文件发生可用变化时需要重载配置</span></span><br><span class="line">cniNetConfMonitor <span class="keyword">map</span>[<span class="keyword">string</span>]*cniNetConfSyncer</span><br><span class="line"><span class="comment">// baseOCISpecs 包含通过 Runtime.BaseRuntimeSpec 缓存的 OCI specs</span></span><br><span class="line">baseOCISpecs <span class="keyword">map</span>[<span class="keyword">string</span>]*oci.Spec</span><br><span class="line"><span class="comment">// allCaps 为 capabilities 列表，当为空时， 从 /proc/self/status 中解析获取</span></span><br><span class="line">allCaps []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// unpackDuplicationSuppressor 用于保证只有唯一一个 fetch request 或者 unpack handler 来处理 </span></span><br><span class="line">unpackDuplicationSuppressor kmutex.KeyedLocker</span><br><span class="line"><span class="comment">// nri 用于在处理 CRI 请求的时候回调 NRI</span></span><br><span class="line">nri *nri.API</span><br><span class="line"><span class="comment">// containerEventsChan 用于捕获 container 事件，并将其发送到 GetContainerEvents 调用者 </span></span><br><span class="line">containerEventsChan <span class="keyword">chan</span> runtime.ContainerEventResponse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewCRIService-构造"><a href="#NewCRIService-构造" class="headerlink" title="NewCRIService 构造"></a><code>NewCRIService</code> 构造</h3><p><code>pkg/cri/server/service.go:123</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCRIService</span><span class="params">(config criconfig.Config, client *containerd.Client, nri *nri.API)</span> <span class="params">(CRIService, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">labels := label.NewStore()</span><br><span class="line">c := &amp;criService&#123;</span><br><span class="line">config:                      config,</span><br><span class="line">client:                      client,</span><br><span class="line">os:                          osinterface.RealOS&#123;&#125;,</span><br><span class="line">sandboxStore:                sandboxstore.NewStore(labels),</span><br><span class="line">containerStore:              containerstore.NewStore(labels),</span><br><span class="line">imageStore:                  imagestore.NewStore(client),</span><br><span class="line">snapshotStore:               snapshotstore.NewStore(),</span><br><span class="line">sandboxNameIndex:            registrar.NewRegistrar(),</span><br><span class="line">containerNameIndex:          registrar.NewRegistrar(),</span><br><span class="line">initialized:                 atomic.NewBool(<span class="literal">false</span>),</span><br><span class="line">netPlugin:                   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]cni.CNI),</span><br><span class="line">unpackDuplicationSuppressor: kmutex.New(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> figure out a proper channel size.</span></span><br><span class="line">c.containerEventsChan = <span class="built_in">make</span>(<span class="keyword">chan</span> runtime.ContainerEventResponse, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SnapshotService 检查</span></span><br><span class="line"><span class="keyword">if</span> client.SnapshotService(c.config.ContainerdConfig.Snapshotter) == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to find snapshotter %q&quot;</span>, c.config.ContainerdConfig.Snapshotter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 镜像文件系统路径构造</span></span><br><span class="line">c.imageFSPath = imageFSPath(config.ContainerdRootDir, config.ContainerdConfig.Snapshotter)</span><br><span class="line">logrus.Infof(<span class="string">&quot;Get image filesystem path %q&quot;</span>, c.imageFSPath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冗余设计用于在 非 windows 和  linux 系统汇中初始化</span></span><br><span class="line"><span class="keyword">if</span> err := c.initPlatform(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;initialize platform: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 stream server</span></span><br><span class="line">c.streamServer, err = newStreamServer(c, config.StreamServerAddress, config.StreamServerPort, config.StreamIdleTimeout)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create stream server: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 event monitor</span></span><br><span class="line">c.eventMonitor = newEventMonitor(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 cni net conf monitor</span></span><br><span class="line">c.cniNetConfMonitor = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*cniNetConfSyncer)</span><br><span class="line"><span class="keyword">for</span> name, i := <span class="keyword">range</span> c.netPlugin &#123;</span><br><span class="line">path := c.config.NetworkPluginConfDir</span><br><span class="line"><span class="keyword">if</span> name != defaultNetworkPlugin &#123;</span><br><span class="line"><span class="keyword">if</span> rc, ok := c.config.Runtimes[name]; ok &#123;</span><br><span class="line">path = rc.NetworkPluginConfDir</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> path != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">m, err := newCNINetConfSyncer(path, i, c.cniLoadOptions())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create cni conf monitor for %s: %w&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br><span class="line">c.cniNetConfMonitor[name] = m</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预加载 base OCI specs</span></span><br><span class="line">c.baseOCISpecs, err = loadBaseOCISpecs(&amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 sandbox controllers(pod sandbox controller and remote shim controller)</span></span><br><span class="line">c.sandboxControllers[criconfig.ModePodSandbox] = podsandbox.New(config, client, c.sandboxStore, c.os, c, c.baseOCISpecs)</span><br><span class="line">c.sandboxControllers[criconfig.ModeShim] = client.SandboxController()</span><br><span class="line"></span><br><span class="line">c.nri = nri</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于 <a href="https://wiki.gentoo.org/wiki/SELinux/Labels#:~:text=The%20label%20of%20a%20process%20is%20decided%20by,will%20not%20be%20allowed%20by%20the%20SELinux%20policy.">SELinux-Label详解</a></p></blockquote><h2 id="启动-CRI-Service"><a href="#启动-CRI-Service" class="headerlink" title="启动 CRI Service"></a>启动 CRI Service</h2><p><code>pkg/cri/server/service.go:207</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *criService)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">logrus.Info(<span class="string">&quot;Start subscribing containerd event&quot;</span>)</span><br><span class="line"><span class="comment">// 注册 event 事件订阅者</span></span><br><span class="line">c.eventMonitor.subscribe(c.client)</span><br><span class="line"></span><br><span class="line">logrus.Infof(<span class="string">&quot;Start recovering state&quot;</span>)</span><br><span class="line"><span class="comment">// 通过 containerd 和 status checkpoint 恢复 system 状态</span></span><br><span class="line"><span class="keyword">if</span> err := c.<span class="built_in">recover</span>(ctrdutil.NamespacedContext()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to recover state: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start event handler.</span></span><br><span class="line">logrus.Info(<span class="string">&quot;Start event monitor&quot;</span>)</span><br><span class="line"><span class="comment">// 启动 eventMonitor</span></span><br><span class="line">eventMonitorErrCh := c.eventMonitor.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start snapshot stats syncer, it doesn&#x27;t need to be stopped.</span></span><br><span class="line">logrus.Info(<span class="string">&quot;Start snapshots syncer&quot;</span>)</span><br><span class="line"><span class="comment">// 构造 snapshotSyncer</span></span><br><span class="line">snapshotsSyncer := newSnapshotsSyncer(</span><br><span class="line">c.snapshotStore,</span><br><span class="line">c.client.SnapshotService(c.config.ContainerdConfig.Snapshotter),</span><br><span class="line">time.Duration(c.config.StatsCollectPeriod)*time.Second,</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 启动 snapshotsSyncer</span></span><br><span class="line">snapshotsSyncer.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 CNI network conf syncers</span></span><br><span class="line">cniNetConfMonitorErrCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="built_in">len</span>(c.cniNetConfMonitor))</span><br><span class="line"><span class="keyword">var</span> netSyncGroup sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> name, h := <span class="keyword">range</span> c.cniNetConfMonitor &#123;</span><br><span class="line">netSyncGroup.Add(<span class="number">1</span>)</span><br><span class="line">logrus.Infof(<span class="string">&quot;Start cni network conf syncer for %s&quot;</span>, name)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(h *cniNetConfSyncer)</span></span> &#123;</span><br><span class="line">cniNetConfMonitorErrCh &lt;- h.syncLoop()</span><br><span class="line">netSyncGroup.Done()</span><br><span class="line">&#125;(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(c.cniNetConfMonitor) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">netSyncGroup.Wait()</span><br><span class="line"><span class="built_in">close</span>(cniNetConfMonitorErrCh)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 streaming server.</span></span><br><span class="line">logrus.Info(<span class="string">&quot;Start streaming server&quot;</span>)</span><br><span class="line">streamServerErrCh := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(streamServerErrCh)</span><br><span class="line"><span class="keyword">if</span> err := c.streamServer.Start(<span class="literal">true</span>); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class="line">logrus.WithError(err).Error(<span class="string">&quot;Failed to start streaming server&quot;</span>)</span><br><span class="line">streamServerErrCh &lt;- err</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 NRI 中注册CRI domain</span></span><br><span class="line"><span class="keyword">if</span> err := c.nri.Register(&amp;criImplementation&#123;c&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to set up NRI for CRI service: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 server 为 初始化状态. GRPC services 正式工作.</span></span><br><span class="line">c.initialized.Set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eventMonitorErr, streamServerErr, cniNetConfMonitorErr error</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> eventMonitorErr = &lt;-eventMonitorErrCh:</span><br><span class="line"><span class="keyword">case</span> streamServerErr = &lt;-streamServerErrCh:</span><br><span class="line"><span class="keyword">case</span> cniNetConfMonitorErr = &lt;-cniNetConfMonitorErrCh:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := c.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to stop cri service: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := &lt;-eventMonitorErrCh; err != <span class="literal">nil</span> &#123;</span><br><span class="line">eventMonitorErr = err</span><br><span class="line">&#125;</span><br><span class="line">logrus.Info(<span class="string">&quot;Event monitor stopped&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := &lt;-streamServerErrCh; err != <span class="literal">nil</span> &#123;</span><br><span class="line">streamServerErr = err</span><br><span class="line">&#125;</span><br><span class="line">logrus.Info(<span class="string">&quot;Stream server stopped&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> eventMonitorErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;event monitor error: %w&quot;</span>, eventMonitorErr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> streamServerErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;stream server error: %w&quot;</span>, streamServerErr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cniNetConfMonitorErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cni network conf monitor error: %w&quot;</span>, cniNetConfMonitorErr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程架构图整理"><a href="#流程架构图整理" class="headerlink" title="流程架构图整理"></a>流程架构图整理</h2><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/Cri-work-flow.png" alt="CRI-work-flow"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;containerd-v1.7.0&lt;br&gt;此篇正式开启插件启用流程分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分</summary>
      
    
    
    
    <category term="contaierd" scheme="http://kiragoo.github.com/categories/contaierd/"/>
    
    
    <category term="容器" scheme="http://kiragoo.github.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="contaierd" scheme="http://kiragoo.github.com/tags/contaierd/"/>
    
  </entry>
  
  <entry>
    <title>containerd源码分析-[1]启动流程</title>
    <link href="http://kiragoo.github.com/archives/a46d2134.html"/>
    <id>http://kiragoo.github.com/archives/a46d2134.html</id>
    <published>2023-04-03T12:27:21.000Z</published>
    <updated>2023-04-03T12:56:15.486Z</updated>
    
    <content type="html"><![CDATA[<p>根据官网<a href="https://containerd.io/">containerd.io</a>的简介，可以得知 <code>containerd</code> 作为容器的生命周期管理。其在整个容器生态的组织架构中的职责如下:<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/architecture.png" alt="architecture">。</p><h1 id="如下分析-containerd-的启动流程"><a href="#如下分析-containerd-的启动流程" class="headerlink" title="如下分析 containerd 的启动流程"></a>如下分析 <code>containerd</code> 的启动流程</h1><blockquote><p>基于 containerd-v1.7.0 版本分析</p></blockquote><p>入口代码其实比较简单，具体如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd/containerd/main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">app := command.App()</span><br><span class="line"><span class="keyword">if</span> err := app.Run(os.Args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;containerd: %s\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>command.App 关键逻辑如下：<ul><li>flags 构造</li><li>注册插件，重点在于 plugin.Init 初始化构造</li><li>启动  TCPServer、GCPServer、TTRPCServer</li></ul></li></ul><p>流程图大纲如下：<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/containerd-run.png" alt="containerd-run"></p><blockquote><p>后续会结合具体的插件进行明细示例分析。</p></blockquote>]]></content>
    
    
    <summary type="html">containerd 源码分析</summary>
    
    
    
    <category term="containerd" scheme="http://kiragoo.github.com/categories/containerd/"/>
    
    
    <category term="容器" scheme="http://kiragoo.github.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="containerd" scheme="http://kiragoo.github.com/tags/containerd/"/>
    
  </entry>
  
  <entry>
    <title>SR-IOV VF 网卡命名问题记录</title>
    <link href="http://kiragoo.github.com/archives/c882714e.html"/>
    <id>http://kiragoo.github.com/archives/c882714e.html</id>
    <published>2023-04-03T09:05:37.000Z</published>
    <updated>2023-04-03T09:31:31.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SR-IOV-VF-网卡命名问题简单记录下"><a href="#SR-IOV-VF-网卡命名问题简单记录下" class="headerlink" title="SR-IOV VF 网卡命名问题简单记录下"></a>SR-IOV VF 网卡命名问题简单记录下</h1><p>最近工作项目中通过 <code>KVM</code> + <code>SR-IOV VF</code> 来构建虚拟网关节点，在资源实施规划部署时需要对每个网络平面的网卡进行统一化的命名，具体形如<br><code>Domain Node Name</code> 和 <code>Admin Node Name</code> 网卡都有统一的命名规范。</p><h2 id="通过业务脚本实现对应网卡及-Slot-配置文件"><a href="#通过业务脚本实现对应网卡及-Slot-配置文件" class="headerlink" title="通过业务脚本实现对应网卡及 Slot 配置文件"></a>通过业务脚本实现对应网卡及 <code>Slot</code> 配置文件</h2><p>通过 <code>virsh</code> atach 网卡。eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh attach-device <span class="variable">$&#123;NODE_NAME&#125;</span> <span class="variable">$&#123;XML_CONFIG&#125;</span> --config</span><br></pre></td></tr></table></figure><p>为了保证生效识别到，最好通过 <code>virsh shutdown $&#123;NODE_NAME&#125;</code> 及 <code>virsh start $&#123;NODE_NAME&#125;</code> 来拉起网卡。<br>由于时间问题，具体的环境已经没有这里就不做贴图了。</p><p>这个时候通过 <code>ip a</code> 能够发现识别到网卡，此时借鉴如下 <img src="https://www.thegeekdiary.com/how-to-set-a-custom-interface-name-with-networkmanager-in-centos-rhel-7/" alt="How to Set a custom Interface Name With NetworkManager in Centos/RHEL 7"> 都不行。</p><p>通过自己的理解和调研，其实以上介绍的就是通过对  <code>/etc/udev/rules.d</code> 进行命名配置让 <code>kennel</code> 在系统启动引导阶段进行网卡重命名。</p><p>后面通过另外一种方式绕了一层：</p><ul><li>首先对原有 <code>/etc/default/grub</code> 配置文件进行配置， <code>mv /etc/default/grub /etc/default/grub.bak</code></li><li>配置 <code>/etc/default/grub</code> 内容：</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=&quot;$(sed &#x27;s, release .*$,,g&#x27; /etc/system-release)&quot;</span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_DISABLE_SUBMENU=true</span><br><span class="line">GRUB_TERMINAL_OUTPUT=&quot;ofconsole&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rd.lvm.lv=cl/root rd.lvm.lv=cl/swap net.ifnames=0 rhgb quiet&quot;  &gt;&gt; 添加 net.ifnames=0 重新生成网卡命名配置规范</span><br><span class="line">GRUB_DISABLE_RECOVERY=&quot;true&quot;</span><br><span class="line">GRUB_ENABLE_BLSCFG=true</span><br><span class="line">GRUB_TERMINFO=&quot;terminfo -g 80x24 console&quot;</span><br><span class="line">GRUB_DISABLE_OS_PROBER=true</span><br></pre></td></tr></table></figure><ul><li>生成启动文件 <code>grub2-mkconfig -o /boot/grub2/grub.cfg</code></li><li>重启虚机 <code>reboot</code></li></ul><p>通过 <code>ip a</code> 查看虚机网卡命名是否生效：<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/vf-interface.png" alt="VF-Interface"></p><h2 id="对网卡进行配置"><a href="#对网卡进行配置" class="headerlink" title="对网卡进行配置"></a>对网卡进行配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nmcli c add con-name $&#123;C_NAME&#125; type ethernet ifname $&#123;IF_NAME&#125; ipv4.address 172.18.1.67/26</span><br><span class="line">nmcli c mod $&#123;C_NAME&#125; ipv4.method static</span><br><span class="line">nmcli c mod $&#123;C_NAME&#125; connection.autoconnect yes</span><br><span class="line">nmcli c mod $&#123;C_NAME&#125; 802-3-ethernet.mtu 9000</span><br><span class="line">nmcli c mod $&#123;C_NAME&#125; ipv6.addr-gen-mode eui64</span><br><span class="line">nmcli c up $&#123;C_NAME&#125;</span><br></pre></td></tr></table></figure><p>由于之前将 <code>Github</code> 作为图床，怎么说呢，不可控性太多了，今天就用 <code>oss</code> 配置了下，后面迁移啥的也比较方便，还是专业的产品做专业的事情吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SR-IOV-VF-网卡命名问题简单记录下&quot;&gt;&lt;a href=&quot;#SR-IOV-VF-网卡命名问题简单记录下&quot; class=&quot;headerlink&quot; title=&quot;SR-IOV VF 网卡命名问题简单记录下&quot;&gt;&lt;/a&gt;SR-IOV VF 网卡命名问题简单记录下&lt;/</summary>
      
    
    
    
    <category term="Linux" scheme="http://kiragoo.github.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://kiragoo.github.com/tags/Linux/"/>
    
    <category term="Network" scheme="http://kiragoo.github.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>kubebuilder 去 kube-rbac-proxy 体验</title>
    <link href="http://kiragoo.github.com/archives/4df09d70.html"/>
    <id>http://kiragoo.github.com/archives/4df09d70.html</id>
    <published>2022-04-26T10:12:36.000Z</published>
    <updated>2023-04-03T08:26:55.906Z</updated>
    
    <content type="html"><![CDATA[<p>安利一波广告，欢迎大家试用目前本人 maintain 的<a href="https://github.com/emqx/emqx-operator"><code>EMQX Kubernete Operator</code></a></p><p>最近在社区中接到用户反馈<a href="https://github.com/emqx/emqx-operator/issues/168">Release manifests has broken metrics</a><br>描述如下：<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/metrics-issue.png" alt="issue-info"><br>使用 <code>release-1.1.5</code> 版本，看到对于目前对于 <code>Operatlr</code> 的 <code>metrics</code> 保护机制是采用的 <code>kube-rbac-proxy</code>，此处相关的内容也可以通过查看 <a href="https://book.kubebuilder.io/reference/metrics.html"><code>kubebuilder</code>官方文档</a>进行具体的阅读。</p><p>根据 <code>Issue</code> 反馈其实很快能定位到应该是 <code>Service</code> 没有匹配的 <code>Container Port</code>,看下 <code>release-1.1.5</code> 中的代码，如下<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/release-1.1.5-manifests.png" alt="release-1.1.5-manifests"><br>可以看到 <code>emqx-operator-controller-manager-metrics-service</code> 中的内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">control-plane:</span> <span class="string">controller-manager</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">emqx-operator-controller-manager-metrics-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">emqx-operator-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span>  <span class="comment"># 配置了  https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8443</span>   <span class="comment"># 端口是 8443</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">control-plane:</span> <span class="string">controller-manager</span></span><br></pre></td></tr></table></figure><p>而 <code>Operator</code> 相应的 <code>Deployment</code> 中 <code>.spec.containers.ports</code> 内容如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9443</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">webhook-server</span> <span class="comment">#只存在 webhook-server 相关的配置</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p>果不其然，确实这块的配置缺少了，但是考虑到目前在私有化交付或者公有化的交付过程中的保护机制，以及一些镜像维护的成本先暂不对外使用基于 <code>kube-rbac-proxy</code> 的 <code>Pod</code> 内部权限检查的机制，那么我们就得针对于 <code>Metrics</code> 的 <code>EndPoint</code> 提供一套默认的配置，方便使用者能够针对 <code>/Metrics</code> 的 <code>EndPoint</code> 进行 <code>metrics</code> 采集。</p><h1 id="基于-kustomize-的-config-维护"><a href="#基于-kustomize-的-config-维护" class="headerlink" title="基于 kustomize 的 config 维护"></a>基于 <code>kustomize</code> 的 <code>config</code> 维护</h1><p>关于 <code>kustomize</code> 的基础这里就不阐述了，重点关注下 <code>config/default/kustomization.yaml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bases:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../crd</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../rbac</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../manager</span></span><br><span class="line"><span class="comment"># [WEBHOOK] To enable webhook, uncomment all the sections with [WEBHOOK] prefix including the one in</span></span><br><span class="line"><span class="comment"># crd/kustomization.yaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../webhook</span></span><br><span class="line"><span class="comment"># [CERTMANAGER] To enable cert-manager, uncomment all sections with &#x27;CERTMANAGER&#x27;. &#x27;WEBHOOK&#x27; components are required.</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../certmanager</span></span><br><span class="line"><span class="comment"># [PROMETHEUS] To enable prometheus monitor, uncomment all sections with &#x27;PROMETHEUS&#x27;.</span></span><br><span class="line"><span class="comment">#- ../prometheus 此处目前是需要部署 对应的 ServiceMonitor 的 目前暂不开放此配置，有能力的用户可以自己generate yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">patchesStrategicMerge:</span></span><br><span class="line"><span class="comment"># Protect the /metrics endpoint by putting it behind auth.</span></span><br><span class="line"><span class="comment"># If you want your controller-manager to expose the /metrics</span></span><br><span class="line"><span class="comment"># endpoint w/o any authn/z, please comment the following line.</span></span><br><span class="line"><span class="comment"># - manager_auth_proxy_patch.yaml  # 重点就是此时的patch.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mount the controller config file for loading manager configurations</span></span><br><span class="line"><span class="comment"># through a ComponentConfig type</span></span><br><span class="line"><span class="comment">#- manager_config_patch.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [WEBHOOK] To enable webhook, uncomment all the sections with [WEBHOOK] prefix including the one in</span></span><br><span class="line"><span class="comment"># crd/kustomization.yaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">manager_webhook_patch.yaml</span></span><br></pre></td></tr></table></figure><p>此时看关联的 <code>patch.yaml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This patch inject a sidecar container which is a HTTP proxy for the</span></span><br><span class="line"><span class="comment"># controller manager, it performs RBAC authorization against the Kubernetes API using SubjectAccessReviews.</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">controller-manager</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kube-rbac-proxy</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gcr.io/kubebuilder/kube-rbac-proxy:v0.8.0</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--secure-listen-address=0.0.0.0:8443&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--upstream=http://127.0.0.1:8080/&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--logtostderr=true&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--v=10&quot;</span></span><br><span class="line">        <span class="attr">ports:</span> <span class="comment">#重点关注点，因为 patch 文件被注释了，所以关于这段patch 内容就没有生成，所以出现了 issue 出现的问题</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8443</span> </span><br><span class="line">          <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">manager</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--health-probe-bind-address=:8081&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--metrics-bind-address=127.0.0.1:8080&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;--leader-elect&quot;</span></span><br></pre></td></tr></table></figure><p>基于交付场景的考虑，目前在工程中暂不开放 <code>manager_auth_proxy</code> 的配置，但是为了让用户可以对 <code>metrics</code> 进行相关的查看，我们需要提供默认的配置，同时还要让用户对工程项目的配置最小化改动，最终的方案是提供基于 <code>http:8080</code> 的默认配置，追加一套 <code>patch</code> 文件，当有能力维护的用户想要自定义的时候他可以取消对 <code># - manager_auth_proxy_patch.yaml</code> 的配置，实际上是触发了 <code>patch$delete</code> 动作。</p><p>明细的改动可以查看<a href="https://github.com/emqx/emqx-operator/releases/tag/1.1.6">release-1.1.6</a>去了解。</p><p>最后还是发版快乐，后续的 <code>RoadMap</code> 已经开始 <code>1.2.x</code> 的计划了，将进行 <code>.spec</code> 以及事件日志以及状态采集的优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安利一波广告，欢迎大家试用目前本人 maintain 的&lt;a href=&quot;https://github.com/emqx/emqx-operator&quot;&gt;&lt;code&gt;EMQX Kubernete Operator&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近在社区中接到用户反馈&lt;</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="kubebuilder" scheme="http://kiragoo.github.com/tags/kubebuilder/"/>
    
  </entry>
  
  <entry>
    <title>通过 OPA 运行 Kubernetes Pod Security Policy</title>
    <link href="http://kiragoo.github.com/archives/a459e2be.html"/>
    <id>http://kiragoo.github.com/archives/a459e2be.html</id>
    <published>2022-04-26T04:15:05.000Z</published>
    <updated>2023-04-03T08:26:55.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://www.infracloud.io/blogs/kubernetes-pod-security-policies-opa/?utm_sq=gggb8083m5">Kubernetes Pod Security Policies with Open Policy Agent</a></p></blockquote><p>Kubernetes是当今云原生生态系统中最流行的容器编排平台。因此，Kubernetes的安全性也是一个越来越令人感兴趣和关注的领域。</p><p>在这篇博文中，首先我将讨论Pod安全策略准入控制器。然后我们将看到Open Policy Agent如何实现Pod安全策略。事实上，在<a href="https://www.infracloud.io/blogs/kubecon-2019-us-day-1-recap/">Kubecon + CloudNaticeCon North America 2019</a>的Kubernetes SIG Auth期间，Open Policy Agent / Gatekeeper被提及为Pod安全策略的潜在替代品。</p><p>首先，简要了解一下容器、安全和准入控制器。</p><h1 id="容器和安全概述"><a href="#容器和安全概述" class="headerlink" title="容器和安全概述"></a>容器和安全概述</h1><h2 id="Kubernetes-中的容器是什么？"><a href="#Kubernetes-中的容器是什么？" class="headerlink" title="Kubernetes 中的容器是什么？"></a><code>Kubernetes</code> 中的容器是什么？</h2><p>容器是轻量级的，可移植的，易于管理。在同一主机上运行的容器没有单独的物理/虚拟机。换句话说，容器共享资源、硬件和它们所运行的主机的操作系统内核。因此，使用者围绕哪些进程可以在容器内运行、这些进程有哪些权限、容器是否允许权限升级、使用哪些镜像等问题拥有适当的安全性变得非常重要。</p><h2 id="kubernetes-中的-Pod-是什么？"><a href="#kubernetes-中的-Pod-是什么？" class="headerlink" title="kubernetes 中的 Pod 是什么？"></a><code>kubernetes</code> 中的 <code>Pod</code> 是什么？</h2><p>Pod是Kubernetes应用程序的基本执行单元，是Kubernetes对象模型中最小、最简单的单元，由你创建或部署。它是一组由一个或多个容器组成的共享存储/网络，以及如何运行这些容器的规范。</p><p>因此，在容器上执行安全策略时，我们检查并应用Pod规范的安全策略。那么，这些政策是如何执行的呢？使用准入控制器。</p><h1 id="什么是-Admission-Controller"><a href="#什么是-Admission-Controller" class="headerlink" title="什么是 Admission Controller ?"></a>什么是 <code>Admission Controller</code> ?</h1><p>准入控制器是kube-apiserver的一部分。在配置被存储在集群设置（etcd）之前，它们拦截对Kubernetes API服务器的请求。一个准入控制器可以是验证性的（验证传入的请求），也可以是突变性的（修改传入的请求），或者两者都是。请参考<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do">Kubernetes文档</a>，快速了解各种准入控制器的情况。</p><h1 id="使用-Open-Policy-Agent-作为-Admission-Controller"><a href="#使用-Open-Policy-Agent-作为-Admission-Controller" class="headerlink" title="使用 Open Policy Agent 作为 Admission Controller"></a>使用 <code>Open Policy Agent</code> 作为 <code>Admission Controller</code></h1><p>开放政策代理（OPA）是一个开源的、通用的政策引擎，它使把政策写成代码成为可能。OPA提供了一种高水平的声明性语言–Rego–来实现政策即代码。使用OPA，我们可以在微服务、CI/CD管道、API网关等方面执行策略。OPA最重要的用例之一是Kubernetes的策略执行，作为一个准入控制器。</p><p>这些策略是在Rego中编写的，并加载到OPA中，作为Kubernetes集群的准入控制器运行。OPA将根据Rego策略评估对Kubernetes API服务器的任何资源创建/更新/删除请求。如果该请求满足所有的策略，该请求就被允许。但即使有一个策略失败，请求也会被拒绝。</p><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/admission-control.png" alt="Admission Control"></p><p>关于<code>OPA</code> 及 <code>Rego</code> 的更多详情，请阅读<a href="https://www.openpolicyagent.org/docs/latest/"><code>Rego Docs</code></a></p><p>现在，让我们来看看Pod安全策略的细节。</p><h1 id="Pod-Security-Policy-是什么？"><a href="#Pod-Security-Policy-是什么？" class="headerlink" title="Pod Security Policy 是什么？"></a><code>Pod Security Policy</code> 是什么？</h1><p>Pod安全策略（PSP）是一个集群级的资源，作为一个准入控制器来实现。PSP允许用户将安全要求转化为管理Pod规格的具体政策。起初，当一个PodSecurityPolicy资源被创建时，它什么都不做。而为了使用它，请求用户或目标pod的服务账户必须通过允许 “使用 “动词来授权使用该策略。你可以参考<a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#enabling-pod-security-policies">Kubernetes文档</a>中的启用Pod安全策略。</p><p>请注意，PSP接纳控制器既是验证接纳控制器，又是变异接纳控制器。对于一些参数，PSP录取控制器使用默认值来改变传入的请求。此外，顺序始终是先变异，然后再验证。</p><h2 id="我们可以使用-PSP-控制哪些参数？"><a href="#我们可以使用-PSP-控制哪些参数？" class="headerlink" title="我们可以使用 PSP 控制哪些参数？"></a>我们可以使用 <code>PSP</code> 控制哪些参数？</h2><p>下表简要介绍了PSP中使用的各种参数和字段。详细解释见<a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#policy-reference">Kubernetes文档</a>。</p><table><thead><tr><th>Field</th><th>Kubernetes API Reference (Kind – Version – Group )</th><th>Control Aspect</th></tr></thead><tbody><tr><td>privileged</td><td><a href="https://v1-18.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#securitycontext-v1-core">SecurityContext v1 core</a></td><td>Running containers in privileged mode</td></tr><tr><td>hostPID, hostIPC</td><td>PodSpec v1 core (<a href="https://v1-18.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core">https://v1-18.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#podspec-v1-core</a>)</td><td>Usage of host namespaces</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><h1 id="如何使用-OPA-来-实现-PSP"><a href="#如何使用-OPA-来-实现-PSP" class="headerlink" title="如何使用 OPA 来 实现 PSP ?"></a>如何使用 <code>OPA</code> 来 实现 <code>PSP</code> ?</h1><p>我在前面提到，Rego语言允许我们把任何自定义策略写成代码。这意味着，我们可以使用Rego编写上述的Pod安全策略，并将OPA作为一个准入控制器来执行。</p><p>让我们快速看下 <code>Rego</code> 实现 <code>privileged pod policy</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package kubernetes.admission</span><br><span class="line"></span><br><span class="line">deny[message] &#123;</span><br><span class="line">    #applies for Pod resources</span><br><span class="line">    input.request.kind.kind &#x3D;&#x3D; &quot;Pod&quot;</span><br><span class="line">    #loops through all containers in the request</span><br><span class="line">    container :&#x3D; input.request.object.spec.containers[_]</span><br><span class="line">    #for each container, check privileged field</span><br><span class="line">    container.securityContext.privileged</span><br><span class="line">    #if all above statements are true, return message</span><br><span class="line">    message :&#x3D; sprintf(&quot;Container %v runs in privileged mode.&quot;, [container.name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这个策略是做什么的呢？如果输入请求中的任何容器是作为特权容器运行的，它将返回一条信息。</p><h1 id="PSP-实践"><a href="#PSP-实践" class="headerlink" title="PSP 实践"></a><code>PSP</code> 实践</h1><p>让我们通过一个基于minikube的基本教程来看看这个策略的运作情况。首先，按照<a href="https://www.openpolicyagent.org/docs/latest/kubernetes-tutorial/">OPA文档</a>中的教程，将OPA设置为准入控制器。这个教程加载一个入口验证策略。取而代之的是，我们将加载上面显示的特权策略。</p><p>一旦OPA被设置为minikube上的接纳控制器，使用上面的策略创建一个文件priorleged.rego。然后，在 “OPA “命名空间中，将该策略创建一个<code>configmap</code>。</p><p><code>kubectl create configmap privileged-policy --from-file=privileged.rego -n opa</code></p><p>现在，让我们使用以下清单创建一个具有特权的容器的部署。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>当你尝试创建这个<code>pod</code>的时候，你将注意到因为<code>OPA</code>的存在而动作被拒绝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error from server (Container nginx runs in privileged mode.): error when creating &quot;privileged-deploy.yaml&quot;: admission webhook &quot;validating-webhook.openpolicyagent.org&quot; denied the request: Container nginx runs in privileged mode.</span><br></pre></td></tr></table></figure><p>同样，我们可以为其他Pod编写安全策略，并使用<code>OPA</code>进行强制执行。</p><p>在此篇教程中，为了简单起见我们使用<code>configmap</code>来加载策略，但这不是生产部署的最佳策略。在生产环境中，你可以从外部的 <code>bundle</code> 服务器中定期的下载 <code>OPA</code> 策略。你所有的策略可以在 <code>bundle</code> 服务中进行维护，另外 <code>OPA</code> 也会定期的下载来保持其最新状态。请查看<a href="https://www.openpolicyagent.org/docs/latest/external-data/#option-3-bundle-api"><code>Bundle API</code></a>了解更多信息。</p><p>简而言之，使用 <code>OPA</code> ，我们可以强制执行 <code>Pod</code> 安全策略。不仅如此，我们还可以使用相同的设置来执行任何其他自定义的安全/基于标准的政策。</p><h1 id="在PSP中应用OPA的几点关键益处"><a href="#在PSP中应用OPA的几点关键益处" class="headerlink" title="在PSP中应用OPA的几点关键益处"></a>在<code>PSP</code>中应用<code>OPA</code>的几点关键益处</h1><ul><li>可以在同一个准入控制器中管理所有的策略避免了分散的管理</li><li>完善了 <code>Policy-as-code</code> 在 <code>CICD</code> 中的实现</li><li>使得通过版本控制工具例如 <code>Git</code> 来维护 <code>OPA</code> 策略成为了可能， <code>OPA</code> 也提供了 <code>APIs</code> 来动态的管理策略并进行加载</li><li>根据自己的实施进行定制化的拒绝信息</li></ul><p>另外，我们也可以部署 <code>OPA</code> 作为 <code>mutating admission controller</code>。这样的话，你也可以完善 <code>PSP Admission Controller</code> 的 <code>mutating</code> 行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://www.infracloud.io/blogs/kubernetes-pod-security-policies-opa/?utm_sq=gggb8083m5&quot;&gt;Kubernetes Pod Security</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="PSP" scheme="http://kiragoo.github.com/tags/PSP/"/>
    
    <category term="OPA" scheme="http://kiragoo.github.com/tags/OPA/"/>
    
  </entry>
  
  <entry>
    <title>USING KUBE-RBAC-PROXY TO SECURE KUBERNETES WORKLOADS</title>
    <link href="http://kiragoo.github.com/archives/217459e6.html"/>
    <id>http://kiragoo.github.com/archives/217459e6.html</id>
    <published>2022-04-25T13:21:12.000Z</published>
    <updated>2023-04-03T08:26:55.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://www.brancz.com/2018/02/27/using-kube-rbac-proxy-to-secure-kubernetes-workloads/">USING KUBE-RBAC-PROXY TO SECURE KUBERNETES WORKLOADS</a></p></blockquote><p>在使用Prometheus监控Kubernetes集群时，我注意到一个反复出现的问题：Prometheus检索的指标可能包含敏感信息（例如，Prometheus节点导出器暴露了主机的内核版本），潜在的入侵者可能利用这些信息在各自的Kubernetes集群中钻营。所以我问自己一个问题。如何认证和授权来自Prometheus的请求，以便Prometheus（只有Prometheus）能够从Pod中运行的应用程序中检索指标？</p><p>在Prometheus中验证和授权指标端点的默认答案是使用TLS客户端证书，然而，由于发行、验证和轮换客户端证书会变得相当复杂，因此，Prometheus请求在大多数情况下根本没有经过验证和授权。</p><p>我建立了kube-rbac-proxy，这是一个针对单一上游的小型HTTP代理，可以使用SubjectAccessReviews对Kubernetes API执行RBAC授权。在这篇文章中，我想解释一下，它是如何使用Kubernetes RBAC来完成这个任务的。</p><h1 id="RBAC是如何在幕后工作的？"><a href="#RBAC是如何在幕后工作的？" class="headerlink" title="RBAC是如何在幕后工作的？"></a>RBAC是如何在幕后工作的？</h1><p>Kubernetes基于角色的访问控制（RBAC）本身只解决了一半的问题。顾名思义，它只涉及访问控制，意味着授权，而不是认证。在一个请求能够被授权之前，它需要被认证。简单地说：我们需要找出谁在执行这个请求。在Kubernetes中，服务自我认证的机制是ServiceAccount令牌。</p><p>Kubernetes API公开了验证ServiceAccount令牌的能力，使用所谓的TokenReview。TokenReview的响应仅仅是ServiceAccount令牌是否被成功验证，以及指定的令牌与哪个用户有关。kube-rbac-proxy期望ServiceAccount令牌在Authorization HTTP头中被指定，然后使用TokenReview对其进行验证。</p><p>在这一点上，一个请求已经被验证，但还没有被授权。与TokenReview平行，Kuberenetes有一个SubjectAccessReview，它是授权API的一部分。在SubjectAccessReview中，指定了一个预期的行动以及想要执行该行动的用户。在Prometheus请求度量的具体案例中，/metrics HTTP端点被请求。不幸的是，在Kubernetes中这不是一个完全指定的资源，然而，SubjectAccessReview资源也能够授权所谓的 “非资源请求”。但可能性是无穷的，例如：授权一个代理请求，SubjecAccessReview也可以检查以确保用户有服务/代理RBAC角色。</p><p>当用Prometheus监控Kubernetes时，那么Prometheus服务器可能已经拥有访问/metrics非资源url的权限，因为从Kubernetes apiserver检索指标需要同样的RBAC角色。</p><h1 id="kube-rbac-proxy"><a href="#kube-rbac-proxy" class="headerlink" title="kube-rbac-proxy"></a>kube-rbac-proxy</h1><p>现在已经解释了所有必要的部分，让我们看看kube-rbac-proxy是如何具体地验证和授权一个请求的，案例在本博文的开头就已经说明了。普罗米修斯从节点输出器中请求度量。</p><p>当Prometheus对node-exporter执行请求时，kube-rbac-proxy在它前面，kube-rbac-proxy用提供的ServiceAccount令牌执行TokenReview，如果TokenReview成功，它继续使用SubjectAccessReview来验证，ServiceAccount被授权访问/metrics HTTP端点。</p><p>可见，从Prometheus验证和授权请求的整个流程是这样的:<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/kube-rbac-proxy.png" alt="kube-rbac-proxy"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果你想做的是用一个静态授权配置文件来授权某些请求，你可能想看看kube-rbac-proxy。</p><p>虽然在你的工作负载中执行授权可能仍然有用–特别是当需要更精细的或特定的数据访问时–但很高兴知道在Kubernetes中，你有可用的工具，可以让你在花费时间之前走得更远。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://www.brancz.com/2018/02/27/using-kube-rbac-proxy-to-secure-kubernetes-workloads/&quot;&gt;USING KUBE-RBAC-PROXY T</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>利用 nektos/act debug github action locally</title>
    <link href="http://kiragoo.github.com/archives/7c305169.html"/>
    <id>http://kiragoo.github.com/archives/7c305169.html</id>
    <published>2022-04-06T14:35:37.000Z</published>
    <updated>2023-04-03T08:26:55.906Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道利用 <code>Github Action</code> 可以用来进行构建<code>CI</code>的流水线，通过构建对应的<code>jobs</code>来实现我们的期望效果，对于目前来说很多时候构建之后的效果目前只能在远端<code>repo</code>才能够看到最终的执行结果，那么我们是否有机会能够在本地构建，然后来类似<code>DEBUG</code>看到最后期望呢？这里我将介绍如何利用<code>nektos/act</code>这一利器来本地执行 <code>Github Action</code>。</p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>根据官方仓库的概览描述告诉了我们对于本地构建的急切缘由！</p><ul><li>及时的结果反馈。 通过本地构建我们无需通过 <code>commit/push</code> 的事件来触发远端<code>repo</code>的<code>action</code>。我们完全可以在本地进行模拟<code>Github Actions</code>所达到的效果，从而得到一个及时的结果信息反馈。</li><li>我们完全可以通过流式线形式的构建来替换 <code>Makefile</code> 文件</li></ul><h1 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h1><p>这里假设你已经具备基本的<code>Github Action</code>配置能力，且具备初步的使用能力，此篇章主要是对 <code>act</code> 的配置及使用。<br>安装完可以通过 <code>act -h</code> 进行简单的查看验证。<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/act-help.png" alt="act-help"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本人使用的是 <code>macos</code>，可以通过 <code>brew install act</code> 进行安装，其他 <code>os</code> 发行版可以参考官方仓库中的安装说明进行安装。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h3><p>在远端<code>Github  Action</code> 运行的时候实际上是提供了对应的 <code>vm</code> 资源进行构建，那么在本地的话，<code>act</code> 是提供一个虚机镜像在容器层面进行 <code>os</code> 的模拟，我这里使用的是默认的 <code>platform/docker-image</code>，当然也可以自定定义。执行的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">act -P &lt;platform&gt;&#x3D;&lt;docker-image&gt;</span><br></pre></td></tr></table></figure><p>如下是我本地的镜像:<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/act-image.png" alt="act-image"></p><h3 id="环境变量及密钥配置"><a href="#环境变量及密钥配置" class="headerlink" title="环境变量及密钥配置"></a>环境变量及密钥配置</h3><p>很多时候在公司内部我们使用的更多的是私有仓库，那么我们在项目工程容器化的时候会拉依赖涉及到私有仓库，在 <code>github</code> 上我们会配置对应的 <code>Action-&gt;secrets</code>，在远端运行<code>github action</code>的时候是有机会获取到的，但是在本地的话我们如何传递呢？</p><p><code>act</code> 支持 <code>secrets</code> 的配置，可以通过命令参数直接传递也可以通过在本地写入配置文件进行配置。<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/act-secrets.png" alt="act-secrets"></p>]]></content>
    
    
    <summary type="html">利用 nektos/act 本地执行 github action</summary>
    
    
    
    <category term="devops" scheme="http://kiragoo.github.com/categories/devops/"/>
    
    
    <category term="github action" scheme="http://kiragoo.github.com/tags/github-action/"/>
    
    <category term="act" scheme="http://kiragoo.github.com/tags/act/"/>
    
  </entry>
  
  <entry>
    <title>手撕client-go:如何编写CRD client</title>
    <link href="http://kiragoo.github.com/archives/ba22a6bc.html"/>
    <id>http://kiragoo.github.com/archives/ba22a6bc.html</id>
    <published>2021-12-24T12:46:08.000Z</published>
    <updated>2022-04-21T12:46:07.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求背景分析"><a href="#需求背景分析" class="headerlink" title="需求背景分析"></a>需求背景分析</h2><p>基于 <code>k8s</code> 的二次开发过程中，有些场景我们会定制化的去开发自己的 <code>CRD</code> + <code>Controller</code>，即 <code>Operator</code>来实现基于<code>k8s</code>的云原生化的部署与自动化运维功能，暂且称之为<strong>底层的基座能力</strong>。</p><p>如果我们想基于底层能力，并想要将其封装为控制台来供上层业务调用的话，我们需要有机会能够去控制与使用这样的接口能力，基于对<code>Client-go</code>的使用，也许有胖友会想到<code>dynamic client</code>的使用，但是作为设计与开发人员，我们应该清醒的认识到对于序列化与反序列化过程，扔一堆<code>map</code>是多么的头疼（除非恰巧业务开发人员与<code>Operator</code>设计设计者是同一人&gt;..&lt;）。</p><p>我们能不能有机会像使用<code>k8s</code> 中的原生资源如<code>Deployments</code>、<code>Service</code>等一样方便的去使用呢？</p><h2 id="必备概念与技能"><a href="#必备概念与技能" class="headerlink" title="必备概念与技能"></a>必备概念与技能</h2><p>在进行具体分析前，建议胖友先去了解下<a href="https://kubernetes.io/zh/docs/reference/using-api/api-concepts/"><code>Kubernetes API</code> 概念</a>，同时具备查阅<a href="https://v1-21.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/"><code>Kubernetes API</code></a>的能力。</p><p>为了方便举例，我在本地<code>k8s</code>集群注册了<a href="https://github.com/emqx/emqx-operator"><code>emqx-operator</code></a> 中的 <code>CRD</code>自定义资源，将其视为与 <code>k8s</code> 原生资源同等地位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emqxbrokers.apps.emqx.io                    2021-12-09T03:59:28Z</span><br><span class="line">emqxenterprises.apps.emqx.io                2021-12-09T03:59:28Z</span><br></pre></td></tr></table></figure><p>另外可以通过<code>kubectl api-version</code>查看其<code>API</code>相关信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> api-versions | grep emqx</span><br><span class="line">apps.emqx.io/v1beta1</span><br></pre></td></tr></table></figure><p>通过 <code>kubectl api-resoures</code> 查看相关 <code>Group</code>,<code>Version</code>,<code>Kind</code>信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> api-resources              </span><br><span class="line">NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND</span><br><span class="line">emqxbrokers                       emqx         apps.emqx.io/v1beta1                   <span class="literal">true</span>         EmqxBroker</span><br><span class="line">emqxenterprises                   emqx-ee      apps.emqx.io/v1beta1                   <span class="literal">true</span>         EmqxEnterprise</span><br></pre></td></tr></table></figure><p>相信胖友应该都掌握如上知识概念及具备如上的基础技能了。^.^</p><h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><p>关于 <code>client-go</code> 的官方文档描述还是蛮少的，作为设计与开发者，胖友们得具备源码分析能力。下面让我们切入<code>client-go</code> 官方 <code>Repo</code> 中。其中<code>examples</code>的<code>create-update-delete-deployment</code>的示例展示了如何使用<code>client-go</code>库来进行<code>rest</code>请求的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> kubeconfig *<span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> home := homedir.HomeDir(); home != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">kubeconfig = flag.String(<span class="string">&quot;kubeconfig&quot;</span>, filepath.Join(home, <span class="string">&quot;.kube&quot;</span>, <span class="string">&quot;config&quot;</span>), <span class="string">&quot;(optional) absolute path to the kubeconfig file&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kubeconfig = flag.String(<span class="string">&quot;kubeconfig&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;absolute path to the kubeconfig file&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Config 的初始化</span></span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(<span class="string">&quot;&quot;</span>, *kubeconfig)</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// clientset 的构造</span></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 resource client 进行 resource 资源的操作</span></span><br><span class="line">deploymentsClient := clientset.AppsV1().Deployments(apiv1.NamespaceDefault)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Deployment</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Creating deployment...&quot;</span>)</span><br><span class="line">result, err := deploymentsClient.Create(context.TODO(), deployment, metav1.CreateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Created deployment %q.\n&quot;</span>, result.GetObjectMeta().GetName())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update Deployment</span></span><br><span class="line">prompt()</span><br><span class="line">fmt.Println(<span class="string">&quot;Updating deployment...&quot;</span>)</span><br><span class="line"><span class="comment">//    You have two options to Update() this Deployment:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    1. Modify the &quot;deployment&quot; variable and call: Update(deployment).</span></span><br><span class="line"><span class="comment">//       This works like the &quot;kubectl replace&quot; command and it overwrites/loses changes</span></span><br><span class="line"><span class="comment">//       made by other clients between you Create() and Update() the object.</span></span><br><span class="line"><span class="comment">//    2. Modify the &quot;result&quot; returned by Get() and retry Update(result) until</span></span><br><span class="line"><span class="comment">//       you no longer get a conflict error. This way, you can preserve changes made</span></span><br><span class="line"><span class="comment">//       by other clients between Create() and Update(). This is implemented below</span></span><br><span class="line"><span class="comment">// using the retry utility package included with client-go. (RECOMMENDED)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// More Info:</span></span><br><span class="line"><span class="comment">// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency</span></span><br><span class="line"></span><br><span class="line">retryErr := retry.RetryOnConflict(retry.DefaultRetry, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Retrieve the latest version of Deployment before attempting update</span></span><br><span class="line"><span class="comment">// RetryOnConflict uses exponential backoff to avoid exhausting the apiserver</span></span><br><span class="line">result, getErr := deploymentsClient.Get(context.TODO(), <span class="string">&quot;demo-deployment&quot;</span>, metav1.GetOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> getErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Failed to get latest version of Deployment: %v&quot;</span>, getErr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result.Spec.Replicas = int32Ptr(<span class="number">1</span>)                           <span class="comment">// reduce replica count</span></span><br><span class="line">result.Spec.Template.Spec.Containers[<span class="number">0</span>].Image = <span class="string">&quot;nginx:1.13&quot;</span> <span class="comment">// change nginx version</span></span><br><span class="line">_, updateErr := deploymentsClient.Update(context.TODO(), result, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">return</span> updateErr</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> retryErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Update failed: %v&quot;</span>, retryErr))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Updated deployment...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// List Deployments</span></span><br><span class="line">    ...</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Listing deployments in namespace %q:\n&quot;</span>, apiv1.NamespaceDefault)</span><br><span class="line">list, err := deploymentsClient.List(context.TODO(), metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> list.Items &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot; * %s (%d replicas)\n&quot;</span>, d.Name, *d.Spec.Replicas)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete Deployment</span></span><br><span class="line">    ...</span><br><span class="line">fmt.Println(<span class="string">&quot;Deleting deployment...&quot;</span>)</span><br><span class="line">deletePolicy := metav1.DeletePropagationForeground</span><br><span class="line"><span class="keyword">if</span> err := deploymentsClient.Delete(context.TODO(), <span class="string">&quot;demo-deployment&quot;</span>, metav1.DeleteOptions&#123;</span><br><span class="line">PropagationPolicy: &amp;deletePolicy,</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Deleted deployment.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计的重点就在于如何设计与实现<code>CRD</code>对应的 <code>resource</code>的<code>clientset</code>。</p><h3 id="clientset-的设计"><a href="#clientset-的设计" class="headerlink" title="clientset 的设计"></a><code>clientset</code> 的设计</h3><p>通过源码我们发现实际上就是通过 <code>Config</code> 去构造 <code>rest http</code> 的客户端。</p><h4 id="NewForConfig"><a href="#NewForConfig" class="headerlink" title="NewForConfig"></a><code>NewForConfig</code></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewForConfig</span><span class="params">(c *rest.Config)</span> <span class="params">(*Clientset, error)</span></span> &#123;</span><br><span class="line">configShallowCopy := *c</span><br><span class="line"></span><br><span class="line"><span class="comment">// share the transport between all clients</span></span><br><span class="line">httpClient, err := rest.HTTPClientFor(&amp;configShallowCopy)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Clientset"><a href="#Clientset" class="headerlink" title="Clientset"></a><code>Clientset</code></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">Discovery() discovery.DiscoveryInterface</span><br><span class="line">    ...</span><br><span class="line">    AppsV1() appsv1.AppsV1Interface <span class="comment">// Deployment 资源调用接口</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Clientset <span class="keyword">struct</span> &#123;</span><br><span class="line">    *discovery.DiscoveryClient</span><br><span class="line">    ...</span><br><span class="line">    appsV1                       *appsv1.AppsV1Client</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里我们发现 <code>Clientset</code> 就是对 <code>AppSV1</code> 下具体资源比如<code>Deployment</code>的抽象，对外暴露引用，我们最终需要的也是提供这样的一个抽象层面。</p><p>实际上<code>AppsV1</code> 也是一个维度的抽象，让我们继续往下看:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppsV1Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">RESTClient() rest.Interface</span><br><span class="line">    ...</span><br><span class="line">DeploymentsGetter</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AppsV1Client is used to interact with features provided by the apps group.</span></span><br><span class="line"><span class="keyword">type</span> AppsV1Client <span class="keyword">struct</span> &#123;</span><br><span class="line">restClient rest.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AppsV1Client)</span> <span class="title">Deployments</span><span class="params">(namespace <span class="keyword">string</span>)</span> <span class="title">DeploymentInterface</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> newDeployments(c, namespace)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewForConfig</span><span class="params">(c *rest.Config)</span> <span class="params">(*AppsV1Client, error)</span></span> &#123;</span><br><span class="line">config := *c</span><br><span class="line">    <span class="comment">// 需要重点留意 setConfigDefaults(&amp;config)</span></span><br><span class="line"><span class="keyword">if</span> err := setConfigDefaults(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">httpClient, err := rest.HTTPClientFor(&amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NewForConfigAndClient(&amp;config, httpClient)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewForConfigAndClient</span><span class="params">(c *rest.Config, h *http.Client)</span> <span class="params">(*AppsV1Client, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> &amp;AppsV1Client&#123;client&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setConfigDefaults</span><span class="params">(config *rest.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要重点留意 gv</span></span><br><span class="line">gv := v1.SchemeGroupVersion</span><br><span class="line">config.GroupVersion = &amp;gv</span><br><span class="line">config.APIPath = <span class="string">&quot;/apis&quot;</span></span><br><span class="line">config.NegotiatedSerializer = scheme.Codecs.WithoutConversion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.UserAgent == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">config.UserAgent = rest.DefaultKubernetesUserAgent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AppsV1Client)</span> <span class="title">RESTClient</span><span class="params">()</span> <span class="title">rest</span>.<span class="title">Interface</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.restClient</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信看到这里我们已经有了清晰的认识了，实际上这里就是去构造对应具体<code>Resource</code>的<code>rest client</code>。</p><p><code>Resource</code> 的<code>client</code> 大体构造我们是有了，那么客户端如何知道去请求啥<code>URL</code>的了？</p><p>这里考察我们对概念的理解与掌握，我们应该对<code>SchemeGroupVersion</code>这样的关键变量有敏锐的捕捉能力，我们去看看这个<code>SchemeGroupVersion</code>究竟是啥？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GroupName is the group name use in this package</span></span><br><span class="line"><span class="keyword">const</span> GroupName = <span class="string">&quot;apps&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SchemeGroupVersion is group version used to register these objects</span></span><br><span class="line"><span class="keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;Group: GroupName, Version: <span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Resource</span><span class="params">(resource <span class="keyword">string</span>)</span> <span class="title">schema</span>.<span class="title">GroupResource</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> move SchemeBuilder with zz_generated.deepcopy.go to k8s.io/api.</span></span><br><span class="line"><span class="comment">// localSchemeBuilder and AddToScheme will stay in k8s.io/kubernetes.</span></span><br><span class="line">SchemeBuilder      = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">localSchemeBuilder = &amp;SchemeBuilder</span><br><span class="line">AddToScheme        = localSchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adds the list of known types to the given scheme.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKnownTypes</span><span class="params">(scheme *runtime.Scheme)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">&amp;Deployment&#123;&#125;,</span><br><span class="line">&amp;DeploymentList&#123;&#125;,</span><br><span class="line">&amp;StatefulSet&#123;&#125;,</span><br><span class="line">&amp;StatefulSetList&#123;&#125;,</span><br><span class="line">&amp;DaemonSet&#123;&#125;,</span><br><span class="line">&amp;DaemonSetList&#123;&#125;,</span><br><span class="line">&amp;ReplicaSet&#123;&#125;,</span><br><span class="line">&amp;ReplicaSetList&#123;&#125;,</span><br><span class="line">&amp;ControllerRevision&#123;&#125;,</span><br><span class="line">&amp;ControllerRevisionList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信看到这里一切都柳暗花明了，其实就是告知<code>k8s</code> 我注册了这些<code>schema</code>，<code>k8s</code> 知道了这些<code>Resource</code>的存在，那么当我去请求的<code>Resouce</code>操作的时候能够按照我们的预期达到功能实现。</p><h3 id="CRD-关键实现"><a href="#CRD-关键实现" class="headerlink" title="CRD 关键实现"></a><code>CRD</code> 关键实现</h3><p>那么对于自定义的 <code>CRD</code> 实现肯定少不了如上分心的<code>setConfigDefaults</code>实现，如下为针对与<code>emqx-operator</code>实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">emqxbrokerGVR = schema.GroupVersion&#123;Group: <span class="string">&quot;apps.emqx.io&quot;</span>, Version: <span class="string">&quot;v1beta1&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setConfigDefaults</span><span class="params">(config *rest.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">gv := emqxbrokerGVR</span><br><span class="line">config.GroupVersion = &amp;gv</span><br><span class="line">config.APIPath = <span class="string">&quot;/apis&quot;</span></span><br><span class="line">config.NegotiatedSerializer = scheme.Codecs.WithoutConversion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.UserAgent == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">config.UserAgent = rest.DefaultKubernetesUserAgent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里对于<code>Client</code>的构造就算结束了，这其中的彩蛋还包括请求<code>API</code>的<code>URL</code>。</p><h3 id="CRD-资源操作具体实现"><a href="#CRD-资源操作具体实现" class="headerlink" title="CRD 资源操作具体实现"></a><code>CRD</code> 资源操作具体实现</h3><p>如上我们主要讲述了如何去构造<code>client</code>，那么对于<code>CRD</code>的具体操作我们是如何实现的呢？</p><p>这里让我们将注意力再返回到<code>AppsV1Interface</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppsV1Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">RESTClient() rest.Interface</span><br><span class="line">    ...</span><br><span class="line">DeploymentsGetter</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们看看<code>DeploymentGetter</code>究竟是啥。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">type</span> DeploymentsGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">Deployments(namespace <span class="keyword">string</span>) DeploymentInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeploymentInterface has methods to work with Deployment resources.</span></span><br><span class="line"><span class="keyword">type</span> DeploymentInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">Create(ctx context.Context, deployment *v1.Deployment, opts metav1.CreateOptions) (*v1.Deployment, error)</span><br><span class="line">Update(ctx context.Context, deployment *v1.Deployment, opts metav1.UpdateOptions) (*v1.Deployment, error)</span><br><span class="line">UpdateStatus(ctx context.Context, deployment *v1.Deployment, opts metav1.UpdateOptions) (*v1.Deployment, error)</span><br><span class="line">Delete(ctx context.Context, name <span class="keyword">string</span>, opts metav1.DeleteOptions) error</span><br><span class="line">DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error</span><br><span class="line">Get(ctx context.Context, name <span class="keyword">string</span>, opts metav1.GetOptions) (*v1.Deployment, error)</span><br><span class="line">List(ctx context.Context, opts metav1.ListOptions) (*v1.DeploymentList, error)</span><br><span class="line">Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)</span><br><span class="line">Patch(ctx context.Context, name <span class="keyword">string</span>, pt types.PatchType, data []<span class="keyword">byte</span>, opts metav1.PatchOptions, subresources ...<span class="keyword">string</span>) (result *v1.Deployment, err error)</span><br><span class="line">Apply(ctx context.Context, deployment *appsv1.DeploymentApplyConfiguration, opts metav1.ApplyOptions) (result *v1.Deployment, err error)</span><br><span class="line">ApplyStatus(ctx context.Context, deployment *appsv1.DeploymentApplyConfiguration, opts metav1.ApplyOptions) (result *v1.Deployment, err error)</span><br><span class="line">GetScale(ctx context.Context, deploymentName <span class="keyword">string</span>, options metav1.GetOptions) (*autoscalingv1.Scale, error)</span><br><span class="line">UpdateScale(ctx context.Context, deploymentName <span class="keyword">string</span>, scale *autoscalingv1.Scale, opts metav1.UpdateOptions) (*autoscalingv1.Scale, error)</span><br><span class="line">ApplyScale(ctx context.Context, deploymentName <span class="keyword">string</span>, scale *applyconfigurationsautoscalingv1.ScaleApplyConfiguration, opts metav1.ApplyOptions) (*autoscalingv1.Scale, error)</span><br><span class="line"></span><br><span class="line">DeploymentExpansion</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看到这里实际上一切都已经明了，通过<code>Interface</code>抽象了对于<code>Deployment</code>的操作，具体的实现就不展开分析了。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>运行环境为通过<code>minikube</code>启动的本地<code>k8s</code>集群，另外在集群中注册<code>CRD</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> get crd | grep emqx </span><br><span class="line">emqxbrokers.apps.emqx.io                    2021-12-09T03:59:28Z</span><br><span class="line">emqxenterprises.apps.emqx.io                2021-12-09T03:59:28Z</span><br></pre></td></tr></table></figure><h3 id="验证CRD-Client"><a href="#验证CRD-Client" class="headerlink" title="验证CRD Client"></a>验证<code>CRD Client</code></h3><p>下面让我们验证下<code>Client</code>实际运行情况，验证对自定义的<code>CRD</code>实例的<code>Create</code>,<code>Get</code>,<code>List</code>,<code>Delete</code>的验证。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo 演示</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DemoForEmqxBroker</span><span class="params">(config *rest.Config, ns <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create emqxbroker restclient</span></span><br><span class="line">clientset, err := pkg.NewForConfig(config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emqxbrokerClient := clientset.EmqxBrokersV1Beta1().EmqxBrokers(ns)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create emqxbroker instance</span></span><br><span class="line">Prompt()</span><br><span class="line">fmt.Println(<span class="string">&quot;[&gt; create emqxbroker&quot;</span>)</span><br><span class="line">emqxbroker, err := emqxbrokerClient.Create(context.TODO(), resource.GenerateEmqxbroker(ns), metav1.CreateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;create emqxbroker: %+v\n&quot;</span>, emqxbroker)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get emqxbroker instance</span></span><br><span class="line">Prompt()</span><br><span class="line">    fmt.Println(<span class="string">&quot;[&gt; get emqxbroker&quot;</span>)</span><br><span class="line">eb, err := emqxbrokerClient.Get(context.TODO(), <span class="string">&quot;emqx&quot;</span>, metav1.GetOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;emqxbroker found: %+v\n&quot;</span>, eb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get emqxbroker list</span></span><br><span class="line">Prompt()</span><br><span class="line">    fmt.Println(<span class="string">&quot;[&gt; list emqxbroker&quot;</span>)</span><br><span class="line">eblist, err := emqxbrokerClient.List(context.TODO(), metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;emqxbroker list: %+v\n&quot;</span>, eblist)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete emqxbroker instance</span></span><br><span class="line">Prompt()</span><br><span class="line">    fmt.Println(<span class="string">&quot;[&gt; delete emqxbroker&quot;</span>)</span><br><span class="line">err = emqxbrokerClient.Delete(context.TODO(), <span class="string">&quot;emqx&quot;</span>, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Delete emqxbroker successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Create</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&gt; create emqxbroker</span><br><span class="line">create emqxbroker: EmqxBroker instance [emqx],Image [emqx/emqx:4.3.10]</span><br></pre></td></tr></table></figure><p>查看下<code>K8s</code>集群中实例的情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> get emqx emqx         </span><br><span class="line">NAME   AGE</span><br><span class="line">emqx   2m26s</span><br><span class="line"><span class="variable">$kubectl</span> get pods      </span><br><span class="line">NAME     READY   STATUS    RESTARTS   AGE</span><br><span class="line">emqx-0   1/1     Running   0          2m30s</span><br><span class="line">emqx-1   1/1     Running   0          2m30s</span><br><span class="line">emqx-2   1/1     Running   0          2m30s</span><br></pre></td></tr></table></figure><ul><li><code>Get</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&gt; get emqxbroker</span><br><span class="line">emqxbroker found: EmqxBroker instance [emqx],Image [emqx/emqx:4.3.10]</span><br></pre></td></tr></table></figure><ul><li><code>List</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&gt; list emqxbroker</span><br><span class="line">emqxbroker list: &amp;&#123;TypeMeta:&#123;Kind: APIVersion:&#125; ListMeta:&#123;SelfLink: ResourceVersion:157139 Continue: RemainingItemCount:&lt;nil&gt;&#125; Items:[&#123;TypeMeta:&#123;Kind:EmqxBroker APIVersion:apps.emqx.io/v1beta1&#125; ObjectMeta:&#123;Name:emqx GenerateName: Namespace:default SelfLink: UID:74896493-0134-460a-a04d-d3bdaed21902 ResourceVersion:157121 Generation:1 CreationTimestamp:2021-12-26 20:23:15 +0800 CST DeletionTimestamp:&lt;nil&gt; DeletionGracePeriodSeconds:&lt;nil&gt; Labels:map[] Annotations:map[] OwnerReferences:[] Finalizers:[] ClusterName: ManagedFields:[&#123;Manager:Go-http-client Operation:Update APIVersion:apps.emqx.io/v1beta1 Time:2021-12-26 20:23:15 +0800 CST FieldsType:FieldsV1 FieldsV1:&#123;<span class="string">&quot;f:spec&quot;</span>:&#123;<span class="string">&quot;.&quot;</span>:&#123;&#125;,<span class="string">&quot;f:image&quot;</span>:&#123;&#125;,<span class="string">&quot;f:labels&quot;</span>:&#123;<span class="string">&quot;.&quot;</span>:&#123;&#125;,<span class="string">&quot;f:cluster&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;f:listener&quot;</span>:&#123;<span class="string">&quot;.&quot;</span>:&#123;&#125;,<span class="string">&quot;f:nodePorts&quot;</span>:&#123;&#125;,<span class="string">&quot;f:ports&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;f:replicas&quot;</span>:&#123;&#125;,<span class="string">&quot;f:resources&quot;</span>:&#123;&#125;,<span class="string">&quot;f:serviceAccountName&quot;</span>:&#123;&#125;&#125;&#125; Subresource:&#125; &#123;Manager:__debug_bin4215542756 Operation:Update APIVersion:apps.emqx.io/v1beta1 Time:2021-12-26 20:23:15 +0800 CST FieldsType:FieldsV1 FieldsV1:&#123;<span class="string">&quot;f:status&quot;</span>:&#123;<span class="string">&quot;.&quot;</span>:&#123;&#125;,<span class="string">&quot;f:conditions&quot;</span>:&#123;&#125;&#125;&#125; Subresource:&#125;]&#125; Spec:&#123;Replicas:0xc000492ec8 Image:emqx/emqx:4.3.10 ServiceAccountName:emqx Resources:&#123;Limits:map[] Requests:map[]&#125; Storage:&lt;nil&gt; Labels:map[cluster:emqx] Listener:&#123;Type: LoadBalancerIP: LoadBalancerSourceRanges:[] ExternalIPs:[] Ports:&#123;MQTT:0 MQTTS:0 WS:0 WSS:0 Dashboard:0 API:0&#125; NodePorts:&#123;MQTT:0 MQTTS:0 WS:0 WSS:0 Dashboard:0 API:0&#125;&#125; Affinity:nil ToleRations:[] NodeSelector:map[] ImagePullPolicy: ExtraVolumes:[] ExtraVolumeMounts:[] Env:[] ACL:[] Plugins:[] Modules:[]&#125; Status:&#123;Conditions:[&#123;Type:Healthy Status:True LastUpdateTime:2021-12-26T20:27:26+08:00 LastUpdateAt:0001-01-01 00:00:00 +0000 UTC LastTransitionTime:2021-12-26T20:23:16+08:00 Reason:Cluster available Message:Cluster ok&#125; &#123;Type:Creating Status:True LastUpdateTime:2021-12-26T20:23:15+08:00 LastUpdateAt:0001-01-01 00:00:00 +0000 UTC LastTransitionTime:2021-12-26T20:23:15+08:00 Reason:Creating Message:Bootstrap emqx cluster&#125;]&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Delete</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&gt; delete emqxbroker</span><br><span class="line">Delete emqxbroker successfull</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求背景分析&quot;&gt;&lt;a href=&quot;#需求背景分析&quot; class=&quot;headerlink&quot; title=&quot;需求背景分析&quot;&gt;&lt;/a&gt;需求背景分析&lt;/h2&gt;&lt;p&gt;基于 &lt;code&gt;k8s&lt;/code&gt; 的二次开发过程中，有些场景我们会定制化的去开发自己的 &lt;code&gt;C</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="CRD" scheme="http://kiragoo.github.com/categories/kubernetes/CRD/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="client-go" scheme="http://kiragoo.github.com/tags/client-go/"/>
    
    <category term="设计" scheme="http://kiragoo.github.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>手撕kube-proxy iptables实例</title>
    <link href="http://kiragoo.github.com/archives/3562ba1.html"/>
    <id>http://kiragoo.github.com/archives/3562ba1.html</id>
    <published>2021-11-04T03:58:55.000Z</published>
    <updated>2022-04-21T12:46:07.735Z</updated>
    
    <content type="html"><![CDATA[<p>继 <a href="https://kiragoo.github.io/archives/26a027f0.html"><code>iptables</code> 入门出坑</a>之后，加深个人理解无非是实战，此篇我们来通过示例来加深个人理解。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本人是 <code>mbp</code>，由于 <code>Docker Desktop For Mac</code> 实在太黑盒了，打算用 <code>minikube</code> 来进行 <code>k8s</code> 实验环境的部署。</p><p>对于需要的 <code>minikube, kubectl</code> 这种基本依赖可执行文件具体就不写步骤了。<br>最终执行如下命令拉起 <code>k8s</code> 集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">minikube start --image-mirror-country=<span class="string">&#x27;cn&#x27;</span> --image-repository=<span class="string">&#x27;registry.cn-hangzhou.aliyuncs.com/google_containers&#x27;</span>  --kubernetes-version=v1.21.0</span><br><span class="line">😄  Darwin 11.6 上的 minikube v1.21.0</span><br><span class="line">❗  Kubernetes 1.21.0 has a known performance issue on cluster startup. It might take 2 to 3 minutes <span class="keyword">for</span> a cluster to start.</span><br><span class="line">❗  For more information, see: https://github.com/kubernetes/kubeadm/issues/2395</span><br><span class="line">🎉  minikube 1.23.2 is available! Download it: https://github.com/kubernetes/minikube/releases/tag/v1.23.2</span><br><span class="line">💡  To <span class="built_in">disable</span> this notice, run: <span class="string">&#x27;minikube config set WantUpdateNotification false&#x27;</span></span><br><span class="line"></span><br><span class="line">✨  根据现有的配置文件使用 docker 驱动程序</span><br><span class="line">👍  Starting control plane node minikube <span class="keyword">in</span> cluster minikube</span><br><span class="line">🚜  Pulling base image ...</span><br><span class="line">💾  Downloading Kubernetes v1.21.0 preload ...</span><br><span class="line">    &gt; preloaded-images-k8s-v11-v1...: 498.90 MiB / 498.90 MiB  100.00% 17.39 Mi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &gt; index.docker.io/kicbase/sta...: 359.09 MiB / 359.09 MiB  100.00% 4.53 MiB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">❗  minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.23, but successfully downloaded kicbase/stable:v0.0.23 as a fallback image</span><br><span class="line">🔥  Creating docker container (CPUs=2, Memory=4000MB) ...</span><br><span class="line">❗  This container is having trouble accessing https://k8s.gcr.io</span><br><span class="line">💡  To pull new external images, you may need to configure a proxy: https://minikube.sigs.k8s.io/docs/reference/networking/proxy/</span><br><span class="line">🐳  正在 Docker 20.10.7 中准备 Kubernetes v1.21.0…</span><br><span class="line">    ▪ Generating certificates and keys ...</span><br><span class="line">    ▪ Booting up control plane ...</span><br><span class="line">    ▪ Configuring RBAC rules ...</span><br><span class="line">🔎  Verifying Kubernetes components...</span><br><span class="line">    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5</span><br><span class="line">🌟  Enabled addons: storage-provisioner, default-storageclass</span><br><span class="line">🏄  Done! kubectl is now configured to use <span class="string">&quot;minikube&quot;</span> cluster and <span class="string">&quot;default&quot;</span> namespace by default</span><br></pre></td></tr></table></figure><p>构建实验 <code>manifests</code>，准备的<code>yaml</code> 文件如下：<br><strong>本例的<code>service type</code> 是 <code>ClusterIP</code></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>待资源全部就绪后，查看资源详情，重点关注 <code>Pod</code> 和 <code>Service</code> 的 <code>IP</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl get all -o wide</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/nginx-deployment-74bc56fb4b-9xqkt   1/1     Running   0          4m23s   172.17.0.5   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/nginx-deployment-74bc56fb4b-c9zp4   1/1     Running   0          4m23s   172.17.0.4   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/nginx-deployment-74bc56fb4b-h7rhz   1/1     Running   0          4m23s   172.17.0.6   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/web-server                          1/1     Running   0          4m23s   172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE     SELECTOR</span><br><span class="line">service/kubernetes      ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP   3h22m   &lt;none&gt;</span><br><span class="line">service/nginx-service   ClusterIP   10.97.79.231   &lt;none&gt;        80/TCP    4m23s   app=nginx</span><br><span class="line"></span><br><span class="line">NAME                               READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES   SELECTOR</span><br><span class="line">deployment.apps/nginx-deployment   3/3     3            3           4m23s   nginx        nginx    app=nginx</span><br><span class="line"></span><br><span class="line">NAME                                          DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES   SELECTOR</span><br><span class="line">replicaset.apps/nginx-deployment-74bc56fb4b   3         3         3       4m23s   nginx        nginx    app=nginx,pod-template-hash=74bc56fb4b</span><br></pre></td></tr></table></figure><p>至此实验环境准备完成。</p><h2 id="流量转发分析"><a href="#流量转发分析" class="headerlink" title="流量转发分析"></a>流量转发分析</h2><p>首先需要登陆到 <code>minukube</code> 节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minikube ssh</span><br><span class="line">docker@minikube:~$ iptables</span><br><span class="line">iptables v1.8.4 (legacy): no <span class="built_in">command</span> specified</span><br><span class="line">Try `iptables -h<span class="string">&#x27; or &#x27;</span>iptables --<span class="built_in">help</span><span class="string">&#x27; for more information.</span></span><br><span class="line"><span class="string">docker@minikube:~$sudo su # 切换到root 用户</span></span><br></pre></td></tr></table></figure><h3 id="kube-proxy-iptable-模式分析之ClusterIP"><a href="#kube-proxy-iptable-模式分析之ClusterIP" class="headerlink" title="kube-proxy iptable 模式分析之ClusterIP"></a><code>kube-proxy iptable</code> 模式分析之<code>ClusterIP</code></h3><h4 id="流量的源与目的大概如下："><a href="#流量的源与目的大概如下：" class="headerlink" title="流量的源与目的大概如下："></a>流量的源与目的大概如下：</h4><pre class="mermaid">graph LR    web[web-server:172.17.0.3]-->nginx[nginx-service:10.97.79.231]</pre><blockquote><p>分析下为啥是从本机出去的流量？<br>因为<code>kube-proxy</code>是以<code>daemonSet</code>的形式部署在所有节点上的，所以每个节点都会有相同的<code>iptable</code>规则，当任何一个节点上的<code>pod</code>访问<code>service</code>时，其实都是可以在该<code>pod</code>所在的node的的<code>iptable</code>中找到对应的<code>service</code>规则从而找到<code>service</code>所代理的<code>pod</code>的，而对于<code>node</code>而言，寄宿在自己上的<code>pod</code>的发出的流量就是从本机的某进程出去的流量。</p></blockquote><p>在 <code>iptables</code> 的学习中可以知道，从本机出去的流量经过的链路流程如下：</p><pre class="mermaid">graph LR   output[OUTPUT链]-->postroting[POSTROUTING链]</pre><h4 id="OUTPUT-链分析"><a href="#OUTPUT-链分析" class="headerlink" title="OUTPUT 链分析"></a><code>OUTPUT</code> 链分析</h4><p><code>OUTPUT</code> 链涉及到4张表：<code>raw</code>，<code>mangle</code>，<code>nat</code>，<code>filter</code>。以下分析中会忽略与本例无关的 <code>rule</code>。<strong>重点看<code>nat</code>表和<code>filter</code>表，<code>raw</code>表和<code>mangle</code>表是空表</strong>。</p><h5 id="NAT-表"><a href="#NAT-表" class="headerlink" title="NAT 表"></a><code>NAT</code> 表</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -nvL</span><br><span class="line">...</span><br><span class="line">Chain OUTPUT (policy ACCEPT 819 packets, 49140 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">15746  946K KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */</span><br><span class="line">   72  4789 DOCKER_OUTPUT  all  --  *      *       0.0.0.0/0            192.168.65.2</span><br><span class="line">10852  651K DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，所有OUTPUT流量都被导向了名叫<code>KUBE-SERVICES</code>的自定义链，我们来看看它是做什么的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> ...</span><br><span class="line">    0     0 KUBE-MARK-MASQ  tcp  --  *      *      !10.244.0.0/16        10.97.79.231         /* default/nginx-service cluster IP */ tcp dpt:80</span><br><span class="line">    0     0 KUBE-SVC-V2OKYYMBY3REGZOG  tcp  --  *      *       0.0.0.0/0            10.97.79.231         /* default/nginx-service cluster IP */ tcp dpt:80</span><br><span class="line"> ...   </span><br><span class="line">    0     0 KUBE-SVC-TCOU7JCQXEZGVUNU  udp  --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns cluster IP */ udp dpt:53</span><br><span class="line">  719 43140 KUBE-NODEPORTS  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule <span class="keyword">in</span> this chain */ ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><p>可以看到这里定义了所有<code>namespace</code>的<code>service</code>相关的规则，其中就有我们创建的<code>nginx-service</code>规则（其他几条<code>service</code>与<code>kube-dns</code>和<code>apiServer</code>相关，大家感兴趣的话可以自己分析一下），可以看到它匹配的是目标地址为<code>10.97.79.231</code>，端口为<code>80</code>的数据包，而我们发往<code>nginx-service</code>的数据包正好匹配这条规则，我们看到这条规则的<code>target</code>是名叫<code>KUBE-SVC-V2OKYYMBY3REGZOG</code>的自定义链，我们来继续挖这个链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SVC-V2OKYYMBY3REGZOG (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 KUBE-SEP-3VDHYO53IOQ2XWUD  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ statistic mode random probability 0.33333333349</span><br><span class="line">    0     0 KUBE-SEP-C54WIGIB4NQVIFB3  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ statistic mode random probability 0.50000000000</span><br><span class="line">    0     0 KUBE-SEP-KN3IA7DQGTHQJWSD  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */</span><br></pre></td></tr></table></figure><p>我们看到这个<code>KUBE-SVC-V2OKYYMBY3REGZOG</code>链里面定义了3条规则，第一条规则有<code>0.33333333349</code>的概率匹配，也就是<code>1/3</code>的概率命中，第一条没命中的话第二条规则有<code>1/2</code>的概率命中，也就是<code>2/3 * 1/2 = 1/3</code>，第二条没命中的话就去第3条了。很明显，这里是在做负载均衡，那我们可以猜到这3条规则后面的<code>target</code>就是这个<code>service</code>代理的3个<code>pod</code>相关的规则了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SEP-3VDHYO53IOQ2XWUD (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 KUBE-MARK-MASQ  all  --  *      *       172.17.0.4           0.0.0.0/0            /* default/nginx-service */</span><br><span class="line">    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ tcp to:172.17.0.4:80</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-C54WIGIB4NQVIFB3 (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 KUBE-MARK-MASQ  all  --  *      *       172.17.0.5           0.0.0.0/0            /* default/nginx-service */</span><br><span class="line">    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ tcp to:172.17.0.5:80</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-KN3IA7DQGTHQJWSD (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 KUBE-MARK-MASQ  all  --  *      *       172.17.0.6           0.0.0.0/0            /* default/nginx-service */</span><br><span class="line">    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ tcp to:172.17.0.6:80</span><br></pre></td></tr></table></figure><p>可以看到这3个自定义链的规则很类似，注意到第一条匹配的是是<code>Pod</code>自己访问自己的情况，会去<code>KUBE-MARK-MASQ</code>这个<code>target</code>，其他的情况会去第二条规则，也就是<code>DNAT</code>。在我们的假设中，是另外一个<code>pod</code>访问<code>nginx-service</code>，所以不会命中第一条，命中第二条<code>DNAT</code>。</p><p>假设我们的数据包在<code>KUBE-SVC-V2OKYYMBY3REGZOG</code>链中被负载均衡分配到了第一个<code>target</code>，也就是<code>KUBE-SEP-3VDHYO53IOQ2XWUD</code>，那么<code>DNAT</code>之后，该数据包的<code>destination</code>从<code>10.97.79.231:80</code>被改成了<code>172.17.0.4:80</code>，即：</p><pre class="mermaid">graph LR    orignal[orginal:172.17.0.3:xxx]-->dst1[10.97.79.231:80]    afterdnat[after dnat:172.17.0.3:xxx]-->dst2[172.17.0.4:80]</pre><p>至此，<code>nat</code> 表中 <code>OUTPUT</code> 链分析技术，进入<code>filter</code>表进行分析。</p><h5 id="filter-表"><a href="#filter-表" class="headerlink" title="filter 表"></a><code>filter</code> 表</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -nvL</span><br><span class="line">...</span><br><span class="line">Chain OUTPUT (policy ACCEPT 193K packets, 30M bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">17326 1040K KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            ctstate NEW /* kubernetes service portals */</span><br><span class="line">1379K  225M KUBE-FIREWALL  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure><p>可以看到所有所有的新的连接（ctstate NEW）都会匹配到第一条规则<code>KUBE-SERVICES</code>。但是我们会发现 <code>KUBE-SERVICES</code> 是一条空链，在此着重看第二条表<code>KUBE-FIREWALL</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-FIREWALL (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 DROP       all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes firewall <span class="keyword">for</span> dropping marked packets */ mark match 0x8000/0x8000</span><br><span class="line">    0     0 DROP       all  --  *      *      !127.0.0.0/8          127.0.0.0/8          /* block incoming localnet connections */ ! ctstate RELATED,ESTABLISHED,DNAT</span><br></pre></td></tr></table></figure><p>可以看到，所有被标记了<code>0x8000/0x8000</code>的数据包都会被直接<code>DROP</code>掉，而我们的数据包一路走过来没有被标记，所以不会被<code>DROP</code>。这样一来<code>filter</code>的<code>OUTPUT</code>规则也走完了，终于进入了下一个阶段 – <code>POSTROUTRING</code>链。</p><h5 id="POSTROUTING-链"><a href="#POSTROUTING-链" class="headerlink" title="POSTROUTING 链"></a><code>POSTROUTING</code> 链</h5><p><code>POSTROUTING</code> 链主要涉及两张表：<code>mangle</code> 和 <code>nat</code>。由于<code>mangle</code>表示空表，只需关注<code>nat</code>表的<code>POSTROUTING</code>规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -nvL</span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 488 packets, 29280 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 8165  491K KUBE-POSTROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */</span><br><span class="line">   13   780 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">    0     0 DOCKER_POSTROUTING  all  --  *      *       0.0.0.0/0            192.168.65.2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先进入第一个 <code>target</code>，<code>KUBE-POSTROUTING</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-POSTROUTING (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">  486 29160 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0            mark match ! 0x4000/0x4000</span><br><span class="line">    0     0 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            MARK xor 0x4000</span><br><span class="line">    0     0 MASQUERADE  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */ random-fully</span><br></pre></td></tr></table></figure><p>最终会发现数据包是从<code>docker0</code>网卡发送出来，并没有做<code>SNAT</code>操作，<code>source ip</code> 依然是 <code>172.17.0.3</code>，但是这个时候的<code>DST IP</code>是<code>10.172.0.4</code> 而不是<code>service ip: 10.97.79.231</code>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>ClusterIP</code> 类型的数据包经历的链路是：</p><pre class="mermaid">graph TB    s((数据包))-->1[nat:OUTPUT]    1-->2[nat:KUBE-SERVICES]    2-->3[nat:KUBE-SVC-V2OKYYMBY3REGZOG]    3-->4[nat:KUBE-SEP-*:3选一]    4-->5[filter:OUTPUT]    5-->6[filter:KUBE-FIREWALL]    6-->7[nat:POSTROUTING]    7-->8[nat:KUBE-POSTROUTING]    8-->9((未被SNAT))</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继 &lt;a href=&quot;https://kiragoo.github.io/archives/26a027f0.html&quot;&gt;&lt;code&gt;iptables&lt;/code&gt; 入门出坑&lt;/a&gt;之后，加深个人理解无非是实战，此篇我们来通过示例来加深个人理解。&lt;/p&gt;
&lt;h2 id=&quot;环</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="网络" scheme="http://kiragoo.github.com/categories/kubernetes/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="iptables" scheme="http://kiragoo.github.com/tags/iptables/"/>
    
    <category term="kube-proxy" scheme="http://kiragoo.github.com/tags/kube-proxy/"/>
    
  </entry>
  
  <entry>
    <title>iptables 入门出坑</title>
    <link href="http://kiragoo.github.com/archives/26a027f0.html"/>
    <id>http://kiragoo.github.com/archives/26a027f0.html</id>
    <published>2021-11-02T02:42:35.000Z</published>
    <updated>2023-04-03T08:26:55.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自<a href="https://mp.weixin.qq.com/s/Dgv5BU9YU0tuSMxtzcuiVw"><code>iptables</code>长文详解，值得收藏细读</a><br>整理此篇博文的初衷还是因为目前很多 <code>k8s</code> 的内部的 <code>service</code> 路由规则还是通过 <code>iptables</code> 来实现的，否则最终还是只停留在使用层面，能够让我们对某个服务夯住又多了个排查利器。</p></blockquote><p><code>Linux</code> 的网络控制模块在内核中，叫做<code>netfilter</code>。而<code>iptables</code>是位于用户空间的一个命令行工具，它作用在OIS7层网络模型中的第四层[物理层，数据链路层，网络层，<strong>传输层</strong>，会话层，表示层，应用层]，用来和内核的<code>netfilter</code>交互，配置<code>netfilter</code>进而实现对网络的控制、流量的转发。</p><p>主要功能：</p><ul><li>流量转发：<code>DNAT</code> 实现 <code>IP</code> 地址和端口的映射</li><li>负载均衡：<code>statistic</code> 模块为每个后端设置权重</li><li>会话保持：<code>recent</code> 模块设置会话保持时间</li></ul><h2 id="基本两要素"><a href="#基本两要素" class="headerlink" title="基本两要素"></a>基本两要素</h2><p>表和链路，5表5链路。</p><p>5张表分别是：<code>raw</code>,<code>filter</code>,<code>nat</code>,<code>mangle</code>,<code>security</code><br>5条链路分别是：<code>prerouting</code>,<code>input</code>,<code>forward</code>,<code>output</code>,<code>postrouting</code></p><p>通过 <code>iptables -t $&#123;table&#125; -nL</code> 查看相关表：</p><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/iptables-nl.png" alt="`filter` 表查看"></p><pre class="mermaid">graph LRR[iptables]-->FT(filter表)FT-->FTFIC(input链)FTFIC-->在入口对流量做过滤FT-->FTFC(forward链)FTFC-->做流量转发FT-->FTOC(output链)FTOC-->在出口对流量做过滤FT-->作用:常用于控制到达某条链路上的数据是继续放行,丢弃,拒绝R-->NT(nat表)NT-->NTPREC(prerouting链)NTPREC-->做dnat目标地址转换NT-->NTIC(input链)NT-->NTOC(output链)NT-->NTPOSTC(postouting链)NTPOSTC-->做snat源地址转换NT-->常用于修改数据包的原地址,目的地址R-->MT(mangle表)MT-->MTPREC(prerouting)MT-->MTIC(input链)MT-->MTFC(forward链)MT-->MTOC(output链)MT-->MTPOSTC(postouting链)MT-->常用于修改ip数据包的头信息R-->RT(raw表)RT-->RTPREC(prerouting链)RT-->RTOC(output链)RT-->对连接的状态进行追踪,常见的状态有new,establishedR-->ST(security表)ST-->是新加入的表,用于将数据包应用在selinux上</pre><h2 id="流量走向分析"><a href="#流量走向分析" class="headerlink" title="流量走向分析"></a>流量走向分析</h2><p>对于流量的分析，我们可以考虑两个场景：</p><ul><li>来及本机的流量经过了 <code>iptables</code> 的哪些节点，最终又到哪里去了？</li><li>来自互联网的外界流量，是如何经历 <code>iptables</code> 的，然后最终的去处？</li></ul><h3 id="iptables-处理流程"><a href="#iptables-处理流程" class="headerlink" title="iptables 处理流程"></a><code>iptables</code> 处理流程</h3><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/Netfilter-packet-flow.svg.png" alt="`netfilter-packet-filter`"></p><h3 id="iptables-在-kube-proxy-的处理流程"><a href="#iptables-在-kube-proxy-的处理流程" class="headerlink" title="iptables 在 kube-proxy 的处理流程"></a><code>iptables</code> 在 <code>kube-proxy</code> 的处理流程</h3><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/kube-proxy-its.png" alt="`kube-proxy-iptables`"></p><blockquote><p>关于 <code>kube-proxy</code> 的规则处理，可以借鉴博文<a href="https://zjj2wry.github.io/network/iptables/">理解<code>kube-proxy</code>中<code>iptable</code>规则</a></p></blockquote><p>如上表解析：<br>1、 红，蓝，绿，紫分别代表上<code>iptables</code>的四张表，如果开启了<code>seLinux</code>，会多出一个<code>security</code>表。</p><p>2、上图左上角部分：<code>incoming packet</code>，表示这是从互联网设备过来的流量，会经历各个表的<code>preouting</code>阶段，再由<code>routing decision</code>(路由选择)决定这些流量是由本机处理还是<code>forward</code>转发走。</p><p>3、上图左上角部分：<code>incoming packet</code> 在做 <code>routing descision</code> 之前会经过<code>nat preouting</code>阶段，在此阶段可以做<code>dnat</code>，可以简单理解为：比如这个数据包原来的<code>dst ip</code>是百度的，经过<code>routing desicion</code> 之后进入<code>forward</code> 转发阶段，这个时候改写目标地址为自己本机，让数据进入<code>input</code>通路，可以在本机截获这个数据包。</p><p>4、上图右上角部分：<code>locally generated packet</code>，表示这是本机自己生成的流量。它会一路经过各个表的<code>output</code>链，然后流到<code>output interface</code>（网卡）上。你注意下，流量在被打包成<code>outgoing packet</code>之前，会有个<code>localhost dest</code>的判断，如果它判断流量不是发往本机的话，流量会经过<code>nat</code>表的<code>postrouting</code>阶段。一般会在这里做DNAT源地址改写。</p><p>理解如上流程，我们可以灵活的对流量进行自定义控制，通常的流量控制无非如下：</p><p>1、 丢弃来自XXX的流量 （<code>filter</code> 表 <code>INPUT</code> 链）</p><p>2、 丢弃去往XXX的流量 （<code>filter</code> 表 <code>OUTPUT</code>链）</p><p>3、 只接收来自XXX的流量 （<code>filter</code> 表 <code>INPUT</code> 链）</p><p>4、 在流量刚流入时，将目的地址改写成其他地址（<code>nat</code>表<code>preouting</code>链）</p><p>5、 在流量即将流出时，将源地址改写成其他地址（<code>nat</code>表<code>postouting</code>链)</p><p>6、 将发往 <code>A</code> 的数据包，转发给<code>B</code>(<code>filter</code>表<code>forward</code>链)</p><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/iptables-flow.png" alt="iptables-flow-zsy(出自https://www.zsythink.net/archives/1199)"></p><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/iptable-flow.drawio.png" alt="iptable-flow"></p><h2 id="iptables-commands"><a href="#iptables-commands" class="headerlink" title="iptables commands"></a><code>iptables commands</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptabls -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;Commands&#125;</span> <span class="variable">$&#123;链名&#125;</span> <span class="variable">$&#123;链中规则&#125;</span> <span class="variable">$&#123;匹配条件&#125;</span> <span class="variable">$&#123;目标动作&#125;</span></span><br></pre></td></tr></table></figure><table>    <tr>        <th>命令行属性</th>        <th>属性列表</th>        <th>说明</th>    </tr>    <tr>        <td rowspan="5">表名</td>        <td> raw </td>        <td>iptables 是有状态的，其对数据包有链接追踪机制，链接追踪信息在/proc/net/nf_conntrack 中可以看到记录</td>    </tr>    <tr>        <td> filter </td>        <td> 用于控制到达某条链接上的数据包是继续放行，直接丢弃还是拒绝</td>    </tr>    <tr>        <td> mangle</td>        <td> 用于修改数据包的IP头信息</td>    </tr>    <tr>        <td> nat </td>        <td>network address translation 网络地址转换，用于修改数据包的源地址和目的地址 </td>    </tr>    <tr>        <td> security </td>        <td> 不常用的表，用在SeLinux上</td>    </tr>    <tr>        <td rowspan="5"> Commands </td>        <td> PREOUTING </td>        <td> 数据包进入之前，可以在此进行DNAT</td>    </tr>    <tr>        <td> POSTOUTING </td>        <td> 发送到网卡之前，可以在此处进行SNAT</td>    </tr>    <tr>        <td> INPUT </td>        <td> 一般处理本地进程的数据包，目的地址为本机</td>    </tr>    <tr>        <td> OUTPUT </td>        <td>原地址为本机，向外发送，一般处理本地进程的数据数据包 </td>    </tr>    <tr>        <td> FORWARD </td>        <td> </td>    </tr>    <tr>        <td> POSTROUTING </td>        <td> </td>    </tr>    <tr>        <td rowspan="10">Commands</td>        <td>-A</td>        <td>添加</td>    </tr>    <tr>        <td>-C</td>        <td>检查</td>    </tr>        <tr>        <td>-C</td>        <td>检查</td>    </tr>    <tr>        <td>-D</td>        <td>删除</td>    </tr>    <tr>        <td>-I</td>        <td>在头部插入</td>    </tr>    <tr>        <td>-R</td>        <td>替换</td>    </tr>    <tr>        <td>-L</td>        <td>查看全部</td>    </tr>    <tr>        <td>-F</td>        <td>清空</td>    </tr>    <tr>        <td>-N</td>        <td>新建</td>    </tr>    <tr>        <td>-P</td>        <td>默认是ACCEPT</td>    </tr>    <tr>        <td rowspan="4">匹配条件</td>        <td>-p</td>        <td>协议，-4,-6</td>    </tr>    <tr>        <td>-s</td>        <td>源地址</td>    </tr>    <tr>        <td>-d</td>        <td>目的地址</td>    </tr>    <tr>        <td>-i</td>        <td>网络接口名称</td>    </tr>    <tr>        <td rowspan="7">目标动作</td>        <td>-j REJECT</td>        <td>拒绝访问</td>    </tr>    <tr>        <td>-j ACCEPT</td>        <td>允许通过</td>    </tr>    <tr>        <td>-j DROP</td>        <td>丢弃</td>    </tr>    <tr>        <td>-j LOG</td>        <td>记录日志</td>    </tr>    <tr>        <td>-j SNAT</td>        <td>源地址转换</td>    </tr>    <tr>        <td>-j DNAT</td>        <td>目标地址转换</td>    </tr>    <tr>        <td>RETURN,QUEUE</td>        <td></td>    </tr></table><h2 id="iptables-的匹配规则"><a href="#iptables-的匹配规则" class="headerlink" title="iptables 的匹配规则"></a><code>iptables</code> 的匹配规则</h2><p>常见的规则如下：<br>源地址：<code>-s 192.168.1.0/24</code><br>目标地址：<code>-d 192.168.1.11</code><br>协议：<code>-p tcp|udp|icmp</code><br>从哪个网卡进来：<code>-i eth0|lo</code><br>从哪个网卡出去：<code>-o eth0|lo</code><br>目标端口（必须制定协议）：<code>-p tcp|udp --dport 8080</code><br>源端口（必须制定协议）：<code>-p tcp|udp --sport 8080</code></p><p><code>iptables</code> 中的每条规则顺序都是由上至下顺序执行的，除非碰到了 <code>DROP</code>,<code>REJECT</code>,<code>RETURN</code>。</p><p>还有就是如果定义的动作是<code>JUMP</code>，那就会相应的 <code>jump</code> 到指定链路上的指定规则：</p><pre class="mermaid">graph TB    chain1((chain1)) --> rule1-1((rule1-1))    chain2((chain2)) --> rule2-1((rule2-1))    rule1-1 --> rule1-2((rule1-2))    rule1-2 --> rule1-3((rule1-3))    rule2-1 --> rule2-2((rule2-2))    rule2-2 --> rule2-3((rule2-3))    rule1-2 --JUMP--> rule2-1    rule2-3 --JUMP--> rule1-3</pre><h2 id="iptables-中的模块"><a href="#iptables-中的模块" class="headerlink" title="iptables 中的模块"></a><code>iptables</code> 中的模块</h2><ul><li>多端口</li></ul><p>可以如下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中的20:30表示20和30之间的所有端口</span></span><br><span class="line">iptables -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;commands&#125;</span> <span class="variable">$&#123;chain&#125;</span> <span class="variable">$&#123;规则号&#125;</span> --dport 20:30 -j <span class="variable">$&#123;动作&#125;</span></span><br></pre></td></tr></table></figure><p>想指定多个不连续的端口可以使用<code>iptables</code>的<code>multiport</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助文档</span></span><br><span class="line">~]<span class="comment"># iptables -m multiport --help</span></span><br><span class="line">...</span><br><span class="line">multiport match options:</span><br><span class="line">[!] --source-ports port[,port:port,port...]</span><br><span class="line"> --sports ...</span><br><span class="line">    match <span class="built_in">source</span> port(s)</span><br><span class="line">[!] --destination-ports port[,port:port,port...]</span><br><span class="line"> --dports ...</span><br><span class="line">    match destination port(s)</span><br><span class="line">[!] --ports port[,port:port,port]</span><br><span class="line">    match both <span class="built_in">source</span> and destination port(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令例子</span></span><br><span class="line">iptables -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;commands&#125;</span> <span class="variable">$&#123;chain&#125;</span> <span class="variable">$&#123;规则号&#125;</span>  </span><br><span class="line">     <span class="variable">$&#123;-p 协议&#125;</span> -m multiport --dports 20,30 -j <span class="variable">$&#123;动作&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#相当于如下两行命令</span></span><br><span class="line">iptables -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;commands&#125;</span> <span class="variable">$&#123;chain&#125;</span>  <span class="variable">$&#123;规则号&#125;</span> -p <span class="variable">$&#123;协议&#125;</span> --dprot 20 -j <span class="variable">$&#123;动作&#125;</span></span><br><span class="line">iptables -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;commands&#125;</span> <span class="variable">$&#123;chain&#125;</span>  <span class="variable">$&#123;规则号&#125;</span> -p <span class="variable">$&#123;协议&#125;</span> --dprot 30 -j <span class="variable">$&#123;动作&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>ip</code> 范围</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># iptables -m iprange --help</span></span><br><span class="line">iprange match options:</span><br><span class="line">[!] --src-range ip[-ip]    Match <span class="built_in">source</span> IP <span class="keyword">in</span> the specified range</span><br><span class="line">[!] --dst-range ip[-ip]    Match destination IP <span class="keyword">in</span> the specified range</span><br></pre></td></tr></table></figure><ul><li>连接状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># iptables -m state --help</span></span><br><span class="line">state match options:</span><br><span class="line"> [!] --state [INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED][,...]</span><br></pre></td></tr></table></figure><blockquote><p>参考借鉴</p></blockquote><ul><li><a href="https://mp.weixin.qq.com/s/Dgv5BU9YU0tuSMxtzcuiVw"><code>iptables</code>长文详解，值得收藏细读</a></li><li><a href="http://www.tianfeiyu.com/?p=2894"><code>kube-proxy iptables</code> 模式源码分析</a></li><li><a href="https://www.zsythink.net/archives/1199"><code>iptables详解（1）</code></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文整理自&lt;a href=&quot;https://mp.weixin.qq.com/s/Dgv5BU9YU0tuSMxtzcuiVw&quot;&gt;&lt;code&gt;iptables&lt;/code&gt;长文详解，值得收藏细读&lt;/a&gt;&lt;br&gt;整理此篇博文的初衷还是因为目前很多 &lt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://kiragoo.github.com/categories/Linux/"/>
    
    
    <category term="iptables" scheme="http://kiragoo.github.com/tags/iptables/"/>
    
    <category term="网络" scheme="http://kiragoo.github.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes源码分析系列之源码分析系列之Statefulset Controller</title>
    <link href="http://kiragoo.github.com/archives/f7f100a2.html"/>
    <id>http://kiragoo.github.com/archives/f7f100a2.html</id>
    <published>2021-10-21T03:01:43.000Z</published>
    <updated>2023-04-03T08:26:56.205Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于分析 <code>Controller</code> 源码选用 <code>StatefulSet Controller</code> 来，其它控制器源码分析一个套路，可以做参考。</p></blockquote><h1 id="StatefulSet-简介"><a href="#StatefulSet-简介" class="headerlink" title="StatefulSet 简介"></a><code>StatefulSet</code> 简介</h1><p>此篇文章默认你已经具备了熟练使用 <code>Statefulset</code> 的基础知识，所以常规介绍及使用 <code>Demo</code> 的描述不在阐述，具体可参考 <a href="https://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/">StatefulSet 基础</a></p><h1 id="StatefulSet-Controller-启动分析"><a href="#StatefulSet-Controller-启动分析" class="headerlink" title="StatefulSet Controller 启动分析"></a><code>StatefulSet Controller</code> 启动分析</h1><h2 id="kube-manager-controller-入口调用链分析"><a href="#kube-manager-controller-入口调用链分析" class="headerlink" title="kube-manager-controller 入口调用链分析"></a><code>kube-manager-controller</code> 入口调用链分析</h2><p><em>对于 <code>Kubernetes</code> 的源码组织结构不做过多介绍，希望你有一定的了解。</em></p><p>对于 <code>k8s</code> 是如何启动 <code>kube-controller-manager</code>，可以通过<a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-controller-manager/">文档<code>kube-controller-manager </code></a> 查找到对应如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--controllers strings     默认值：[*]</span><br><span class="line">要启用的控制器列表。\* 表示启用所有默认启用的控制器； foo 启用名为 foo 的控制器； -foo 表示禁用名为 foo 的控制器。</span><br><span class="line">控制器的全集：attachdetach、bootstrapsigner、cloud-node-lifecycle、clusterrole-aggregation、cronjob、csrapproving、csrcleaner、csrsigning、daemonset、deployment、disruption、endpoint、endpointslice、endpointslicemirroring、ephemeral-volume、garbagecollector、horizontalpodautoscaling、job、namespace、nodeipam、nodelifecycle、persistentvolume-binder、persistentvolume-expander、podgc、pv-protection、pvc-protection、replicaset、replicationcontroller、resourcequota、root-ca-cert-publisher、route、service、serviceaccount、serviceaccount-token、statefulset、tokencleaner、ttl、ttl-after-finished</span><br><span class="line">默认禁用的控制器有：bootstrapsigner 和 tokencleaner。</span><br></pre></td></tr></table></figure><p>这里我们发现默认值启动中已经加入了 <code>statefulset</code> 的初始化，那么在代码是在哪里体现的呢？继续往下看。</p><p>进入 <code>cmd/controller-manager</code> 的 <code>main</code> 函数，实际上就做两个事情：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">command := app.NewControllerManagerCommand()    <span class="comment">// 初始化</span></span><br><span class="line">code := cli.Run(command)    <span class="comment">//真正执行</span></span><br><span class="line">os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数调用关系，我们进入 <code>cmd/kube-controller-manager/controllermanager.go</code> 中，查看 <code>Run</code> 执行究竟做了啥。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">verflag.PrintAndExitIfRequested()</span><br><span class="line">cliflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">err := checkNonZeroInsecurePort(cmd.Flags())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是我们需要关注的点，就是 `KnownControllers() 实际上就是将我们进行需要我们初始化已知的 `Controllers`</span></span><br><span class="line">c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List())     </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := Run(c.Complete(), wait.NeverStop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>深入 <code>KnowControllers()</code> 函数分析：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KnownControllers returns all known controllers&#x27;s name</span></span><br><span class="line"><span class="comment">// 这里我们发现实际上这边就是之前 `daemon` 进程启动需要的参数，为一个 `controller` 控制器数组。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KnownControllers</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">ret := sets.StringKeySet(NewControllerInitializers(IncludeCloudLoops))</span><br><span class="line"></span><br><span class="line"><span class="comment">// add &quot;special&quot; controllers that aren&#x27;t initialized normally.  These controllers cannot be initialized</span></span><br><span class="line"><span class="comment">// using a normal function.  The only known special case is the SA token controller which *must* be started</span></span><br><span class="line"><span class="comment">// first to ensure that the SA tokens for future controllers will exist.  Think very carefully before adding</span></span><br><span class="line"><span class="comment">// to this list.</span></span><br><span class="line">ret.Insert(</span><br><span class="line">saTokenControllerName,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret.List()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>NewControllerInitializers</code> 可以知道的是真正执行 <code>controller-manager</code> 初始化的执行函数是这个。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerInitializers is a public map of named controller groups (you can start more than one in an init func)</span></span><br><span class="line"><span class="comment">// paired to their InitFunc.  This allows for structured downstream composition and subdivision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处即为在 `map` 中进行实质性的初始化赋值</span></span><br><span class="line">controllers[<span class="string">&quot;statefulset&quot;</span>] = startStatefulSetController  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">controllers[<span class="string">&quot;service&quot;</span>] = startServiceController</span><br><span class="line">controllers[<span class="string">&quot;route&quot;</span>] = startRouteController</span><br><span class="line">controllers[<span class="string">&quot;cloud-node-lifecycle&quot;</span>] = startCloudNodeLifecycleController</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> volume controller into the IncludeCloudLoops only set.</span></span><br><span class="line">&#125;</span><br><span class="line">controllers[<span class="string">&quot;persistentvolume-binder&quot;</span>] = startPersistentVolumeBinderController</span><br><span class="line">controllers[<span class="string">&quot;attachdetach&quot;</span>] = startAttachDetachController</span><br><span class="line">controllers[<span class="string">&quot;persistentvolume-expander&quot;</span>] = startVolumeExpandController</span><br><span class="line">controllers[<span class="string">&quot;clusterrole-aggregation&quot;</span>] = startClusterRoleAggregrationController</span><br><span class="line">controllers[<span class="string">&quot;pvc-protection&quot;</span>] = startPVCProtectionController</span><br><span class="line">controllers[<span class="string">&quot;pv-protection&quot;</span>] = startPVProtectionController</span><br><span class="line">controllers[<span class="string">&quot;ttl-after-finished&quot;</span>] = startTTLAfterFinishedController</span><br><span class="line">controllers[<span class="string">&quot;root-ca-cert-publisher&quot;</span>] = startRootCACertPublisher</span><br><span class="line">controllers[<span class="string">&quot;ephemeral-volume&quot;</span>] = startEphemeralVolumeController</span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(genericfeatures.APIServerIdentity) &amp;&amp;</span><br><span class="line">utilfeature.DefaultFeatureGate.Enabled(genericfeatures.StorageVersionAPI) &#123;</span><br><span class="line">controllers[<span class="string">&quot;storage-version-gc&quot;</span>] = startStorageVersionGCController</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如上可以得知 <code>StatefulSet</code> 是如何被初始化到 <code>kube-controller-manager</code> 中的。</p><h2 id="Statefulset-Controller-启动过程"><a href="#Statefulset-Controller-启动过程" class="headerlink" title="Statefulset Controller 启动过程"></a><code>Statefulset Controller</code> 启动过程</h2><p>通过 <code>cmd/kube-manager-controller/app/controllermanager.go</code> 中 <code>Run</code> 函数分析，其中</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">verflag.PrintAndExitIfRequested()</span><br><span class="line">cliflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">err := checkNonZeroInsecurePort(cmd.Flags())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List()) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处是对 `Controller manager` 进行 `config` 的初始化，然后对其中所管理的 `controller` 进行 `Run` 执行</span></span><br><span class="line"><span class="keyword">if</span> err := Run(c.Complete(), wait.NeverStop); err != <span class="literal">nil</span> &#123; </span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>进入 <code>Run</code> 函数进行分析：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// To help debugging, immediately log version</span></span><br><span class="line">klog.Infof(<span class="string">&quot;Version: %+v&quot;</span>, version.Get())</span><br><span class="line">...</span><br><span class="line">clientBuilder, rootClientBuilder := createClientBuilders(c)</span><br><span class="line"></span><br><span class="line">saTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class="line"></span><br><span class="line">run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, startSATokenController InitFunc, initializersFunc ControllerInitializersFunc)</span></span> &#123; <span class="comment">// 此处是我们需要关注的 `Controller` 初始化。</span></span><br><span class="line"></span><br><span class="line">controllerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">&quot;error building controller context: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">controllerInitializers := initializersFunc(controllerContext.LoopMode)</span><br><span class="line">        <span class="comment">// 在这里是真正意义上开始对管理的控制器执行启动</span></span><br><span class="line"><span class="keyword">if</span> err := StartControllers(ctx, controllerContext, startSATokenController, controllerInitializers, unsecuredMux, healthzHandler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">&quot;error starting controllers: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">controllerContext.InformerFactory.Start(stopCh)</span><br><span class="line">controllerContext.ObjectOrMetadataInformerFactory.Start(stopCh)</span><br><span class="line"><span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <code>StartControllers</code> 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartControllers starts a set of controllers with a specified ControllerContext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartControllers</span><span class="params">(ctx context.Context, controllerCtx ControllerContext, startSATokenController InitFunc, controllers <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">unsecuredMux *mux.PathRecorderMux, healthzHandler *controllerhealthz.MutableHealthzHandler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里会 `for` 循环遍历初始化过的 `controllers` 进行处理，需要关注下 `initFn` 究竟做了啥.</span></span><br><span class="line"><span class="keyword">for</span> controllerName, initFn := <span class="keyword">range</span> controllers &#123;</span><br><span class="line"><span class="keyword">if</span> !controllerCtx.IsControllerEnabled(controllerName) &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;%q is disabled&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(wait.Jitter(controllerCtx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">1</span>).Infof(<span class="string">&quot;Starting %q&quot;</span>, controllerName)</span><br><span class="line">ctrl, started, err := initFn(ctx, controllerCtx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;Error starting %q&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !started &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;Skipping %q&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">klog.Infof(<span class="string">&quot;Started %q&quot;</span>, controllerName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">healthzHandler.AddHealthChecker(controllerChecks...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于判断具体的 `controller` 是否满足接口需求来得到 `controller manager` 支持的特性</span></span><br><span class="line"><span class="keyword">type</span> InitFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, controllerCtx ControllerContext)</span> <span class="params">(controller controller.Interface, enabled <span class="keyword">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>看到这里我们似乎还是没看到 <code>StatefulSet Controller</code> 真正执行的地方，请再次回顾下我们之前 <code>NewControllerInitializers</code> 中的内容：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    controllers[<span class="string">&quot;statefulset&quot;</span>] = startStatefulSetController</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉看到了一丝丝曙光，继续往下看 <code>startStatefulSetController</code> 的具体实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startStatefulSetController</span><span class="params">(ctx context.Context, controllerContext ControllerContext)</span> <span class="params">(controller.Interface, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> statefulset.NewStatefulSetController(</span><br><span class="line"><span class="comment">// 如下是 `Sts` 直接相关类型</span></span><br><span class="line">controllerContext.InformerFactory.Core().V1().Pods(),</span><br><span class="line">controllerContext.InformerFactory.Apps().V1().StatefulSets(),</span><br><span class="line">controllerContext.InformerFactory.Core().V1().PersistentVolumeClaims(),</span><br><span class="line">controllerContext.InformerFactory.Apps().V1().ControllerRevisions(),</span><br><span class="line">controllerContext.ClientBuilder.ClientOrDie(<span class="string">&quot;statefulset-controller&quot;</span>),</span><br><span class="line">).Run(<span class="keyword">int</span>(controllerContext.ComponentConfig.StatefulSetController.ConcurrentStatefulSetSyncs), ctx.Done())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里我们终于知道了 <code>StatefulSet Controller</code> 真正意义上是被如何启动的了。</p><h1 id="StatefulSet-Controller-明细分析"><a href="#StatefulSet-Controller-明细分析" class="headerlink" title="StatefulSet Controller 明细分析"></a><code>StatefulSet Controller</code> 明细分析</h1><p>通过如上的分析，下面就到了 <code>StatefulSet Controller</code> 具体的范畴了。</p><h2 id="StatefulSetController"><a href="#StatefulSetController" class="headerlink" title="StatefulSetController"></a><code>StatefulSetController</code></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StatefulSetController <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// client interface</span></span><br><span class="line">kubeClient clientset.Interface</span><br><span class="line"><span class="comment">// control returns an interface capable of syncing a stateful set.</span></span><br><span class="line"><span class="comment">// Abstracted out for testing.</span></span><br><span class="line">control StatefulSetControlInterface</span><br><span class="line"><span class="comment">// podControl is used for patching pods.</span></span><br><span class="line">podControl controller.PodControlInterface</span><br><span class="line"><span class="comment">// podLister is able to list/get pods from a shared informer&#x27;s store</span></span><br><span class="line">podLister corelisters.PodLister</span><br><span class="line"><span class="comment">// podListerSynced returns true if the pod shared informer has synced at least once</span></span><br><span class="line">podListerSynced cache.InformerSynced</span><br><span class="line"><span class="comment">// setLister is able to list/get stateful sets from a shared informer&#x27;s store</span></span><br><span class="line">setLister appslisters.StatefulSetLister</span><br><span class="line"><span class="comment">// setListerSynced returns true if the stateful set shared informer has synced at least once</span></span><br><span class="line">setListerSynced cache.InformerSynced</span><br><span class="line"><span class="comment">// pvcListerSynced returns true if the pvc shared informer has synced at least once</span></span><br><span class="line">pvcListerSynced cache.InformerSynced</span><br><span class="line"><span class="comment">// revListerSynced returns true if the rev shared informer has synced at least once</span></span><br><span class="line">revListerSynced cache.InformerSynced</span><br><span class="line"><span class="comment">// StatefulSets that need to be synced.</span></span><br><span class="line">queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对 <code>StatefulSetController</code> 结构体的大纲，了解下大概的结构：<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/ssc.png" alt="ssc"></p><h2 id="NewStatefulSetController"><a href="#NewStatefulSetController" class="headerlink" title="NewStatefulSetController"></a><code>NewStatefulSetController</code></h2><p>对于 <code>ssc</code> 的构造函数分析：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStatefulSetController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">// 可以观察到，这边都是 `ssc` 关心的 `resource` 对象，Pod/Sts/Pvc/Revision</span></span></span><br><span class="line"><span class="function"><span class="params">podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">setInformer appsinformers.StatefulSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">revInformer appsinformers.ControllerRevisionInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">kubeClient clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">StatefulSetController</span></span> &#123;</span><br><span class="line">eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: kubeClient.CoreV1().Events(<span class="string">&quot;&quot;</span>)&#125;)</span><br><span class="line">recorder := eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">&quot;statefulset-controller&quot;</span>&#125;)</span><br><span class="line">ssc := &amp;StatefulSetController&#123;</span><br><span class="line">kubeClient: kubeClient,</span><br><span class="line">control: NewDefaultStatefulSetControl(</span><br><span class="line">NewRealStatefulPodControl(</span><br><span class="line">kubeClient,</span><br><span class="line">setInformer.Lister(),</span><br><span class="line">podInformer.Lister(),</span><br><span class="line">pvcInformer.Lister(),</span><br><span class="line">recorder),</span><br><span class="line">NewRealStatefulSetStatusUpdater(kubeClient, setInformer.Lister()),</span><br><span class="line">history.NewHistory(kubeClient, revInformer.Lister()),</span><br><span class="line">recorder,</span><br><span class="line">),</span><br><span class="line">pvcListerSynced: pvcInformer.Informer().HasSynced,</span><br><span class="line">queue:           workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">&quot;statefulset&quot;</span>),</span><br><span class="line">podControl:      controller.RealPodControl&#123;KubeClient: kubeClient, Recorder: recorder&#125;,</span><br><span class="line"></span><br><span class="line">revListerSynced: revInformer.Informer().HasSynced,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Sts` 管理的 `Pod crud` 时对应的处理方法</span></span><br><span class="line">podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line"><span class="comment">// lookup the statefulset and enqueue</span></span><br><span class="line">AddFunc: ssc.addPod,</span><br><span class="line"><span class="comment">// lookup current and old statefulset if labels changed</span></span><br><span class="line">UpdateFunc: ssc.updatePod,</span><br><span class="line"><span class="comment">// lookup statefulset accounting for deletion tombstones</span></span><br><span class="line">DeleteFunc: ssc.deletePod,</span><br><span class="line">&#125;)</span><br><span class="line">ssc.podLister = podInformer.Lister()</span><br><span class="line">ssc.podListerSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Sts crud` 时对应的方法 </span></span><br><span class="line">setInformer.Informer().AddEventHandler(</span><br><span class="line">cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: ssc.enqueueStatefulSet,</span><br><span class="line">UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">oldPS := old.(*apps.StatefulSet)</span><br><span class="line">curPS := cur.(*apps.StatefulSet)</span><br><span class="line"><span class="keyword">if</span> oldPS.Status.Replicas != curPS.Status.Replicas &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Observed updated replica count for StatefulSet: %v, %d-&gt;%d&quot;</span>, curPS.Name, oldPS.Status.Replicas, curPS.Status.Replicas)</span><br><span class="line">&#125;</span><br><span class="line">ssc.enqueueStatefulSet(cur)</span><br><span class="line">&#125;,</span><br><span class="line">DeleteFunc: ssc.enqueueStatefulSet,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">ssc.setLister = setInformer.Lister()</span><br><span class="line">ssc.setListerSynced = setInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Watch volumes</span></span><br><span class="line"><span class="keyword">return</span> ssc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ControllerRevision"><a href="#ControllerRevision" class="headerlink" title="ControllerRevision"></a><code>ControllerRevision</code></h3><p>这里了解下 <code>ControllerRevision</code> 究竟是啥，为啥需要关注。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ControllerRevision implements an immutable snapshot of state data. Clients</span></span><br><span class="line"><span class="comment">// are responsible for serializing and deserializing the objects that contain</span></span><br><span class="line"><span class="comment">// their internal state.</span></span><br><span class="line"><span class="comment">// Once a ControllerRevision has been successfully created, it can not be updated.</span></span><br><span class="line"><span class="comment">// The API Server will fail validation of all requests that attempt to mutate</span></span><br><span class="line"><span class="comment">// the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both</span></span><br><span class="line"><span class="comment">// the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However,</span></span><br><span class="line"><span class="comment">// it may be subject to name and representation changes in future releases, and clients should not</span></span><br><span class="line"><span class="comment">// depend on its stability. It is primarily for internal use by controllers.</span></span><br><span class="line"><span class="keyword">type</span> ControllerRevision <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line"><span class="comment">// Standard object&#x27;s metadata.</span></span><br><span class="line"><span class="comment">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Data is the serialized representation of the state.</span></span><br><span class="line">Data runtime.RawExtension <span class="string">`json:&quot;data,omitempty&quot; protobuf:&quot;bytes,2,opt,name=data&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Revision indicates the revision of the state represented by Data.</span></span><br><span class="line">Revision <span class="keyword">int64</span> <span class="string">`json:&quot;revision&quot; protobuf:&quot;varint,3,opt,name=revision&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由对应的注释可以知道：<br><code>ControllerRevision</code> 提供给 <code>DaemonSet</code>和 <code>StatefulSet</code> 用作更新和回滚，<code>ControllerRevision</code> 存放的是数据的快照，<code>ControllerRevision</code> 生成之后内容是不可修改的，由调用端来负责序列化写入和反序列化读取。其中 <code>Revision(int64)</code> 字段相当于 <code>ControllerRevision</code> 的版本 <code>id</code> 号，Data字段则存放序列化后的数据。<br>所以 <code>Sts</code> 的更新以及回滚是基于新旧 <code>ControllerRevision</code> 的对比来进行的。</p><h3 id="NewDefaultStatefulSetControl"><a href="#NewDefaultStatefulSetControl" class="headerlink" title="NewDefaultStatefulSetControl"></a><code>NewDefaultStatefulSetControl</code></h3><p>深入看下 <code>NewDefaultStatefulSetControl</code> 定义：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDefaultStatefulSetControl returns a new instance of the default implementation StatefulSetControlInterface that</span></span><br><span class="line"><span class="comment">// implements the documented semantics for StatefulSets. podControl is the PodControlInterface used to create, update,</span></span><br><span class="line"><span class="comment">// and delete Pods and to create PersistentVolumeClaims. statusUpdater is the StatefulSetStatusUpdaterInterface used</span></span><br><span class="line"><span class="comment">// to update the status of StatefulSets. You should use an instance returned from NewRealStatefulPodControl() for any</span></span><br><span class="line"><span class="comment">// scenario other than testing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultStatefulSetControl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">// 管理 Sts 对应的 Pod 的接口</span></span></span><br><span class="line"><span class="function"><span class="params">podControl StatefulPodControlInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">// 管理 Sts 的  Status 的更新接口</span></span></span><br><span class="line"><span class="function"><span class="params">statusUpdater StatefulSetStatusUpdaterInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">// 管理 ControllerRevision 的接口</span></span></span><br><span class="line"><span class="function"><span class="params">controllerHistory history.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">// 事件记录器接口</span></span></span><br><span class="line"><span class="function"><span class="params">recorder record.EventRecorder)</span> <span class="title">StatefulSetControlInterface</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;defaultStatefulSetControl&#123;podControl, statusUpdater, controllerHistory, recorder&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Run-函数执行过程"><a href="#Run-函数执行过程" class="headerlink" title="Run 函数执行过程"></a><code>Run</code> 函数执行过程</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the statefulset controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> ssc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">klog.Infof(<span class="string">&quot;Starting stateful set controller&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> klog.Infof(<span class="string">&quot;Shutting down statefulset controller&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">&quot;stateful set&quot;</span>, stopCh, ssc.podListerSynced, ssc.setListerSynced, ssc.pvcListerSynced, ssc.revListerSynced) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(ssc.worker, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处关注下 <code>wait.Until</code> 工具：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Until loops until stop channel is closed, running f every period.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Until is syntactic sugar on top of JitterUntil with zero jitter factor and</span></span><br><span class="line"><span class="comment">// with sliding = true (which means the timer for period starts after the f</span></span><br><span class="line"><span class="comment">// completes).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Until</span><span class="params">(f <span class="keyword">func</span>()</span>, <span class="title">period</span> <span class="title">time</span>.<span class="title">Duration</span>, <span class="title">stopCh</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;) &#123;</span><br><span class="line">JitterUntil(f, period, <span class="number">0.0</span>, <span class="literal">true</span>, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过注释可以知道， <code>Until</code> 工具会根据 <code>channel</code> 的关闭来周期性的执行函数 <code>f</code>。<br>主要解决的是当我们执行完某些操作后，还需要等待其他资源执行的情况，例如对于有依赖条件的资源释放的时候，<code>A</code> 依赖于 <code>B</code>，那么对 <code>A</code> 资源释放的时候还需要对 <code>B</code> 资源的释放进行观望。这在 <code>k8s</code> 的资源操作场景是常见的。</p><p>继续关注 <code>wait.Until</code> 中包的函数 <code>ssc.worker</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker runs a worker goroutine that invokes processNextWorkItem until the controller&#x27;s queue is closed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ssc.processNextWorkItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>worker</code> 通过运行一个 <code>goroutine</code> 来处理 <code>processNextWorkItem</code> 直到 <code>controller</code> 相关的 <code>queue</code> 被关闭。</p><p>毫无疑问，需要分析 <code>processNextWorkItem()</code> 对应函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processNextWorkItem dequeues items, processes them, and marks them done. It enforces that the syncHandler is never</span></span><br><span class="line"><span class="comment">// invoked concurrently with the same key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">key, quit := ssc.queue.Get()</span><br><span class="line"><span class="keyword">if</span> quit &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ssc.queue.Done(key)</span><br><span class="line"><span class="comment">// 其它语义很容易理解，需要关注的是 ssc.sync() 函数</span></span><br><span class="line"><span class="keyword">if</span> err := ssc.sync(key.(<span class="keyword">string</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error syncing StatefulSet %v, requeuing: %v&quot;</span>, key.(<span class="keyword">string</span>), err))</span><br><span class="line">ssc.queue.AddRateLimited(key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ssc.queue.Forget(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>processNextWorkItem()</code> 主要用于对 <code>queue</code> 的元素出队,并标记为已处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync syncs the given statefulset.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">sync</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">startTime := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Finished syncing statefulset %q (%v)&quot;</span>, key, time.Since(startTime))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对缓存中的 key 进行 split操作</span></span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对缓存根据 namespace 及 name 进行 get 操作</span></span><br><span class="line">set, err := ssc.setLister.StatefulSets(namespace).Get(name)</span><br><span class="line"><span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;StatefulSet has been deleted %v&quot;</span>, key)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;unable to retrieve StatefulSet %v from store: %v&quot;</span>, key, err))</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 sts 的 selector</span></span><br><span class="line">selector, err := metav1.LabelSelectorAsSelector(set.Spec.Selector)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error converting StatefulSet %v selector: %v&quot;</span>, key, err))</span><br><span class="line"><span class="comment">// This is a non-transient error, so don&#x27;t retry.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ssc.adoptOrphanRevisions 检查是否有孤儿 controllerrevisions 对象，若有且能匹配 selector 的则添加 ownerReferences 进行关联，已关联但 label 不匹配的则进行释放。</span></span><br><span class="line"><span class="keyword">if</span> err := ssc.adoptOrphanRevisions(set); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ssc.getPodsForStatefulSet 通过 selector 获取 sts 关联的 pod，若有孤儿 pod 的 label 与 sts 的能匹配则进行关联，若已关联的 pod label 有变化则解除与 sts 的关联关系。</span></span><br><span class="line">pods, err := ssc.getPodsForStatefulSet(set, selector)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行真正的 sync 操作</span></span><br><span class="line"><span class="keyword">return</span> ssc.syncStatefulSet(set, pods)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syncStatefulSet</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncStatefulSet syncs a tuple of (statefulset, []*v1.Pod).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">syncStatefulSet</span><span class="params">(set *apps.StatefulSet, pods []*v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Syncing StatefulSet %v/%v with %d pods&quot;</span>, set.Namespace, set.Name, <span class="built_in">len</span>(pods))</span><br><span class="line"><span class="keyword">var</span> status *apps.StatefulSetStatus</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> investigate where we mutate the set during the update as it is not obvious.</span></span><br><span class="line"><span class="comment">// 中仅仅是调用了 ssc.control.UpdateStatefulSet 方法进行处理。</span></span><br><span class="line">status, err = ssc.control.UpdateStatefulSet(set.DeepCopy(), pods)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Successfully synced StatefulSet %s/%s successful&quot;</span>, set.Namespace, set.Name)</span><br><span class="line"><span class="comment">// One more sync to handle the clock skew. This is also helping in requeuing right after status update</span></span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetMinReadySeconds) &amp;&amp; set.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp; status != <span class="literal">nil</span> &amp;&amp; status.AvailableReplicas != *set.Spec.Replicas &#123;</span><br><span class="line">ssc.enqueueSSAfter(set, time.Duration(set.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UpdateStatefulSet</code>：</p><ol><li>获取历史 <code>revisions</code>；</li><li>计算 <code>currentRevision</code> 和 <code>updateRevision</code>，若 <code>sts</code> 处于更新过程中则 <code>currentRevision</code> 和 <code>updateRevision</code> 值不同；</li><li>调用 <code>ssc.performUpdate</code> 执行实际的 <code>sync</code> 操作；</li><li>调用 <code>ssc.updateStatefulSetStatus</code> 更新 <code>status subResource</code>；</li><li>根据 <code>sts</code> 的 <code>spec.revisionHistoryLimit</code> 字段清理过期的 <code>controllerrevision</code>；</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *defaultStatefulSetControl)</span> <span class="title">UpdateStatefulSet</span><span class="params">(set *apps.StatefulSet, pods []*v1.Pod)</span> <span class="params">(*apps.StatefulSetStatus, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取 revisions 并排序</span></span><br><span class="line">revisions, err := ssc.ListRevisions(set)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">history.SortControllerRevisions(revisions)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 Revison</span></span><br><span class="line">currentRevision, updateRevision, status, err := ssc.performUpdate(set, pods, revisions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, utilerrors.NewAggregate([]error&#123;err, ssc.truncateHistory(set, pods, revisions, currentRevision, updateRevision)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期的历史版本</span></span><br><span class="line"><span class="keyword">return</span> status, ssc.truncateHistory(set, pods, revisions, currentRevision, updateRevision)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *defaultStatefulSetControl)</span> <span class="title">performUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">set *apps.StatefulSet, pods []*v1.Pod, revisions []*apps.ControllerRevision)</span> <span class="params">(*apps.ControllerRevision, *apps.ControllerRevision, *apps.StatefulSetStatus, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> currentStatus *apps.StatefulSetStatus</span><br><span class="line"><span class="comment">// get the current, and update revisions</span></span><br><span class="line">currentRevision, updateRevision, collisionCount, err := ssc.getStatefulSetRevisions(set, revisions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentRevision, updateRevision, currentStatus, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的 update 操作</span></span><br><span class="line">currentStatus, err = ssc.updateStatefulSet(set, currentRevision, updateRevision, collisionCount, pods)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentRevision, updateRevision, currentStatus, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update  status</span></span><br><span class="line">err = ssc.updateStatefulSetStatus(set, currentStatus)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentRevision, updateRevision, currentStatus, err</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;StatefulSet %s/%s pod status replicas=%d ready=%d current=%d updated=%d&quot;</span>,</span><br><span class="line">set.Namespace,</span><br><span class="line">set.Name,</span><br><span class="line">currentStatus.Replicas,</span><br><span class="line">currentStatus.ReadyReplicas,</span><br><span class="line">currentStatus.CurrentReplicas,</span><br><span class="line">currentStatus.UpdatedReplicas)</span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;StatefulSet %s/%s revisions current=%s update=%s&quot;</span>,</span><br><span class="line">set.Namespace,</span><br><span class="line">set.Name,</span><br><span class="line">currentStatus.CurrentRevision,</span><br><span class="line">currentStatus.UpdateRevision)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> currentRevision, updateRevision, currentStatus, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateStatefulSet</code>：</p><pre><code class="golang">// 作为updateStatefulSet的核心方法，重试保障Statefulset到达期望状态，update策略主要分为三类：// 1.RollingUpdateStatefulSetStrategyType// 2.OnDeleteStatefulSetStrategyType// 3.PartitionStatefulSetStrategyTypefunc (ssc *defaultStatefulSetControl) updateStatefulSet(    set *apps.StatefulSet,    currentRevision *apps.ControllerRevision,    updateRevision *apps.ControllerRevision,    collisionCount int32,    pods []*v1.Pod) (*apps.StatefulSetStatus, error) &#123;    ...    // 获取当前和更新的 Revision    currentSet, err := ApplyRevision(set, currentRevision)    ...    // 构建 sts 对象    currentSet, err := ApplyRevision(set, currentRevision)    ...    // 构建 sts 对象    updateSet, err := ApplyRevision(set, updateRevision)    ...    // status 赋值    status := apps.StatefulSetStatus&#123;&#125;    status.ObservedGeneration = set.Generation    status.CurrentRevision = currentRevision.Name    status.UpdateRevision = updateRevision.Name    status.CollisionCount = new(int32)    *status.CollisionCount = collisionCount    // replicas 存放  Pods such that 0 &lt;= getOrdinal(pod) &lt; set.Spec.Replicas    replicas := make([]*v1.Pod, replicaCount)    // condemned 存放  Pods such that set.Spec.Replicas &lt;= getOrdinal(pod)    condemned := make([]*v1.Pod, 0, len(pods))    ...    // 对 pods 进行处理分别存放到 replicas  和 condemned 切片中    for i := range pods &#123;        status.Replicas++        // 统计 running 和 ready 的副本数        if isRunningAndReady(pods[i]) &#123;            status.ReadyReplicas++            // 对门控是否开启特性的判断            if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetMinReadySeconds) &#123;                if isRunningAndAvailable(pods[i], set.Spec.MinReadySeconds) &#123;                    status.AvailableReplicas++                &#125;            &#125; else &#123;                // 如果门控特性未开启，那么所有ready 的副本数将被认为是可用状态的副本数                status.AvailableReplicas = status.ReadyReplicas            &#125;        &#125;        // 统计 current 和 update 的副本数        if isCreated(pods[i]) &amp;&amp; !isTerminating(pods[i]) &#123;            if getPodRevision(pods[i]) == currentRevision.Name &#123;                status.CurrentReplicas++            &#125;            if getPodRevision(pods[i]) == updateRevision.Name &#123;                status.UpdatedReplicas++            &#125;        &#125;        if ord := getOrdinal(pods[i]); 0 &lt;= ord &amp;&amp; ord &lt; replicaCount &#123;            // replicas 的赋值            replicas[ord] = pods[i]        &#125; else if ord &gt;= replicaCount &#123;            // condemned 的赋值            condemned = append(condemned, pods[i])        &#125;    &#125;    // 检查 replicas数组中 [0,set.Spec.Replicas) 下标是否有缺失的 pod，若有缺失的则创建对应的 pod object     // 在 newVersionedStatefulSetPod 中会判断是使用 currentSet 还是 updateSet 来创建    for ord := 0; ord &lt; replicaCount; ord++ &#123;        if replicas[ord] == nil &#123;            replicas[ord] = newVersionedStatefulSetPod(                currentSet,                updateSet,                currentRevision.Name,                updateRevision.Name, ord)        &#125;    &#125;    // 对 condemned 数组进行排序     sort.Sort(ascendingOrdinal(condemned))    // 根据 ord 在 replicas 和 condemned 数组中找出 first unhealthy Pod    for i := range replicas &#123;        if !isHealthy(replicas[i]) &#123;            unhealthy++            if firstUnhealthyPod == nil &#123;                firstUnhealthyPod = replicas[i]            &#125;        &#125;    &#125;    for i := range condemned &#123;        if !isHealthy(condemned[i]) &#123;            unhealthy++            if firstUnhealthyPod == nil &#123;                firstUnhealthyPod = condemned[i]            &#125;        &#125;    &#125;    if unhealthy &gt; 0 &#123;        klog.V(4).Infof(&quot;StatefulSet %s/%s has %d unhealthy Pods starting with %s&quot;,            set.Namespace,            set.Name,            unhealthy,            firstUnhealthyPod.Name)    &#125;    // 判断 set 是否处于 deleting     if set.DeletionTimestamp != nil &#123;        return &amp;status, nil    &#125;    // 默认设置为非并行模式    monotonic := !allowsBurst(set)    // 确保 replicas 数组中的所有 pod 都是 running 状态    for i := range replicas &#123;        // 删除和重建失败的 pods        if isFailed(replicas[i]) &#123;            ssc.recorder.Eventf(set, v1.EventTypeWarning, &quot;RecreatingFailedPod&quot;,                &quot;StatefulSet %s/%s is recreating failed Pod %s&quot;,                set.Namespace,                set.Name,                replicas[i].Name)            if err := ssc.podControl.DeleteStatefulPod(set, replicas[i]); err != nil &#123;                return &amp;status, err            &#125;            if getPodRevision(replicas[i]) == currentRevision.Name &#123;                status.CurrentReplicas--            &#125;            if getPodRevision(replicas[i]) == updateRevision.Name &#123;                status.UpdatedReplicas--            &#125;            status.Replicas--            replicas[i] = newVersionedStatefulSetPod(                currentSet,                updateSet,                currentRevision.Name,                updateRevision.Name,                i)        &#125;        // 如果 pod 未被创建则进行创建        if !isCreated(replicas[i]) &#123;            if err := ssc.podControl.CreateStatefulPod(set, replicas[i]); err != nil &#123;                return &amp;status, err            &#125;            status.Replicas++            if getPodRevision(replicas[i]) == currentRevision.Name &#123;                status.CurrentReplicas++            &#125;            if getPodRevision(replicas[i]) == updateRevision.Name &#123;                status.UpdatedReplicas++            &#125;            // if the set does not allow bursting, return immediately            if monotonic &#123;                return &amp;status, nil            &#125;            // pod created, no more work possible for this round            continue        &#125;        // 当 pod 处于 terminating 状态的时候且不允许并行的情况下 则进行等待删除完成        if isTerminating(replicas[i]) &amp;&amp; monotonic &#123;            klog.V(4).Infof(                &quot;StatefulSet %s/%s is waiting for Pod %s to Terminate&quot;,                set.Namespace,                set.Name,                replicas[i].Name)            return &amp;status, nil        &#125;        // 当 pod 已经被创建且不运行并行的情况下，状态并不是 running 和 ready 状态的处理。        if !isRunningAndReady(replicas[i]) &amp;&amp; monotonic &#123;            klog.V(4).Infof(                &quot;StatefulSet %s/%s is waiting for Pod %s to be Running and Ready&quot;,                set.Namespace,                set.Name,                replicas[i].Name)            return &amp;status, nil        &#125;        // pod creates 成功但是并不是可用状态时的处理。        if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetMinReadySeconds) &amp;&amp; !isRunningAndAvailable(replicas[i], set.Spec.MinReadySeconds) &amp;&amp; monotonic &#123;            klog.V(4).Infof(                &quot;StatefulSet %s/%s is waiting for Pod %s to be Available&quot;,                set.Namespace,                set.Name,                replicas[i].Name)            return &amp;status, nil        &#125;        // 对 sts 的唯一性及相关存储唯一性的检查        if identityMatches(set, replicas[i]) &amp;&amp; storageMatches(set, replicas[i]) &#123;            continue        &#125;        ...    &#125;&#125;至此结束。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对于分析 &lt;code&gt;Controller&lt;/code&gt; 源码选用 &lt;code&gt;StatefulSet Controller&lt;/code&gt; 来，其它控制器源码分析一个套路，可以做参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;State</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="源码分析" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="Controller" scheme="http://kiragoo.github.com/tags/Controller/"/>
    
    <category term="源码分析" scheme="http://kiragoo.github.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="StatefulSet" scheme="http://kiragoo.github.com/tags/StatefulSet/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes之编写Controller</title>
    <link href="http://kiragoo.github.com/archives/a66802dc.html"/>
    <id>http://kiragoo.github.com/archives/a66802dc.html</id>
    <published>2021-10-14T03:50:53.000Z</published>
    <updated>2022-04-21T12:46:07.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://github.com/kubernetes/community/blob/8cafef897a22026d42f5e5bb3f104febe7e29830/contributors/devel/controllers.md">Writing Controllers</a></p></blockquote><h1 id="Writing-Controller"><a href="#Writing-Controller" class="headerlink" title="Writing Controller"></a><code>Writing Controller</code></h1><p><code>Kubernetes Controller</code> 是个“常驻调谐进程”。它除了会“监视”对象的期望状态外，也会“监视”对象的运行状态。会通过发送“指令”尝试着将对象的运行状态更加趋近于期望状态。</p><p>如下是个简单的 <code>loop</code> 循环:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  desired := getDesiredState()</span><br><span class="line">  current := getCurrentState()</span><br><span class="line">  makeChanges(desired, current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Guidelines"><a href="#Guidelines" class="headerlink" title="Guidelines"></a><code>Guidelines</code></h1><p>当我们写 <code>Controller</code> 的时候，有如下知道方针来帮助我们实现我们想要的结果和表现。</p><ol><li><strong>一次之操作一个元素</strong>。 如果你使用 <code>workqueue.Interface</code>，你将能够将一个具体的<code>Resource</code>入队，然后稍后将它们 <code>pop</code> 到 <code>worker gofuncs</code>，此处需要保证的是同一时间不能有多个 <code>gofuncs</code> 处理同一个元素。</li></ol><p><code>Controllers</code> 会引发多个 <code>Resource</code> 之前的关联关系（例如 Y 发生改变了 我需要检查 X），但是几乎所有的 <code>Controller</code> 会基于 <code>relationships</code> 将检查X的所有放入到队列中。例如，<code>RepicaSet Controller</code> 需要对正在进行删除 <code>pod</code> 做出反应，但是它需要发现关联的<code>RepicaSets</code> 并且对此做出入队。</p><ol start="2"><li><strong><code>Resources</code> 随件排序</strong>。当 <code>queue off</code> 多种 <code>resources</code> 的时候，将不会保证这些 <code>resources</code> 的顺序。</li></ol><p>“监视” 将会实时的进行更新，即使在明显顺序如“create resource A/X”，“create resource B/Y”，<code>Controller</code> 也许注意到的为 <code>create resource B/Y</code>，<code>create resource A/X</code>。</p><ol start="3"><li><strong>水平驱逐而不是边缘驱逐</strong>。比如某个 <code>shell</code> 脚本没有一直运行，你的 <code>controller</code> 将再重新运行该 <code>shell</code> 之间“休眠”不确定时间。</li></ol><p>如果某个 <code>API</code> 对象出现某个 <code>marker</code> 为 <code>true</code>，你也无法判断出它是由 <code>false</code> 变成 <code>true</code> 的，你只能知道它当前为 <code>true</code>。即使 <code>API</code> “监视”深受其害，所以你将无法对此看出变化，除非你的 <code>controller</code> 在对象的 <code>status</code> 中记录相关信息。</p><ol start="4"><li>**<code>SharedInformers</code>**。<code>SharedInformers</code> 提供对具体 <code>resource</code> 的添加、更新、删除事件的钩子。同时提供对共享缓存便利性的函数访问。</li></ol><p>使用 <a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/factory.go">https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/factory.go</a> 工厂方法来保证使用相同的缓存实例。</p><p>这可以使的我们不使用 <code>API server</code>， 重复序列化会消耗服务端资源，重复反序列化会消耗控制器资源以及重复缓存会也会消耗控制器资源。</p><p>你也许发现其他的机制比如 <code>reflectors</code> 和 <code>deltafifos</code> 驱动控制器。 这些已是陈旧的机制，后续我们将构建 <code>SharedInformers</code>。你需要避免在新的控制器中使用这些。</p><ol start="5"><li><strong>切勿转换原始对象</strong>。 控制器建通过缓存来进行共享，这就意味着如果你转换了 <em>“拷贝”</em> 对象，你将使得其与其他的控制器混肴了。</li></ol><p>最常见的就是通过 <em>“浅拷贝”</em> 然后对 <code>map</code> 进行转换导致失败，比如对 <code>Annotations</code>。</p><ol start="6"><li><strong>二级缓存</strong>。许多控制器拥有一级资源和二级资源。一级资源对应着那些我们将要更新 <code>Status</code> 的原始对象资源。二级资源对应着将要管理的对象。</li></ol><p>在启用一级更新操作之前使用 <code>framework.WaitFirCacheSync</code> 来等待二级缓存。</p><ol start="7"><li><strong>系统中的其他因素</strong>。因为你没更新对象并不意味着没有其他人更新对象。</li></ol><p>不要忘记当前状态会在任意时刻发生更新–仅仅观察期望的状态是不够的。如果你使用在期望状态下的对象缺失来提示当前状态下的东西被删除，请确保你的可观察代码中没有错误（例如，在你的缓存填充之前进行处理）。</p><ol start="8"><li><strong>过滤错误到顶层以保持一直的重新队列</strong>。我们采用 <code>workqueue.RateLimitingInterface</code> 来允许简单的排队与合理的回退。</li></ol><p>当在排队时，你的主控制器返回结果应该包含 <code>error</code>。当不存在错误时，则应该使用 <code>utilruntime.HandleEroor</code> 并且以返回 <code>nil</code> 代替它。这使的审核人员能够容易地检查错误处理情况，并确信控制器不会丢失它应该重试处理的内容。</p><ol start="9"><li>**<code>Watches、Informers 将会同步</code>**。他们会定期的将集群中匹配的对象进行 <code>Update</code> 更新。这对于你可能需要对对象采取额外的操作是很好的，但是大多数情况下你知道不会存在较多的额外工作。</li></ol><p>你可以通过比对新旧对象中的资源版本来判断他们是否发生变化来决定是否需要进行再次入队处理。如果它们是相同的则跳过重新入队的工作环节。需要你注意的是，如果你曾经在再次入队的时候失败了，应该是失败处理而不是再次入队，并且不要再对它们进行重试。</p><ol start="10"><li>如果你的控制器协调的一级资源在其 <code>Status</code> 中支持 <code>ObservedGeneration</code>，请确保其正确的设置为 <code>MetaData</code> 元数据。当两个字段间不匹配的时候进行生成。</li></ol><p>这将让客户端知道控制器在处理资源。确保你的控制器是负责此资源的，否则如果你需要通过自己的控制器与其通信，你将需要在资源的<code>Status</code> 中创建一个不同类型的<code>ObservedGeneration</code>。</p><ol start="11"><li>考虑到资源创建时对其他资源的所有者引用（例如，<code>ReplicaSet</code> 导致创建 <code>Pods</code>）。因此你得确保被控制器管理的资源被删除时那些依赖的子资源能够很好的呗回收处理。关于所有者引用的更多明细，请参考<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/controller-ref.md">这里</a>。</li></ol><p>需要特别注意的是，当父资源或者子资源被标机为删除时，你不应该采用子资源。如果你对资源使用了缓存，你最好通过直接的 <code>API</code> 绕过缓存，以防你观察到的某个资源的所有者引用已被更新。所以你可以确保你的控制器不会与垃圾回收期产生竞争。</p><p>查看<a href="https://github.com/kubernetes/kubernetes/pull/42938">k8s.io/kubernetes/pull/42938</a>获取更多的细节。</p><h1 id="Rough-Structure"><a href="#Rough-Structure" class="headerlink" title="Rough Structure"></a><code>Rough Structure</code></h1><p><code>Controller</code> 大概如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// podLister is secondary cache of pods which is used for object lookups</span></span><br><span class="line">    podLister cache.StoreToPodLister</span><br><span class="line"></span><br><span class="line">    <span class="comment">// queue is where incoming work is placed to de-dup and to allow &quot;easy&quot;</span></span><br><span class="line">    <span class="comment">// rate limmited requeues on errors</span></span><br><span class="line">    queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">Run</span><span class="params">(threadiness <span class="keyword">int</span>, stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// don&#x27;t let panics crash the process</span></span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure the work queue is shutdown which will trigger workers to end</span></span><br><span class="line">    <span class="keyword">defer</span> c.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">    glog.Infof(<span class="string">&quot;Starting &lt;NAME&gt; controller&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for your secondary caches to fill before starting your work</span></span><br><span class="line">    <span class="keyword">if</span> !framework.WaitFirCacheSync(stopCh, c.PodStoreSunced) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start up your worker threads based on threadiness. Some controllers</span></span><br><span class="line">    <span class="comment">// have multiple kinds of workers</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;threadiness;i++&#123;</span><br><span class="line">        <span class="comment">// runWorker will loop until &quot;something bad&quot; happens. The .Until will</span></span><br><span class="line">        <span class="comment">// then rekick the worker after one second</span></span><br><span class="line">        <span class="keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait until we&#x27;re told to stop</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line">    glog.Infof(<span class="string">&quot;Shutting down &lt;NAME&gt; controller&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">runWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// hot loop until we&#x27;re told to stop. processNextWorkItem will</span></span><br><span class="line">    <span class="comment">// automatically wait until there&#x27;s work available, so we don&#x27;t worry </span></span><br><span class="line">    <span class="comment">// about secondary waits</span></span><br><span class="line">    <span class="keyword">for</span> c.processNextWorkItem() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processNextWorkItem deals with one key off the queue. It returns false</span></span><br><span class="line"><span class="comment">// when it&#x27;s time to quit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// pull the next work item from queue. It should be a key we use to lookup</span></span><br><span class="line">    <span class="comment">// something in a cache</span></span><br><span class="line">    key, quit := c.queue.Get()</span><br><span class="line">    <span class="keyword">if</span> quit &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// you always have to indicate to the queue that you&#x27;ve completed a piece of </span></span><br><span class="line">    <span class="comment">// work</span></span><br><span class="line">    <span class="keyword">defer</span> c.queue.Done(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do your work on the key. This method will contains your &quot;do stuff&quot; logic</span></span><br><span class="line">    err := c.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// if you had no error, thll the queue to stop tracking history for your</span></span><br><span class="line">        <span class="comment">// key. This will reset things like failuer counts for per-item rate</span></span><br><span class="line">        <span class="comment">// limiting</span></span><br><span class="line">        c.queue.Forget(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// there was a failure so be sure to report it. This method allows for </span></span><br><span class="line">    <span class="comment">// pluggable error handling which can be used for things like</span></span><br><span class="line">    <span class="comment">// cluster-monitoring</span></span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;%v failed with : %v&quot;</span>, key, err))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since we failed, we should requeue the item to work on later. This</span></span><br><span class="line">    <span class="comment">// method will add a backoff to avoid hotlooping on particular items</span></span><br><span class="line">    <span class="comment">// (they&#x27;re probably still not going to work right away) and overall</span></span><br><span class="line">    <span class="comment">// controller protection (everything I&#x27;ve done is broken, this controller</span></span><br><span class="line">    <span class="comment">// needs to calm down or it can starve other usefull work) cases.</span></span><br><span class="line">    c.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://github.com/kubernetes/community/blob/8cafef897a22026d42f5e5bb3f104febe7e29830/contributors/devel/control</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/categories/Kubernetes/"/>
    
    <category term="Controller" scheme="http://kiragoo.github.com/categories/Kubernetes/Controller/"/>
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/tags/Kubernetes/"/>
    
    <category term="Controller" scheme="http://kiragoo.github.com/tags/Controller/"/>
    
  </entry>
  
  <entry>
    <title>PersistentVolumnes 单Pod 访问模式</title>
    <link href="http://kiragoo.github.com/archives/96e8d00f.html"/>
    <id>http://kiragoo.github.com/archives/96e8d00f.html</id>
    <published>2021-09-28T03:08:05.000Z</published>
    <updated>2022-04-21T12:46:07.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://kubernetes.io/blog/2021/09/13/read-write-once-pod-access-mode-alpha/">Introducing Single Pod Access Mode for PersistentVolumes</a></p></blockquote><h1 id="访问模式及重要意义"><a href="#访问模式及重要意义" class="headerlink" title="访问模式及重要意义"></a>访问模式及重要意义</h1><p>当使用持久化储存时，对于存储有多种模式进行访问使用。</p><p>例如，存储系统中的网络文件可以同时被多个用户进行读写数据。在另一种场景下，也许每个用户允许进行读而不具备写的权限。对于高敏数据，可能只允许一个用户用户进行读写操作而不是所有的用户。</p><p>在 <code>Kubernetes</code> 的世界中，<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes"><code>access mode</code></a>就是我们定义持久化存储如何使用的方式。这些访问方式作为 <code>PVs</code> 和 <code>PVCs</code> 中 <code>spec</code> 描述的一部分内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">shared-cache</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span> <span class="comment"># Allow many pods to access shared-cache simultaneously.</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure><p>在 <code>v1.22</code> 版本之前， <code>Kubernetes</code> 为 <code>PVs</code> 和 <code>PVCs</code>提供如下三种访问模式:</p><ul><li><code>ReadWriteOnce</code> - <code>volume</code> 只允许被单个 <strong><code>node</code></strong> 进行读写</li><li><code>ReadOnlyMany</code> - <code>volume</code> 允许被多个 <strong><code>node</code></strong> 进行读操作</li><li><code>ReadWriteMany</code> - <code>volume</code> 允许被多个 <strong><code>node</code></strong> 进行读写操作</li></ul><p>这些访问模式通过 <code>Kubernetes</code> 组件如 <code>kube-controller-manager</code> 和 <code>kubelet</code> 来保证相应的 <code>Pods</code> 能够访问所应用的 <code>PersistentVolume</code>.</p><h1 id="新的访问模式及运行原理"><a href="#新的访问模式及运行原理" class="headerlink" title="新的访问模式及运行原理"></a>新的访问模式及运行原理</h1><p><code>Kubernetes v1.22</code> 介绍了 <code>PVs</code> 和 <code>PVCs</code> 的第四种访问模式：</p><ul><li><code>ReadWriteOncePod</code> - <code>volume</code> 允许单个 <strong><code>Pod</code></strong> 进行读写操作</li></ul><p>如果你对使用了 <code>PVC</code> 的 <code>Pod</code> 配置了 <code>ReadWriteOncePod</code> 的访问模式，<code>Kubernetes</code> 将确保此 <code>Pod</code> 是集群中唯一能够对此 <code>PVC</code> 进行读写的唯一 <code>Pod</code>.</p><p>如果你将另一个 <code>Pod</code> 对同一个 <code>PVC</code> 进行配置关联且也是配置了此访问模式，那么此 <code>Pod</code> 将无法启动，因为此 <code>PVC</code> 已经被另一个 <code>Pod</code> 使用了。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type     Reason            Age   From               Message</span><br><span class="line">  ----     ------            ----  ----               -------</span><br><span class="line">  Warning  FailedScheduling  1s    default-scheduler  0/1 nodes are available: 1 node has pod using PersistentVolumeClaim with the same name and ReadWriteOncePod access mode.</span><br></pre></td></tr></table></figure><h2 id="此访问模式与-ReadWriteOnce-的区别？"><a href="#此访问模式与-ReadWriteOnce-的区别？" class="headerlink" title="此访问模式与 ReadWriteOnce 的区别？"></a>此访问模式与 <code>ReadWriteOnce</code> 的区别？</h2><p><code>ReadWriteOnce</code> 访问模式约束 <code>volume</code> 对应单个 <code>node</code>，这意味着在同一个节点上的多个 <code>Pods</code> 能够读写通过一个 <code>volume</code>。对于某些应用此访问模式可能是个潜在的重大问题，尤其是对那些要求至多要求保证只有一个数据写入而言。</p><p>对 <code>PVC</code> 设置 <code>ReadWriteOncePod</code> 访问策略，那么 <code>Kubernetes</code> 将保证只有一个 <code>Pod</code> 能够进行访问。</p><h1 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h1><p><code>ReadWriteOncePod</code> 访问模式在 <code>v1.22</code> 版本中是 <code>alpha</code> 版本，并且支持 <code>CSI volume</code>。首先你得在 <code>kube-apiserver</code>, <code>kube-scheduler</code>, <code>kubelet</code> 中开启对 <code>ReadWriteOncePod</code> 的<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates">特性</a>。你可以通过设置如下命令行参数进行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--feature-gates=<span class="string">&quot;...,ReadWriteOncePod=true&quot;</span></span><br><span class="line"></span><br><span class="line">另外你的将如下 `CSI sidecars` 升级到如下版本或更高：</span><br><span class="line">- [csi-provisioner:v3.0.0+](https://github.com/kubernetes-csi/external-provisioner/releases/tag/v3.0.0)</span><br><span class="line">- [csi-attacher:v3.3.0+](https://github.com/kubernetes-csi/external-attacher/releases/tag/v3.3.0)</span><br><span class="line">- [csi-resizer:v1.3.0+](https://github.com/kubernetes-csi/external-resizer/releases/tag/v1.3.0)</span><br></pre></td></tr></table></figure><h2 id="创建-PersistentVolumeClaim"><a href="#创建-PersistentVolumeClaim" class="headerlink" title="创建 PersistentVolumeClaim"></a>创建 <code>PersistentVolumeClaim</code></h2><p>对 <code>PVs</code> 和 <code>PVCs</code> 使用 <code>ReadWriteOncePod</code> 访问模式，你需创建一个新的 <code>PVC</code> 配置如下的访问模式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">single-writer-only</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOncePod</span> <span class="comment"># Allow only a single pod to access single-writer-only.</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure><p>如果你的存储插件支持 <a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/"><code>dynamic provisioning</code></a>，新的 <code>PersistentVolumes</code> 将会应用<code>ReadWriteOncePod</code>访问模式。</p><h2 id="迁移已有的-PersistentVolumes"><a href="#迁移已有的-PersistentVolumes" class="headerlink" title="迁移已有的 PersistentVolumes"></a>迁移已有的 <code>PersistentVolumes</code></h2><p>如果你已经有了存在的 <code>PersistentVolumes</code>，也可以将它们迁移使用 <code>ReadWriteOncePod</code> 访问模式。</p><p>在此例子中，我们已经拥有了与 <code>cat-pictures-pv</code> 绑定的 <code>cat-pictures-pvc PersistentVolumeClaim</code>，另外 <code>cat-pictures-writer Deployment</code> 已经使用了此 <code>PersistentVolumeClaim</code>。</p><p>第一步，你需要编辑你的 <code>PersistentVolume</code> 中的 <code>spec.persistentVolumeReclaimPolicy</code> 将其改为 **<code>Retain</code>**。这是为了保证当我们相关 <code>PersistentVolumeClaim</code> 的时候 <code>PersistentVolume</code> 将不会被删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch pv cat-pictures-pv -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;persistentVolumeReclaimPolicy&quot;:&quot;Retain&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>下一步你需要停止那些使用了你想做迁移的 <code>PersistentVolume</code> 想关联的 <code>PersistentVolumeClaim</code> 的工作平面，同事删除这些 <code>PersistentVolumeClaim</code>。</p><p>一旦如上步骤已经完成，你需要清除与你相关的 <code>PersistenVolume</code> 相关的 <code>spec.claimRef.uid</code> 字段内容，以便确保 <code>PersistentVolumeClaims</code> 能够在再次创建过程中能够被绑定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=0 deployment cat-pictures-writer</span><br><span class="line">kubectl delete pvc cat-pictures-pvc</span><br><span class="line">kubectl patch pv cat-pictures-pv -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;claimRef&quot;:&#123;&quot;uid&quot;:&quot;&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>结束之后你需要将 <code>PersistentVolume</code> 的访问模式替换为 <code>ReadWriteOncePod</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch pv cat-pictures-pv -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;accessModes&quot;:[&quot;ReadWriteOncePod&quot;]&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Note</strong>：<code>ReadWriteOncePod</code> 访问模式无法与其他的访问模式进行结合使用。确保在更新 <code>PersistentVolume</code> 的时候 <code>ReadWriteOncePod</code>是唯一的访问模式，否则将会放生请求失败。</p></blockquote><p>下一步你的得将你的 <code>PersistentVolumeClaim</code> 修改为 <code>ReadWriteOncePod</code> 作为唯一的访问模式。同时你还得将配置 <code>PersistentVolumeClaim</code> 中的 <code>spec.volumeName</code> 对应到你的 <code>PersistentVolume</code>。</p><p>一旦以上步骤都已经完成，你可以重新创建你的 <code>PersistenVolumeClaim</code> 并且启动你的工作平面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># IMPORTANT: Make sure to edit your PVC in cat-pictures-pvc.yaml before applying. You need to:</span></span><br><span class="line"><span class="comment"># - Set ReadWriteOncePod as the only access mode</span></span><br><span class="line"><span class="comment"># - Set spec.volumeName to &quot;cat-pictures-pv&quot;</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f cat-pictures-pvc.yaml</span><br><span class="line">kubectl apply -f cat-pictures-writer-deployment.yaml</span><br></pre></td></tr></table></figure><p>最后你可能需要编辑的你的 <code>PersistentVolume</code> 中 <code>spec.persistentVolumeReclaimPolicy</code> 字段并将其配置为 <code>Delete</code> 如果你确实改动过它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch pv cat-pictures-pv -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;persistentVolumeReclaimPolicy&quot;:&quot;Delete&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>你可以阅读<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/">Configure a Pod to Use a PersistentVolume for Storage</a>了解更多的细节。</p>]]></content>
    
    
    <summary type="html">介绍与迁移示例</summary>
    
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/categories/Kubernetes/"/>
    
    <category term="PersistentVolumes" scheme="http://kiragoo.github.com/categories/Kubernetes/PersistentVolumes/"/>
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/tags/Kubernetes/"/>
    
    <category term="PersistentVolumes" scheme="http://kiragoo.github.com/tags/PersistentVolumes/"/>
    
  </entry>
  
  <entry>
    <title>深入理解k8s网络原理之-Service原理</title>
    <link href="http://kiragoo.github.com/archives/1d9c7e0d.html"/>
    <id>http://kiragoo.github.com/archives/1d9c7e0d.html</id>
    <published>2021-09-13T02:05:16.000Z</published>
    <updated>2023-04-03T08:26:56.200Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>收集整理，转载自<a href="https://zhuanlan.zhihu.com/p/404837363">深入理解kubernetes（k8s）网络原理之二-service原理</a></p></blockquote><p>在<a href="https://kiragoo.github.io/archives/1d9a37c9.html">深入理解k8s网路原理之-POD连接主机</a>中主要介绍了<code>POD</code>与主机及<code>POD</code>访问外网的原理。</p><h2 id="Linux网络基础知识"><a href="#Linux网络基础知识" class="headerlink" title="Linux网络基础知识"></a><code>Linux</code>网络基础知识</h2><h3 id="netfilter"><a href="#netfilter" class="headerlink" title="netfilter"></a><code>netfilter</code></h3><p><code>netfileter</code>子系统5个关键扩展点：</p><ul><li><code>PREROUTING</code>，数据包刚到达时会经过这个点，通常用来完成DNAT的功能。</li><li><code>INPUT</code>，数据包要进入本机的传输层时会经过这个点，通常用来完成防火墙入站检测。</li><li><code>FORWARD</code>，数据包要通过本机转发时会经过这个点，通常用来完成防火墙转发过滤。</li><li><code>OUTPUT</code>，从本机的数据包要出去的时候会经过这个点，通常用来做DNAT和防火墙出站检测。</li><li><code>POSTROUTING</code>，数据包离开本机前会经过这个点，通常用来做SNAT。</li></ul><p><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/netfilter.drawio.png" alt="netfilter"><br>1、 主机的应用程序接收外部的数据包会经过的点: PREROUTING -&gt; INPUT</p><p>2、 主机的应用程序发送数据包到外部经过的点: OUTPUT -&gt; POSTROUTING</p><p>3、 主机的<code>POD</code>发送的数据包去外部或者去主机的另外一个<code>POD</code>: PREROUTING -&gt; FORWARD -&gt; POSTROUTING</p><blockquote><p>主机上运行的<code>POD</code>虽然也是主机上的一个进程，但是<code>POD</code>发送数据包出去的流程去和主机的其他进程不一样，由于<code>POD</code>在新的<code>NS</code>中，所以他的发包流程适合主机收到另一台主机的数据然后转发的流程是一样的。</p></blockquote><p>4、<strong>注意图中的<code>IPIsLocal</code>？的判断，如果数据包的目标<code>IP</code>是本机<code>IP</code>,则往<code>INPUT</code>点走，否则查看<code>net.ipv4.ip_forward</code>是否为1，是则往<code>FORWARD</code>走，0则丢弃。</strong></p><h3 id="iptables-基础知识"><a href="#iptables-基础知识" class="headerlink" title="iptables 基础知识"></a><code>iptables</code> 基础知识</h3><p><code>iptables</code> 初识别</p><p><code>iptables -A INPUT -t filter -s 192.168.1.10 -j DROP</code><br>意思是指不允许来源为<code>192.168.1.10</code>的<code>ip</code>访问本机的服务。</p><p>命令详解：</p><ul><li>-A 是指后面加一条规则,其他为<ul><li>-I 是前面加一条规则，优先级更高</li><li>-D 删除规则</li><li>-N 新增加链</li><li>-F 清除链上的所有规则或者所有链</li><li>-X 删除一条用户的自定义链</li><li>-P 更改链的默认策略</li><li>-L 真是指定链上的规则</li></ul></li><li>防火墙规则一般制工作在<code>INPUT/OUTPUT/FORWARD</code>三个扩展点</li><li>-t 指定当前命令操作所属的表，主要有：<ul><li><code>filter</code> 表，主要用于拦截或者房型，不修改包，如果不指定，则默认为<code>filter</code>表</li><li><code>nat</code> 表，用于修改<code>ip</code>包的源/目的地址</li><li><code>mangle</code> 表，用于给数据包打标记</li><li><code>raw</code> 表，#TODO</li><li><code>security</code> 表， #TODO</li></ul></li><li>-s 数据包的匹配规则，规则可以一个或者多个，多个是与的效果，这里 -s 是匹配来源的的意思，其他的还有<ul><li>-d 匹配目标地址</li><li>–sport 匹配来源端口</li><li>–dport 匹配目标端口</li><li>-p tcp 匹配协议类型</li></ul></li><li>-j <code>DROP</code>是执行的动作，这里是跳转到（<code>jump</code>）<code>DROP</code> 链，<code>iptables</code> 有几个预定义的链:<ul><li><code>DROP</code> 丢弃进入该链的包</li><li><code>ACCEPT</code> 接收进入该链的包</li><li><code>RETURN</code> 返回上一级链</li><li><code>SNAT</code> 源地址转换，要指定转换后的源地址</li><li><code>DNAT</code> 目标地址转换，要指定转换后目标地址</li><li><code>MASQUEREDE</code> 对进入该链的包进行源地址转换，与<code>SNAT</code> 类似，但不用指定具体的转换后的源地址，会自动应用网卡的地址作为原地址，通常都用这条链完成<code>SNAT</code>。<br>进阶示例：<br>— 把本机应用发往10.96.0.100的数据包的目标地址转换为10.244.3.10上，注意使要影响本机应用，</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A OUTPUT -t nat -d 10.96.0.100 -j DNAT --to-distination 10.244.3.10</span><br></pre></td></tr></table></figure><ul><li>上面的规则支队本机的应用程序发送的流量有影响， 对于本机的<code>POD</code>发出的流量乜有影响，如果要影响本机的<code>POD</code>，还要加一条，规则都一样，只是工作在<code>PREROUTING</code>链.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A RPEROTING -t nat -d 10.96.0.100 -j DNAT --to-distination 10.244.3.10</span><br></pre></td></tr></table></figure><ul><li>对本机发送的数据包中来源<code>ip</code> 为172.20.1.10 的数据包进行源地址伪装，注意修改源地址只有个一个点可以用，就是<code>POSTROUTING</code>，下面的规则就是配置<code>POD</code>上外网时使用的：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptabels -A POSTROUTING -t NAT -S 172.20.1.10 -j MASQUEREDE</span><br></pre></td></tr></table></figure><ul><li>允许来源<code>IP</code>为192.168.6.166并访问本机的<code>TCP</code>80 端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A  INPUT -t filter -s 192.168.8.166 -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><blockquote><p><code>iptables</code> 上的规则创建会有一些限制，如无法在<code>POSTROUTING</code>链上创建<code>DNAT</code>的规则，因为饿在<code>POSTROUTING</code>之前，数据包要进行路由判决，内核会根据当前的目的地选择一个最合适的出口，而<code>POSTROUTING</code>链的规则是在路由判决后发生，在这里修改数据包的目的地会造成数据包不可到达的后果。</p></blockquote><h3 id="K8S-的-Service-设计"><a href="#K8S-的-Service-设计" class="headerlink" title="K8S 的 Service 设计"></a><code>K8S</code> 的 <code>Service</code> 设计</h3><p>主要考虑如下两个原因：</p><ul><li><code>pod</code> 的特性是快速创建销毁，所以<code>pod</code>的<code>ip</code>是不固定的，要让调用方有个固定依赖，所以需要一个<code>VIP</code>来代表服务</li><li>一般来说为了追求应用的高可用，一个应用会部署多个<code>POD</code>,这时需要一个<code>VIP</code>充当多个<code>pod</code>的流量负载</li></ul><h4 id="service-几种类型的使用场景"><a href="#service-几种类型的使用场景" class="headerlink" title="service 几种类型的使用场景"></a><code>service</code> 几种类型的使用场景</h4><ul><li><code>clusterIP</code>: 只能在集群的节点和<code>pod</code>中访问，解决的就是集群内应用间的相互访问的问题</li><li><code>nodeport</code>: 通过节点的地址和端口将<code>pod</code>暴露到集群外，让集群外的应用能够访问集群内的应用，设置服务类型为<code>nodeport</code>时，是在<code>clusterIP</code>的基础上再给节点开个端口转发，所以<code>nodeport</code>的服务也会有一个<code>clusterIP</code></li><li><code>loadBalancer</code>: 因为使用<code>nodeport</code>方式时，需要在应用的调用方写死一个集群节点的<code>IP</code>,此方式并非为高可用方式，这个时候使用第三方负载均衡器的方式，转发到多个节点的<code>nodeport</code>，<code>loadBanlancer</code>是在<code>nodeport</code>的基础上再创建一个<code>lb</code>，所以也会先分配一个<code>clusterIP</code>,再创建节点的端口转发。</li><li><code>headless</code>: 应用多个副本彼此间相互访问，比如要部署到<code>mysql</code>的主从，从的副本想要找主的副本:</li><li><code>externalName</code>: 相当于<code>coredns</code>里面的<code>cname</code>记录</li></ul><blockquote><p>在<code>iptables</code> 模式下，<code>clusterIP</code>都是<code>ping</code>不通的，这是因为 <code>kube-proxy</code> 在实现时之根据<code>ip</code>+端口+协议精确匹配才转发，这才导致<code>clusterIP</code>不能<code>ping</code></p></blockquote><p><strong><code>hairpin flow</code>场景: <code>pod</code>通过<code>clusterIP</code>访问自己</strong></p><blockquote><p>推荐一篇万字长文<a href="https://mp.weixin.qq.com/s/Dgv5BU9YU0tuSMxtzcuiVw"><code>iptables</code>长文详解</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;收集整理，转载自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/404837363&quot;&gt;深入理解kubernetes（k8s）网络原理之二-service原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a hr</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="network" scheme="http://kiragoo.github.com/categories/kubernetes/network/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="iptables" scheme="http://kiragoo.github.com/tags/iptables/"/>
    
    <category term="network" scheme="http://kiragoo.github.com/tags/network/"/>
    
    <category term="service" scheme="http://kiragoo.github.com/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>深入理解k8s网路原理之-POD连接主机</title>
    <link href="http://kiragoo.github.com/archives/1d9a37c9.html"/>
    <id>http://kiragoo.github.com/archives/1d9a37c9.html</id>
    <published>2021-09-03T07:58:47.000Z</published>
    <updated>2022-04-21T12:46:07.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://zhuanlan.zhihu.com/p/403856388">深入理解kubernetes（k8s）网络原理之一-pod连接主机</a></p></blockquote><h1 id="关于Linux网络的知识"><a href="#关于Linux网络的知识" class="headerlink" title="关于Linux网络的知识"></a>关于<code>Linux</code>网络的知识</h1><h2 id="向外发送一个数据包，执行步骤："><a href="#向外发送一个数据包，执行步骤：" class="headerlink" title="向外发送一个数据包，执行步骤："></a>向外发送一个数据包，执行步骤：</h2><p>1、查找该数据包的目的地的路由信息，如果是直连，则在邻居表中查找该目的地的<code>Mac</code>地址<br>2、如果非直连路由，则在邻居表中查找下一跳的<code>Mac</code>地址<br>3、如果找不到对应的路由，则报<code>&quot;network is unreachable&quot;</code><br>4、如果在邻居表中没有查到相应的<code>MAC</code>地址信息，则向外发送<code>ARP</code>请求询问<br>5、发送出去的数据帧，源<code>MAC</code>地址为发送网卡的<code>MAC</code>地址，目标<code>MAC</code>则是下一跳的<code>MAC</code>，只要不经过<code>NAT</code>，那么源目的<code>IP</code>全程不会变化，而<code>MAC</code>地址则每一跳都会变化</p><h2 id="收到数据帧，执行步骤"><a href="#收到数据帧，执行步骤" class="headerlink" title="收到数据帧，执行步骤"></a>收到数据帧，执行步骤</h2><p>1、如果数据帧目标<code>MAC</code>地址不是收包网卡的<code>MAC</code>，也不是<code>ARP</code>广播地址，且网卡未开启混杂模式，则拒绝收包<br>2、如果数据帧目标<code>MAC</code>为<code>ff:ff:ff:ff:ff:ff</code>，则进入<code>ARP</code>请求处理流程<br>3、如果数据帧目标<code>MAC</code>地址是收包网卡的<code>MAC</code>，且是<code>IP</code>包则：<br>    1、目标<code>IP</code>地址在本机，则上送到上一层协议继续处理<br>    2、目标<code>IP</code>地址不在本机，则看<code>net.ipv4.ip_forward</code>是否为1，若是1，则查找目标<code>IP</code>的路由信息，进行转发<br>    3、目标<code>IP</code>不在本机，且<code>net.ipv4.ip_forward</code>为0，则丢弃</p><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡信息</span></span><br><span class="line">ip link </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡ip地址</span></span><br><span class="line">ip addr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看邻居表信息</span></span><br><span class="line">ip neigh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有iptables规则</span></span><br><span class="line">iptables-save</span><br></pre></td></tr></table></figure><blockquote><p>为了让多个进程高效互不影响地运行，衍生出容器技术，其中以<code>Docker</code>最为流行：<br>1、资源隔离： 使用<code>linux control group</code> 解决各种进程<code>CPU</code>和<code>Memory</code>、<code>io</code>的资源分配问题<br>2、网络隔离： 使用<code>linux network group</code>让各个进程运行在独立的网络命名空间，使各个进程运行在独立的网络命名空间<br>3、文件系统隔离：使用<code>union fs</code>，让各个进程运行在独立的根文件系统中</p></blockquote><p><strong><code>POD</code>即共享同一个<code>ns</code>的多个容器</strong></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><code>docker</code> 运行一个容器时，都会为当前容器创建一个<code>ns</code>，多个容器只能相互访问对方的<code>ip</code>地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=pause busybox</span><br><span class="line">docker run --name=nginx -d nginx  </span><br></pre></td></tr></table></figure><p>此时要在 <code>pause</code> 中访问 <code>nginx</code>，先查找下<code>nginx</code>容器的<code>ip</code>地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker inspect nginx | grep IPAddress</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br></pre></td></tr></table></figure><p>然后在<code>pause</code>容器中用刚查到的<code>ip</code>地址进行访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it pause curl 172.17.0.8</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">....</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这里可以让 <code>nginx</code> 容器加入<code>pause</code>容器的<code>ns</code>，用下面的命令可以模拟：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=pause busybox</span><br><span class="line">docker run --name=nginx --network=container:pause -d nginx</span><br></pre></td></tr></table></figure><p>此时<code>pause</code>容器和<code>nginx</code>容器是在相同的<code>ns</code>中，相互间访问就可以使用`localhost进行访问了，可以用下面的命令进行验证:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it pause culr localhost</span><br></pre></td></tr></table></figure><p><em><code>pause</code>容器和<code>nginx</code>容器就是共享一个<code>ns</code>的两个容器，所以<code>pause</code>和<code>nginx</code>两个容器加起来就是<code>k8s</code>的<code>pod</code></em></p><blockquote><p>在<code>k8s</code>集群的节点中使用<code>docker ps</code>，总会发现一堆名为<code>pause</code>的容器，<code>pause</code>是为多个业务容器提供共享的<code>ns</code>的。</p></blockquote><p>1、进入<code>docker</code>创建的<code>pause</code>容器的<code>ns 先获取</code>pause<code>容器的</code>pid`</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect pause | grep Pid</span><br></pre></td></tr></table></figure><p>2、进入指定<code>pid</code>的`ns</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsenter --net=/proc/3083138/ns/net</span><br></pre></td></tr></table></figure><p>3、此时已经在<code>pause</code>容器的<code>ns</code>中了，可以查看该<code>ns</code>的网卡，路由表，邻居表等信息了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br><span class="line">ip route</span><br></pre></td></tr></table></figure><h1 id="认识ns"><a href="#认识ns" class="headerlink" title="认识ns"></a>认识<code>ns</code></h1><p>影响网络方面的配置主要有以下几个：<br>— 网卡：启动时初始化，后期可以添加虚拟设备</p><ul><li>端口：1到65535，所有进程共享</li><li><code>iptables</code>规则： 配置进出主机的防火墙策略和<code>NAT</code>规则</li><li>路由表：到目标地址的路由信息</li><li>邻居表：与主机在同个二层网络的其他主机的<code>MAC</code>地址与<code>IP</code>地址的映射关系</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>1、创建新的<code>ns</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns add ns1</span><br></pre></td></tr></table></figure><p>然后可以使用<code>ip netns exec ns1</code>前缀来执行命令，这样显示的结果就都是<code>ns1</code>的网络相关的配置了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip link show</span><br></pre></td></tr></table></figure><p>2、主机与<code>pod</code>相互访问<br>首先给<code>ns1</code>正价一张与主机相连的网卡，这里用到<code>linux</code>虚拟网络设备<code>veth</code>网卡对，对于<code>veth</code>，基本可以理解为中间连着线的两张网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 增加一对veth网卡，名为 ns1-eth0 和 veth-ns1</span></span><br><span class="line">ip link add ns1-eth0 type veth peer name veth-ns1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中一端挪到刚才创建的ns1中，另一端留在主机端，这样主机和ns就连接起来了</span></span><br><span class="line">ip link set ns1-eth0 netns ns1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动主机端的网卡veth-ns1</span></span><br><span class="line">ip link set veth-ns1 up</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行设置网卡的ip</span></span><br><span class="line">ip netns exec ns1 ip addr add 172.20.1.10/24 dev ns1-eth0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动ns1端的网卡ns1-eth0</span></span><br><span class="line">ip netns exec ns1 ip link set ns1-eth0 up</span><br></pre></td></tr></table></figure><p>3、测试与主机<code>ip</code>是否能<code>ping</code>通</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ping xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><p>此时发现不能<code>ping</code>通主机，这是因为没有到目的地的路由，所以在这里给<code>ns1</code>增加一条默认路由</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip route add default via 172.20.1.1. dev ns-eth0</span><br></pre></td></tr></table></figure><p>通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netsns exec ns1 ip route</span><br></pre></td></tr></table></figure><p>查看路由信息<br>此时去<code>ping</code>发现还是不行，这是因为<em>如果是非直连路由，会先去拿下一跳的<code>mac</code>地址，下一跳是<code>172..20.1.1</code>，能获取到它的<code>MAC</code>地址吗？</em><br>用如下命令查一下路由表:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip neigh</span><br></pre></td></tr></table></figure><p>会发现获取不到，以为网关<code>ip</code>地址确实是个不存在的地址，网关<code>IP</code>是不会出现在<code>pod</code>发送的数据包中的，真正需要用的是网关的<code>mac</code>地址，我们的目的是要得到主机端<code>veth-ns1</code>的<code>mac</code>地址，有两个方法：<br>·、设置对端的网卡<code>apr</code>代答，<code>ns1-eth0</code>的对端是主机上的<code>veth-ns1</code>网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这样就开启了veth-ns1的arp代答，只要收到arp请求，不管目标IP是什么，veth-ns1网卡都会把自己MAC地址回复回去</span></span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/veth-ns1/proxy_arp </span><br></pre></td></tr></table></figure><p>或者把网关地址设置在对端的网卡上<br>4、此时拿到网关的<code>mac</code>地址但是<code>ping</code>之后发现还是不行。这是因为主机上没有添加到<code>pod</code>的直连路由</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add 172.20.1.10 dev veth-ns1</span><br></pre></td></tr></table></figure><p>此时只能保证主机与<code>pod</code>进行互通，此时<code>pod</code>是没法访问外网的，这个时候需要做原地址转换，所以我们需要在主机上也要配置针对刚才创建的<code>pod</code>的原地址转换规则。</p><h2 id="pod访问外网"><a href="#pod访问外网" class="headerlink" title="pod访问外网"></a><code>pod</code>访问外网</h2><ul><li>首先第一步需要打开本机的<code>ip</code>转发功能<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></li><li>设置<code>snat</code>规则<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A POSTROUTING -t nat -s 172.20.1.10 -j MASQUERADE</span><br></pre></td></tr></table></figure>此时发现可以<code>ping</code>通百度</li></ul>]]></content>
    
    
    <summary type="html">温顾而知新，最近在做公司产品 `MQ` 场景的 `Operator` 开发设计，好久没更新博客了。</summary>
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="network" scheme="http://kiragoo.github.com/categories/kubernetes/network/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="network" scheme="http://kiragoo.github.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Istio初体验之后续补充</title>
    <link href="http://kiragoo.github.com/archives/ffa85151.html"/>
    <id>http://kiragoo.github.com/archives/ffa85151.html</id>
    <published>2021-05-12T10:33:02.000Z</published>
    <updated>2023-04-03T08:26:55.906Z</updated>
    
    <content type="html"><![CDATA[<p>继<a href="https://kiragoo.github.io/archives/b47cf59d.html">docker desktop之Istio初体验</a>中完成集群内部基础组件部署之后，我们有了大概的认知。其中关于如何将服务对外暴露并没有明细说明太多，此篇补充下<em>如何对外开放应用服务</em>。</p><h1 id="对外开放应用程序"><a href="#对外开放应用程序" class="headerlink" title="对外开放应用程序"></a>对外开放应用程序</h1><p>此时我们查看如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  kubectl get pods                                                ✔  18:28:42</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-79c697d759-smfhp       2/2     Running   0          5m56s</span><br><span class="line">productpage-v1-65576bb7bf-k6797   2/2     Running   0          5m54s</span><br><span class="line">ratings-v1-7d99676f7f-xjr74       2/2     Running   0          5m55s</span><br><span class="line">reviews-v1-987d495c-2hqcg         2/2     Running   0          5m55s</span><br><span class="line">reviews-v2-6c5bf657cf-s4db5       2/2     Running   0          5m56s</span><br><span class="line">reviews-v3-5f7b9f4f77-7rt5t       2/2     Running   0          5m55s</span><br><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  kubectl <span class="built_in">exec</span> <span class="string">&quot;<span class="subst">$(kubectl get pod -l app=ratings -o jsonpath=&#x27;&#123;.items[0].metadata.name&#125;&#x27;)</span>&quot;</span> -c ratings -- curl -s productpage:9080/productpage | grep -o <span class="string">&quot;&lt;title&gt;.*&lt;/title&gt;&quot;</span> </span><br><span class="line"></span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure><p>确保服务状态都是正常的。</p><p>此时，<code>BookInfo</code> 应用已经部署，但还不能被外界访问。 要开放访问，你需要创建 <a href="https://kiragoo.github.io/archives/c3a53ddf.html"><code>Istio</code> 入站网关（<code>Ingress Gateway</code>）</a>, 它会在网格边缘把一个路径映射到路由。</p><blockquote><p>如对基础概念还不清楚的，可以参考<a href="https://kiragoo.github.io/archives/6a996a50.html">Istio-文档-概念</a></p></blockquote><ol><li>把应用关联到<code>Istio</code>网关：<br>先看下 <code>bookinfo-gateway.yaml</code> 中内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io&#x2F;v1alpha3</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  name: bookinfo-gateway</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    istio: ingressgateway # use istio default controller</span><br><span class="line">  servers:</span><br><span class="line">  - port:</span><br><span class="line">      number: 80</span><br><span class="line">      name: http</span><br><span class="line">      protocol: HTTP</span><br><span class="line">    hosts:</span><br><span class="line">    - &quot;*&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: networking.istio.io&#x2F;v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: bookinfo</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">  - &quot;*&quot;</span><br><span class="line">  gateways:</span><br><span class="line">  - bookinfo-gateway</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - uri:</span><br><span class="line">        exact: &#x2F;productpage</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: &#x2F;static</span><br><span class="line">    - uri:</span><br><span class="line">        exact: &#x2F;login</span><br><span class="line">    - uri:</span><br><span class="line">        exact: &#x2F;logout</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: &#x2F;api&#x2F;v1&#x2F;products</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: productpage</span><br><span class="line">        port:</span><br><span class="line">          number: 9080</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml </span><br><span class="line">gateway.networking.istio.io/bookinfo-gateway created</span><br><span class="line">virtualservice.networking.istio.io/bookinfo created</span><br></pre></td></tr></table></figure></li><li>确保配置文件没有问题：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  istioctl analyze                                                ✔  18:43:44</span><br><span class="line">✔ No validation issues found when analyzing namespace: default.</span><br></pre></td></tr></table></figure><h2 id="确定入站-IP-和端口"><a href="#确定入站-IP-和端口" class="headerlink" title="确定入站 IP 和端口"></a>确定入站 <code>IP</code> 和端口</h2>为访问网关设置两个变量：<code>INGRESS_HOST</code> 和 <code>INGRESS_PORT</code>。*由于我的环境是<code>Mac</code>，通过<code>docker desktop</code>部署的<code>k8s</code>*，所以如下的为此环境的处理方式。</li></ol><p>执行下面命令进行判断：你的 <code>Kubernetes</code> 集群环境是否支持外部负载均衡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  kubectl get svc istio-ingressgateway -n istio-system                                                   ✔  18:50:32</span><br><span class="line"></span><br><span class="line">NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.106.247.46   localhost     15021:30307/TCP,80:30353/TCP,443:30695/TCP,31400:30328/TCP,15443:32035/TCP   28m</span><br></pre></td></tr></table></figure><p>设置 <code>EXTERNAL-IP</code> 的值之后， 你的环境就有了一个外部的负载均衡，可以用它做入站网关。 但如果 <code>EXTERNAL-IP</code> 的值为 &lt;<code>none</code>&gt; (或者一直是 &lt;<code>pending</code>&gt; 状态)， 则你的环境则没有提供可作为入站流量网关的外部负载均衡。 这个情况，你还可以用服务（<code>Service</code>）的 节点端口 访问网关。</p><ul><li><p><strong>由于我的环境中确实存在外部的负载均衡，那么继续往下走。</strong><br>设置入站 <code>IP</code> 地址和端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">export</span> INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.status.loadBalancer.ingress[0].ip&#125;&#x27;</span>) </span><br><span class="line"></span><br><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].port&#125;&#x27;</span>) </span><br><span class="line"></span><br><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;https&quot;)].port&#125;&#x27;</span>) </span><br></pre></td></tr></table></figure><blockquote><p>在某些环境中，负载均衡除了 <code>IP</code> 地址，还可以用主机名访问。 在这种情况下，入站流量网关的<code>EXTERNAL-IP</code> 值不是 <code>IP</code> 地址，而是一个主机名， 那上面设置 <code>INGRESS_HOST</code> 环境变量的操作会失败。 使用下面命令纠正 <code>INGRESS_HOST</code> 的值。<strong>我的环境是出现这样的情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ <span class="built_in">export</span> INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.status.loadBalancer.ingress[0].hostname&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>如果没有负载均衡，那就选择一个节点端口来代替</strong><br>设置入站的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].nodePort&#125;&#x27;</span>)</span><br><span class="line">$ <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;https&quot;)].nodePort&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><code>GKE</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=workerNodeAddress</span><br></pre></td></tr></table></figure><p>你需要创建一个防火墙规则，放行发往 <code>ingressgateway</code> 的 <code>TCP</code> 流量。 再运行下面的命令，单独放行发往 <code>HTTP</code> 端口或 <code>HTTPS</code> 端口的流量，或者都放行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcloud compute firewall-rules create allow-gateway-http --allow <span class="string">&quot;tcp:<span class="variable">$INGRESS_PORT</span>&quot;</span></span><br><span class="line">$ gcloud compute firewall-rules create allow-gateway-https --allow <span class="string">&quot;tcp:<span class="variable">$SECURE_INGRESS_PORT</span>&quot;</span></span><br></pre></td></tr></table></figure><p><code>IBM Cloud Kubernetes Service</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ibmcloud ks workers --cluster cluster-name-or-id</span><br><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=public-IP-of-one-of-the-worker-nodes</span><br></pre></td></tr></table></figure><p><code>Docker For Desktop</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=127.0.0.1</span><br></pre></td></tr></table></figure><p><code>Other environments</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath=<span class="string">&#x27;&#123;.items[0].status.hostIP&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>设置环境变量 <code>GATEWAY_URL</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">export</span> GATEWAY_URL=<span class="variable">$INGRESS_HOST</span>:<span class="variable">$INGRESS_PORT</span>                                                         ✔  18:54:31</span><br></pre></td></tr></table></figure></li><li>确保 <code>IP</code>地址和端口均成功的赋值给了环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">echo</span> <span class="variable">$GATEWAY_URL</span>                                                                                      ✔  19:03:53</span><br><span class="line">localhost:80</span><br></pre></td></tr></table></figure><h2 id="验证外部访问"><a href="#验证外部访问" class="headerlink" title="验证外部访问"></a>验证外部访问</h2>用浏览器查看 <code>Bookinfo</code> 应用的产品页面，验证 <code>Bookinfo</code> 已经实现了外部访问。</li><li>运行下面命令，获取 <code>Bookinfo</code> 应用的外部访问地址。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">echo</span> <span class="string">&quot;http://<span class="variable">$GATEWAY_URL</span>/productpage&quot;</span>                                                                 ✔  19:03:58</span><br><span class="line">http://localhost:80/productpage</span><br></pre></td></tr></table></figure></li><li>把上面命令的输出地址复制粘贴到浏览器并访问，确认 Bookinfo 应用的产品页面是否可以打开。<br><img src="https://kblogs.oss-cn-beijing.aliyuncs.com/blogimgs/bookinfo.png" alt="bookinfo"></li></ol><p>至此结束，后续继续更新<code>Istio</code>相关文章。</p><blockquote><p>参考<a href="https://istio.io/latest/zh/docs/setup/getting-started/">入门</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继&lt;a href=&quot;https://kiragoo.github.io/archives/b47cf59d.html&quot;&gt;docker desktop之Istio初体验&lt;/a&gt;中完成集群内部基础组件部署之后，我们有了大概的认知。其中关于如何将服务对外暴露并没有明细说明太多，此</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="istio" scheme="http://kiragoo.github.com/categories/kubernetes/istio/"/>
    
    
    <category term="kubernetes - istio" scheme="http://kiragoo.github.com/tags/kubernetes-istio/"/>
    
  </entry>
  
  <entry>
    <title>Isotio-文档-流量管理</title>
    <link href="http://kiragoo.github.com/archives/c3a53ddf.html"/>
    <id>http://kiragoo.github.com/archives/c3a53ddf.html</id>
    <published>2021-05-11T03:32:06.000Z</published>
    <updated>2023-04-03T08:26:56.068Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/">istio文档</a></p></blockquote><h1 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h1><p><code>Istio</code> 的流量路由规则可以让您很容易的控制服务之间的流量和 <code>API</code> 调用。<code>Istio</code> 简化了服务级别属性的配置，比如熔断器、超时和重试，并且能轻松的设置重要的任务，如 <code>A/B</code> 测试、金丝雀发布、基于流量百分比切分的概率发布等。它还提供了开箱即用的故障恢复特性，有助于增强应用的健壮性，从而更好地应对被依赖的服务或网络发生故障的情况。</p><p><code>Istio</code> 的流量管理模型源于和服务一起部署的 <a href="https://envoyproxy.github.io/envoy/"><code>Envoy</code> 代理</a>。网格内服务发送和接收的所有流量（<code>data plane</code>流量）都经由 <code>Envoy</code> 代理，这让控制网格内的流量变得异常简单，而且不需要对服务做任何的更改。</p><p>本节中描述的功能特性，如果您对它们是如何工作的感兴趣的话，可以在<a href="https://istio.io/latest/zh/docs/ops/deployment/architecture/">架构概述</a>中找到关于 <code>Istio</code> 的流量管理实现的更多信息。本部分只介绍 <code>Istio</code> 的流量管理特性。</p><h1 id="流量管理介绍"><a href="#流量管理介绍" class="headerlink" title="流量管理介绍"></a>流量管理介绍</h1><p>为了在网格中导流，<code>Istio</code> 需要知道所有的 <code>endpoint</code> 在哪和属于哪个服务。为了定位到<code>service registry</code>(服务注册中心)，<code>Istio</code> 会连接到一个服务发现系统。例如，如果您在 <code>Kubernetes</code> 集群上安装了 <code>Istio</code>，那么它将自动检测该集群中的服务和 <code>endpoint</code>。</p><p>使用此服务注册中心，<code>Envoy</code> 代理可以将流量定向到相关服务。大多数基于微服务的应用程序，每个服务的工作负载都有多个实例来处理流量，称为负载均衡池。默认情况下，<code>Envoy</code> 代理基于轮询调度模型在服务的负载均衡池内分发流量，按顺序将请求发送给池中每个成员，一旦所有服务实例均接收过一次请求后，重新回到第一个池成员。</p><p><code>Istio</code> 基本的服务发现和负载均衡能力为您提供了一个可用的服务网格，但它能做到的远比这多的多。在许多情况下，您可能希望对网格的流量情况进行更细粒度的控制。作为 <code>A/B</code> 测试的一部分，您可能想将特定百分比的流量定向到新版本的服务，或者为特定的服务实例子集应用不同的负载均衡策略。您可能还想对进出网格的流量应用特殊的规则，或者<strong>将网格的外部依赖项添加到服务注册中心</strong>。通过使用 <code>Istio</code> 的流量管理 <code>API</code> 将流量配置添加到 <code>Istio</code>，就可以完成所有这些甚至更多的工作。</p><p>和其他 <code>Istio</code> 配置一样，这些 <code>API</code> 也使用 <code>Kubernetes</code> 的自定义资源定义（<code>CRDs</code>）来声明，您可以像示例中看到的那样使用 <code>YAML</code> 进行配置。</p><p>本章节的其余部分将分别介绍每个流量管理 API 以及如何使用它们。这些资源包括：</p><ul><li>虚拟服务</li><li>目标规则</li><li>网关</li><li>服务入口</li><li><code>Sidecar</code></li></ul><h1 id="虚拟服务"><a href="#虚拟服务" class="headerlink" title="虚拟服务"></a>虚拟服务</h1><p>虚拟服务（<code>Virtual Service</code>） 和目标规则（<code>Destination Rule</code>） 是 <code>Istio</code> 流量路由功能的关键拼图。虚拟服务让您配置如何在服务网格内将请求路由到服务，这基于 <code>Istio</code> 和平台提供的基本的连通性和服务发现能力。每个虚拟服务包含一组路由规则，<code>Istio</code> 按顺序评估它们，<code>Istio</code> 将每个给定的请求匹配到虚拟服务指定的实际目标地址。您的网格可以有多个虚拟服务，也可以没有，取决于您的使用场景。</p><h2 id="为什么使用虚拟服务？"><a href="#为什么使用虚拟服务？" class="headerlink" title="为什么使用虚拟服务？"></a>为什么使用虚拟服务？</h2><p>虚拟服务在增强 <code>Istio</code> 流量管理的灵活性和有效性方面，发挥着至关重要的作用，通过对客户端请求的目标地址与真实响应请求的目标工作负载进行解耦来实现。虚拟服务同时提供了丰富的方式，为发送至这些工作负载的流量指定不同的路由规则。</p><p>为什么这如此有用？就像在介绍中所说，如果没有虚拟服务，<code>Envoy</code> 会在所有的服务实例中使用轮询的负载均衡策略分发请求。您可以用您对工作负载的了解来改善这种行为。例如，有些可能代表不同的版本。这在 <code>A/B</code> 测试中可能有用，您可能希望在其中配置基于不同服务版本的流量百分比路由，或指引从内部用户到特定实例集的流量。</p><p>使用虚拟服务，您可以为一个或多个主机名指定流量行为。在虚拟服务中使用路由规则，告诉 <code>Envoy</code> 如何发送虚拟服务的流量到适当的目标。路由目标地址可以是同一服务的不同版本，也可以是完全不同的服务。</p><p>一个典型的用例是将流量发送到被指定为服务子集的服务的不同版本。客户端将虚拟服务视为一个单一实体，将请求发送至虚拟服务主机，然后 <code>Envoy</code> 根据虚拟服务规则把流量路由到不同的版本。例如，“20% 的调用转到新版本”或“将这些用户的调用转到版本 2”。这允许您创建一个金丝雀发布，逐步增加发送到新版本服务的流量百分比。流量路由完全独立于实例部署，这意味着实现新版本服务的实例可以根据流量的负载来伸缩，完全不影响流量路由。相比之下，像 <code>Kubernetes</code> 这样的容器编排平台只支持基于实例缩放的流量分发，这会让情况变得复杂。您可以在使用 <a href="https://istio.io/latest/zh/blog/2017/0.1-canary/">Istio 进行金丝雀部署</a>的文章里阅读到更多用虚拟服务实现金丝雀部署的内容。</p><p>虚拟服务可以让您：</p><ul><li>通过单个虚拟服务处理多个应用程序服务。如果您的网格使用 <code>Kubernetes</code>，可以配置一个虚拟服务处理特定命名空间中的所有服务。映射单一的虚拟服务到多个“真实”服务特别有用，可以在不需要客户适应转换的情况下，将单体应用转换为微服务构建的复合应用系统。您的路由规则可以指定为“对这些 <code>monolith.com</code> 的 <code>URI</code> 调用转到<code>microservice A</code>”等等。您可以在<a href="##%E8%99%9A%E6%8B%9F%E6%9C%8D%E5%8A%A1%E7%A4%BA%E4%BE%8B">下面的一个示例</a>看到它是如何工作的。</li><li>和<a href="##%E7%BD%91%E5%85%B3">网关</a>整合并配置流量规则来控制出入流量。</li></ul><p>在某些情况下，您还需要配置目标规则来使用这些特性，因为这是指定服务子集的地方。在一个单独的对象中指定服务子集和其它特定目标策略，有利于在虚拟服务之间更简洁地重用这些规则。在下一章节您可以找到更多关于目标规则的内容。</p><h2 id="虚拟服务示例"><a href="#虚拟服务示例" class="headerlink" title="虚拟服务示例"></a>虚拟服务示例</h2><p>下面的虚拟服务根据请求是否来自特定的用户，把它们路由到服务的不同版本。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">end-user:</span></span><br><span class="line">          <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><h3 id="hosts字段"><a href="#hosts字段" class="headerlink" title="hosts字段"></a><code>hosts</code>字段</h3><p>使用 <code>hosts</code> 字段列举虚拟服务的主机——即用户指定的目标或是路由规则设定的目标。这是客户端向服务发送请求时使用的一个或多个地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hosts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">reviews</span></span><br></pre></td></tr></table></figure><p>虚拟服务主机名可以是 <code>IP</code> 地址、<code>DNS</code> 名称，或者依赖于平台的一个简称（例如 <code>Kubernetes</code> 服务的短名称），隐式或显式地指向一个完全限定域名（<code>FQDN</code>）。您也可以使用通配符（“*”）前缀，让您创建一组匹配所有服务的路由规则。虚拟服务的 <code>hosts</code> 字段实际上不必是 <code>Istio</code> 服务注册的一部分，它只是虚拟的目标地址。这让您可以为没有路由到网格内部的虚拟主机建模。</p><h3 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a><code>路由规则</code></h3><p>在 <code>http</code> 字段包含了虚拟服务的路由规则，用来描述匹配条件和路由行为，它们把 <code>HTTP/1.1、HTTP2</code> 和 <code>gRPC</code> 等流量发送到 <code>hosts</code> 字段指定的目标（您也可以用 <code>tcp</code> 和 <code>tls</code> 片段为 <code>TCP</code> 和未终止的 <code>TLS</code> 流量设置路由规则）。一个路由规则包含了指定的请求要流向哪个目标地址，具有 0 或多个匹配条件，取决于您的使用场景。</p><h4 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h4><p>示例中的第一个路由规则有一个条件，因此以 <code>match</code> 字段开始。在本例中，您希望此路由应用于来自 ”jason“ 用户的所有请求，所以使用 <code>headers、end-user</code> 和 <code>exact</code> 字段选择适当的请求。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">       <span class="attr">end-user:</span></span><br><span class="line">         <span class="attr">exact:</span> <span class="string">jason</span></span><br></pre></td></tr></table></figure><h4 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a><code>Destination</code></h4><p><code>route</code> 部分的 <code>destination</code> 字段指定了符合此条件的流量的实际目标地址。与虚拟服务的 <code>hosts</code> 不同，<code>destination</code> 的 <code>host</code> 必须是存在于 <code>Istio</code> 服务注册中心的实际目标地址，否则 <code>Envoy</code> 不知道该将请求发送到哪里。可以是一个有代理的服务网格，或者是一个通过服务入口被添加进来的非网格服务。本示例运行在 <code>Kubernetes</code> 环境中，<code>host</code> 名为一个 <code>Kubernetes</code> 服务名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">    <span class="attr">subset:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure><p><em>请注意，在该示例和本页其它示例中，为了简单，我们使用 <code>Kubernetes</code> 的短名称设置 <code>destination</code> 的 <code>host</code>。在评估此规则时，<code>Istio</code> 会添加一个基于虚拟服务命名空间的域后缀，这个虚拟服务包含要获取主机的完全限定名的路由规则。在我们的示例中使用短名称也意味着您可以复制并在任何喜欢的命名空间中尝试它们。</em></p><blockquote><p><strong>只有在目标主机和虚拟服务位于相同的 <code>Kubernetes</code> 命名空间时才可以使用这样的短名称。因为使用 <code>Kubernetes</code> 的短名称容易导致配置出错，我们建议您在生产环境中指定完全限定的主机名。</strong></p></blockquote><p><code>destination</code> 片段还指定了 <code>Kubernetes</code> 服务的子集，将符合此规则条件的请求转入其中。在本例中子集名称是 <code>v2</code>。您可以在<a href="#%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%99">目标规则章节</a>中看到如何定义服务子集。</p><h3 id="路由规则优先级"><a href="#路由规则优先级" class="headerlink" title="路由规则优先级"></a>路由规则优先级</h3><p>路由规则按从上到下的顺序选择，虚拟服务中定义的第一条规则有最高优先级。本示例中，不满足第一个路由规则的流量均流向一个默认的目标，该目标在第二条规则中指定。因此，第二条规则没有 <code>match</code> 条件，直接将流量导向 <code>v3</code> 子集。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>我们建议提供一个默认的“无条件”或基于权重的规则（见下文）作为每一个虚拟服务的最后一条规则，如案例所示，从而确保流经虚拟服务的流量至少能够匹配一条路由规则。</p><h2 id="路由规则的更多内容"><a href="#路由规则的更多内容" class="headerlink" title="路由规则的更多内容"></a>路由规则的更多内容</h2><p>正如上面所看到的，路由规则是将特定流量子集路由到指定目标地址的强大工具。您可以在流量端口、<code>header</code> 字段、<code>URI</code> 等内容上设置匹配条件。例如，这个虚拟服务让用户发送请求到两个独立的服务：<code>ratings</code> 和 <code>reviews</code>，就好像它们是 <code>http://bookinfo.com/</code> 这个更大的虚拟服务的一部分。虚拟服务规则根据请求的 URI 和指向适当服务的请求匹配流量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bookinfo.com</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/reviews</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/ratings</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="attr">sourceLabels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">reviews</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>有些匹配条件可以使用精确的值，如前缀或正则。</p><p>您可以使用 <code>AND</code> 向同一个 <code>match</code> 块添加多个匹配条件，或者使用 <code>OR</code> 向同一个规则添加多个 <code>match</code> 块。对于任何给定的虚拟服务也可以有多个路由规则。这可以在单个虚拟服务中使路由条件变得随您所愿的复杂或简单。匹配条件字段和备选值的完整列表可以在 <a href="https://istio.io/latest/zh/docs/reference/config/networking/virtual-service/#HTTPMatchRequest"><code>HTTPMatchRequest</code> 参考</a>中找到。</p><p>另外，使用匹配条件您可以按百分比”权重“分发请求。这在 <code>A/B</code> 测试和金丝雀发布中非常有用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">75</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>您也可以使用路由规则在流量上执行一些操作，例如：</p><ul><li>添加或删除 <code>header</code>。</li><li>重写 <code>URL</code>。</li><li>调用这一目标地址的请求设置<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/#retries">重试策略</a>。<br>想了解如何利用这些操作，查看 <a href="https://istio.io/latest/zh/docs/reference/config/networking/virtual-service/#HTTPRoute"><code>HTTPRoute</code> 参考</a>。</li></ul><h1 id="目标规则"><a href="#目标规则" class="headerlink" title="目标规则"></a>目标规则</h1><p>与虚拟服务一样，目标规则也是 <code>Istio</code> 流量路由功能的关键部分。您可以将虚拟服务视为将流量如何路由到给定目标地址，然后使用目标规则来配置该目标的流量。在评估虚拟服务路由规则之后，目标规则将应用于流量的“真实”目标地址。</p><p>特别是，您可以使用目标规则来指定命名的服务子集，例如按版本为所有给定服务的实例分组。然后可以在虚拟服务的路由规则中使用这些服务子集来控制到服务不同实例的流量。</p><p>目标规则还允许您在调用整个目的地服务或特定服务子集时定制 Envoy 的流量策略，比如您喜欢的负载均衡模型、TLS 安全模式或熔断器设置。在<a href="https://istio.io/latest/zh/docs/reference/config/networking/destination-rule/">目标规则参考</a>中可以看到目标规则选项的完整列表。</p><h2 id="负载均衡选项"><a href="#负载均衡选项" class="headerlink" title="负载均衡选项"></a>负载均衡选项</h2><p>默认情况下，<code>Istio</code> 使用轮询的负载均衡策略，实例池中的每个实例依次获取请求。<code>Istio</code> 同时支持如下的负载均衡模型，可以在 <code>DestinationRule</code> 中为流向某个特定服务或服务子集的流量指定这些模型。</p><ul><li>随机：请求以随机的方式转到池中的实例。</li><li>权重：请求根据指定的百分比转到实例。</li><li>最少请求：请求被转到最少被访问的实例。</li></ul><p>查看 <a href="https://www.envoyproxy.io/docs/envoy/v1.5.0/intro/arch_overview/load_balancing"><code>Envoy</code> 负载均衡文档</a>获取这部分的更多信息。</p><h2 id="目标规则示例"><a href="#目标规则示例" class="headerlink" title="目标规则示例"></a>目标规则示例</h2><p>在下面的示例中，目标规则为 <code>my-svc</code> 目标服务配置了 3 个具有不同负载均衡策略的子集：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-destination-rule</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">my-svc</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span></span><br><span class="line">    <span class="attr">loadBalancer:</span></span><br><span class="line">      <span class="attr">simple:</span> <span class="string">RANDOM</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v3</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>每个子集都是基于一个或多个 <code>labels</code> 定义的，在 <code>Kubernetes</code> 中它是附加到像 <code>Pod</code> 这种对象上的键/值对。这些标签应用于 `Kubernetes 服务的 Deployment 并作为 metadata 来识别不同的版本。</p><p>除了定义子集之外，目标规则对于所有子集都有默认的流量策略，而对于该子集，则有特定于子集的策略覆盖它。定义在 <code>subsets</code> 上的默认策略，为 <code>v1</code> 和 <code>v3</code> 子集设置了一个简单的随机负载均衡器。在 <code>v2</code> 策略中，轮询负载均衡器被指定在相应的子集字段上。</p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>使用网关为网格来管理入站和出站流量，可以让您指定要进入或离开网格的流量。网关配置被用于运行在网格边界的独立 <code>Envoy</code> 代理，而不是服务工作负载的 <code>sidecar</code> 代理。</p><p>与 <code>Kubernetes Ingress API</code> 这种控制进入系统流量的其他机制不同，<code>Istio</code> 网关让您充分利用流量路由的强大能力和灵活性。您可以这么做的原因是 <code>Istio</code> 的网关资源可以配置 4-6 层的负载均衡属性，如对外暴露的端口、<code>TLS</code> 设置等。作为替代应用层流量路由（L7）到相同的 <code>API</code> 资源，您绑定了一个常规的 <code>Istio</code> 虚拟服务到网关。这让您可以像管理网格中其他数据平面的流量一样去管理网关流量。</p><p>网关主要用于管理进入的流量，但您也可以配置出口网关。出口网关让您为离开网格的流量配置一个专用的出口节点，这可以限制哪些服务可以或应该访问外部网络，或者启用<a href="https://istio.io/latest/zh/blog/2019/egress-traffic-control-in-istio-part-1/">出口流量安全控制</a>为您的网格添加安全性。您也可以使用网关配置一个纯粹的内部代理。</p><p><code>Istio</code> 提供了一些预先配置好的网关代理部署（<code>istio-ingressgateway</code> 和 <code>istio-egressgateway</code>）供您使用——如果使用我们的演示安装它们都已经部署好了；如果使用默认或 <code>sds</code> 配置文件则只部署了入口网关。可以将您自己的网关配置应用到这些部署或配置您自己的网关代理。</p><h2 id="Gateway示例"><a href="#Gateway示例" class="headerlink" title="Gateway示例"></a><code>Gateway</code>示例</h2><p>下面的示例展示了一个外部 <code>HTTPS</code> 入口流量的网关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ext-host-gwy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-gateway-controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">SIMPLE</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/tmp/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/tmp/tls.key</span></span><br></pre></td></tr></table></figure><p>这个网关配置让 <code>HTTPS</code> 流量从 <code>ext-host.example.com</code> 通过 443 端口流入网格，但没有为请求指定任何路由规则。为想要工作的网关指定路由，您必须把网关绑定到虚拟服务上。正如下面的示例所示，使用虚拟服务的 <code>gateways</code> 字段进行设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">virtual-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ext-host-gwy</span></span><br></pre></td></tr></table></figure><p>然后就可以为出口流量配置带有路由规则的虚拟服务。</p><h1 id="服务入口"><a href="#服务入口" class="headerlink" title="服务入口"></a>服务入口</h1><p>使用服务入口（<code>Service Entry</code>） 来添加一个入口到 <code>Istio</code> 内部维护的服务注册中心。添加了服务入口后，<code>Envoy</code> 代理可以向服务发送流量，就好像它是网格内部的服务一样。配置服务入口允许您管理运行在网格外的服务的流量，它包括以下几种能力：</p><ul><li>为外部目标 <code>redirect</code> 和转发请求，例如来自 <code>web</code> 端的 <code>API</code> 调用，或者流向遗留老系统的服务。</li><li>为外部目标定义重试、超时和故障注入策略。</li><li>添加一个运行在虚拟机的服务来扩展您的网格。</li><li>从逻辑上添加来自不同集群的服务到网格，在 <code>Kubernetes</code> 上实现一个多集群 <code>Istio</code> 网格。</li></ul><p><em>您不需要为网格服务要使用的每个外部服务都添加服务入口。默认情况下，Istio 配置 Envoy 代理将请求传递给未知服务。但是，您不能使用 Istio 的特性来控制没有在网格中注册的目标流量。</em></p><h2 id="服务入口示例"><a href="#服务入口示例" class="headerlink" title="服务入口示例"></a>服务入口示例</h2><p>下面示例的 <code>mesh-external</code> 服务入口将 <code>ext-resource</code> 外部依赖项添加到 <code>Istio</code> 的服务注册中心：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">svc-entry</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-svc.example.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br></pre></td></tr></table></figure><p>您指定的外部资源使用 <code>hosts</code> 字段。可以使用完全限定名或通配符作为前缀域名。</p><p>您可以配置虚拟服务和目标规则，以更细粒度的方式控制到服务入口的流量，这与网格中的任何其他服务配置流量的方式相同。例如，下面的目标规则配置流量路由以使用双向 <code>TLS</code> 来保护到 <code>ext-svc.example.com</code> 外部服务的连接，我们使用服务入口配置了该外部服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ext-res-dr</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">ext-svc.example.com</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">MUTUAL</span></span><br><span class="line">      <span class="attr">clientCertificate:</span> <span class="string">/etc/certs/myclientcert.pem</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/etc/certs/client_private_key.pem</span></span><br><span class="line">      <span class="attr">caCertificates:</span> <span class="string">/etc/certs/rootcacerts.pem</span></span><br></pre></td></tr></table></figure><p>查看<a href="https://istio.io/latest/zh/docs/reference/config/networking/service-entry">服务入口参考</a>获取更多可能的配置项。</p><h1 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h1><p>默认情况下，<code>Istio</code> 让每个 <code>Envoy</code> 代理都可以访问来自和它关联的工作负载的所有端口的请求，然后转发到对应的工作负载。您可以使用 <code>sidecar</code> 配置去做下面的事情：</p><ul><li>微调 <code>Envoy</code> 代理接受的端口和协议集。</li><li>限制 <code>Envoy</code> 代理可以访问的服务集合。</li></ul><p>您可能希望在较庞大的应用程序中限制这样的 sidecar 可达性，配置每个代理能访问网格中的任意服务可能会因为高内存使用量而影响网格的性能。</p><p>您可以指定将 <code>sidecar</code> 配置应用于特定命名空间中的所有工作负载，或者使用 <code>workloadSelector</code> 选择特定的工作负载。例如，下面的 <code>sidecar</code> 配置将 <code>bookinfo</code> 命名空间中的所有服务配置为仅能访问运行在相同命名空间和 <code>Istio</code> 控制平面中的服务（目前需要使用 <code>Istio</code> 的策略和遥测功能）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Sidecar</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;./*&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;istio-system/*&quot;</span></span><br></pre></td></tr></table></figure><p>查阅 <a href="https://istio.io/latest/zh/docs/reference/config/networking/sidecar/">Sidecar 参考</a>获取详细信息。</p><h1 id="网络弹性和测试"><a href="#网络弹性和测试" class="headerlink" title="网络弹性和测试"></a>网络弹性和测试</h1><p>除了为您的网格导流之外，<code>Istio</code> 还提供了可选的故障恢复和故障注入功能，您可以在运行时动态配置这些功能。使用这些特性可以让您的应用程序运行稳定，确保服务网格能够容忍故障节点，并防止局部故障级联影响到其他节点。</p><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>超时是 <code>Envoy</code> 代理等待来自给定服务的答复的时间量，以确保服务不会因为等待答复而无限期的挂起，并在可预测的时间范围内调用成功或失败。<code>HTTP</code> 请求的默认超时时间是 15 秒，这意味着如果服务在 15 秒内没有响应，调用将失败。</p><p>对于某些应用程序和服务，<code>Istio</code> 的缺省超时可能不合适。例如，超时太长可能会由于等待失败服务的回复而导致过度的延迟；而超时过短则可能在等待涉及多个服务返回的操作时触发不必要地失败。为了找到并使用最佳超时设置，<code>Istio</code> 允许您使用虚拟服务按服务轻松地动态调整超时，而不必修改您的业务代码。下面的示例是一个虚拟服务，它对 <code>ratings</code> 服务的 <code>v1</code> 子集的调用指定 10 秒超时：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>重试设置指定如果初始调用失败，<code>Envoy</code> 代理尝试连接服务的最大次数。通过确保调用不会因为临时过载的服务或网络等问题而永久失败，重试可以提高服务可用性和应用程序的性能。重试之间的间隔（25ms+）是可变的，并由 <code>Istio</code> 自动确定，从而防止被调用服务被请求淹没。<code>HTTP</code> 请求的默认重试行为是在返回错误之前重试两次。</p><p>与超时一样，<code>Istio</code> 默认的重试行为在延迟方面可能不适合您的应用程序需求（对失败的服务进行过多的重试会降低速度）或可用性。您可以在虚拟服务中按服务调整重试设置，而不必修改业务代码。您还可以通过添加每次重试的超时来进一步细化重试行为，并指定每次重试都试图成功连接到服务所等待的时间量。下面的示例配置了在初始调用失败后最多重试 3 次来连接到服务子集，每个重试都有 2 秒的超时。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">retries:</span></span><br><span class="line">      <span class="attr">attempts:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">perTryTimeout:</span> <span class="string">2s</span></span><br></pre></td></tr></table></figure><h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><p>熔断器是 <code>Istio</code> 为创建具有弹性的微服务应用提供的另一个有用的机制。在熔断器中，设置一个对服务中的单个主机调用的限制，例如并发连接的数量或对该主机调用失败的次数。一旦限制被触发，熔断器就会“跳闸”并停止连接到该主机。使用熔断模式可以快速失败而不必让客户端尝试连接到过载或有故障的主机。</p><p>熔断适用于在负载均衡池中的“真实”网格目标地址，您可以在目标规则中配置熔断器阈值，让配置适用于服务中的每个主机。下面的示例将 <code>v1</code> 子集的<code>reviews</code>服务工作负载的并发连接数限制为 100：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">connectionPool:</span></span><br><span class="line">        <span class="attr">tcp:</span></span><br><span class="line">          <span class="attr">maxConnections:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>您可以在<a href="https://istio.io/latest/zh/docs/tasks/traffic-management/circuit-breaking/">熔断</a>中查看更多相关信息。</p><h2 id="故障注入"><a href="#故障注入" class="headerlink" title="故障注入"></a>故障注入</h2><p>在配置了网络，包括故障恢复策略之后，可以使用 <code>Istio</code> 的故障注入机制来为整个应用程序测试故障恢复能力。故障注入是一种将错误引入系统以确保系统能够承受并从错误条件中恢复的测试方法。使用故障注入特别有用，能确保故障恢复策略不至于不兼容或者太严格，这会导致关键服务不可用。</p><p>与其他错误注入机制（如延迟数据包或在网络层杀掉 <code>Pod</code> 不同，<code>Istio</code> 允许在应用层注入错误。这使您可以注入更多相关的故障，例如 <code>HTTP</code> 错误码，以获得更多相关的结果。</p><p>您可以注入两种故障，它们都使用虚拟服务配置：</p><ul><li><p>延迟：延迟是时间故障。它们模拟增加的网络延迟或一个超载的上游服务。</p></li><li><p>终止：终止是崩溃失败。他们模仿上游服务的失败。终止通常以 HTTP 错误码或 TCP 连接失败的形式出现。</p></li></ul><p>例如，下面的虚拟服务为千分之一的访问 <code>ratings</code> 服务的请求配置了一个 5 秒的延迟：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure><p>有关如何配置延迟和终止的详细信息请参考<a href="https://istio.io/latest/zh/docs/tasks/traffic-management/fault-injection/">故障注入</a>。</p><h2 id="和您的应用程序一起运行"><a href="#和您的应用程序一起运行" class="headerlink" title="和您的应用程序一起运行"></a>和您的应用程序一起运行</h2><p><code>Istio</code> 故障恢复功能对应用程序来说是完全透明的。在返回响应之前，应用程序不知道 <code>Envoy sidecar</code> 代理是否正在处理被调用服务的故障。这意味着，如果在应用程序代码中设置了故障恢复策略，那么您需要记住这两个策略都是独立工作的，否则会发生冲突。例如，假设您设置了两个超时，一个在虚拟服务中配置，另一个在应用程序中配置。应用程序为服务的 <code>API</code> 调用设置了 2 秒超时。而您在虚拟服务中配置了一个 3 秒超时和重试。在这种情况下，应用程序的超时会先生效，因此 <code>Envoy</code> 的超时和重试尝试会失效。</p><p>虽然 <code>Istio</code> 故障恢复特性提高了网格中服务的可靠性和可用性，但应用程序必须处理故障或错误并采取适当的回退操作。例如，当负载均衡中的所有实例都失败时，<code>Envoy</code> 返回一个<code>HTTP</code> 503代码。应用程序必须实现回退逻辑来处理<code>HTTP</code> 503错误代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自&lt;a href=&quot;https://istio.io/latest/zh/docs/concepts/traffic-management/&quot;&gt;istio文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;流量管理&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="文档" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%96%87%E6%A1%A3/"/>
    
    <category term="istio" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%96%87%E6%A1%A3/istio/"/>
    
    
    <category term="kubernetes - istio - 文档" scheme="http://kiragoo.github.com/tags/kubernetes-istio-%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
</feed>
