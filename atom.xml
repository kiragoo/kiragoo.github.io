<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kirago杂谈</title>
  
  
  <link href="http://kiragoo.github.com/atom.xml" rel="self"/>
  
  <link href="http://kiragoo.github.com/"/>
  <updated>2022-04-21T12:56:45.867Z</updated>
  <id>http://kiragoo.github.com/</id>
  
  <author>
    <name>kirago</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用 nektos/act debug github action locally</title>
    <link href="http://kiragoo.github.com/archives/7c305169.html"/>
    <id>http://kiragoo.github.com/archives/7c305169.html</id>
    <published>2022-04-06T14:35:37.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道利用 <code>Github Action</code> 可以用来进行构建<code>CI</code>的流水线，通过构建对应的<code>jobs</code>来实现我们的期望效果，对于目前来说很多时候构建之后的效果目前只能在远端<code>repo</code>才能够看到最终的执行结果，那么我们是否有机会能够在本地构建，然后来类似<code>DEBUG</code>看到最后期望呢？这里我将介绍如何利用<code>nektos/act</code>这一利器来本地执行 <code>Github Action</code>。</p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>根据官方仓库的概览描述告诉了我们对于本地构建的急切缘由！</p><ul><li>及时的结果反馈。 通过本地构建我们无需通过 <code>commit/push</code> 的事件来触发远端<code>repo</code>的<code>action</code>。我们完全可以在本地进行模拟<code>Github Actions</code>所达到的效果，从而得到一个及时的结果信息反馈。</li><li>我们完全可以通过流式线形式的构建来替换 <code>Makefile</code> 文件</li></ul><h1 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h1><p>这里假设你已经具备基本的<code>Github Action</code>配置能力，且具备初步的使用能力，此篇章主要是对 <code>act</code> 的配置及使用。<br>安装完可以通过 <code>act -h</code> 进行简单的查看验证。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/act-help.png" alt="act-help"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本人使用的是 <code>macos</code>，可以通过 <code>brew install act</code> 进行安装，其他 <code>os</code> 发行版可以参考官方仓库中的安装说明进行安装。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h3><p>在远端<code>Github  Action</code> 运行的时候实际上是提供了对应的 <code>vm</code> 资源进行构建，那么在本地的话，<code>act</code> 是提供一个虚机镜像在容器层面进行 <code>os</code> 的模拟，我这里使用的是默认的 <code>platform/docker-image</code>，当然也可以自定定义。执行的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">act -P &lt;platform&gt;&#x3D;&lt;docker-image&gt;</span><br></pre></td></tr></table></figure><p>如下是我本地的镜像:<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/act-image.png" alt="act-image"></p><h3 id="环境变量及密钥配置"><a href="#环境变量及密钥配置" class="headerlink" title="环境变量及密钥配置"></a>环境变量及密钥配置</h3><p>很多时候在公司内部我们使用的更多的是私有仓库，那么我们在项目工程容器化的时候会拉依赖涉及到私有仓库，在 <code>github</code> 上我们会配置对应的 <code>Action-&gt;secrets</code>，在远端运行<code>github action</code>的时候是有机会获取到的，但是在本地的话我们如何传递呢？</p><p><code>act</code> 支持 <code>secrets</code> 的配置，可以通过命令参数直接传递也可以通过在本地写入配置文件进行配置。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/act-secrets.png" alt="act-secrets"></p>]]></content>
    
    
    <summary type="html">利用 nektos/act 本地执行 github action</summary>
    
    
    
    <category term="devops" scheme="http://kiragoo.github.com/categories/devops/"/>
    
    
    <category term="github action" scheme="http://kiragoo.github.com/tags/github-action/"/>
    
    <category term="act" scheme="http://kiragoo.github.com/tags/act/"/>
    
  </entry>
  
  <entry>
    <title>手撕client-go:如何编写CRD client</title>
    <link href="http://kiragoo.github.com/archives/ba22a6bc.html"/>
    <id>http://kiragoo.github.com/archives/ba22a6bc.html</id>
    <published>2021-12-24T12:46:08.000Z</published>
    <updated>2022-04-21T12:46:07.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求背景分析"><a href="#需求背景分析" class="headerlink" title="需求背景分析"></a>需求背景分析</h2><p>基于 <code>k8s</code> 的二次开发过程中，有些场景我们会定制化的去开发自己的 <code>CRD</code> + <code>Controller</code>，即 <code>Operator</code>来实现基于<code>k8s</code>的云原生化的部署与自动化运维功能，暂且称之为<strong>底层的基座能力</strong>。</p><p>如果我们想基于底层能力，并想要将其封装为控制台来供上层业务调用的话，我们需要有机会能够去控制与使用这样的接口能力，基于对<code>Client-go</code>的使用，也许有胖友会想到<code>dynamic client</code>的使用，但是作为设计与开发人员，我们应该清醒的认识到对于序列化与反序列化过程，扔一堆<code>map</code>是多么的头疼（除非恰巧业务开发人员与<code>Operator</code>设计设计者是同一人&gt;..&lt;）。</p><p>我们能不能有机会像使用<code>k8s</code> 中的原生资源如<code>Deployments</code>、<code>Service</code>等一样方便的去使用呢？</p><h2 id="必备概念与技能"><a href="#必备概念与技能" class="headerlink" title="必备概念与技能"></a>必备概念与技能</h2><p>在进行具体分析前，建议胖友先去了解下<a href="https://kubernetes.io/zh/docs/reference/using-api/api-concepts/"><code>Kubernetes API</code> 概念</a>，同时具备查阅<a href="https://v1-21.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/"><code>Kubernetes API</code></a>的能力。</p><p>为了方便举例，我在本地<code>k8s</code>集群注册了<a href="https://github.com/emqx/emqx-operator"><code>emqx-operator</code></a> 中的 <code>CRD</code>自定义资源，将其视为与 <code>k8s</code> 原生资源同等地位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">emqxbrokers.apps.emqx.io                    2021-12-09T03:59:28Z</span><br><span class="line">emqxenterprises.apps.emqx.io                2021-12-09T03:59:28Z</span><br></pre></td></tr></table></figure><p>另外可以通过<code>kubectl api-version</code>查看其<code>API</code>相关信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> api-versions | grep emqx</span><br><span class="line">apps.emqx.io/v1beta1</span><br></pre></td></tr></table></figure><p>通过 <code>kubectl api-resoures</code> 查看相关 <code>Group</code>,<code>Version</code>,<code>Kind</code>信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> api-resources              </span><br><span class="line">NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND</span><br><span class="line">emqxbrokers                       emqx         apps.emqx.io/v1beta1                   <span class="literal">true</span>         EmqxBroker</span><br><span class="line">emqxenterprises                   emqx-ee      apps.emqx.io/v1beta1                   <span class="literal">true</span>         EmqxEnterprise</span><br></pre></td></tr></table></figure><p>相信胖友应该都掌握如上知识概念及具备如上的基础技能了。^.^</p><h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><p>关于 <code>client-go</code> 的官方文档描述还是蛮少的，作为设计与开发者，胖友们得具备源码分析能力。下面让我们切入<code>client-go</code> 官方 <code>Repo</code> 中。其中<code>examples</code>的<code>create-update-delete-deployment</code>的示例展示了如何使用<code>client-go</code>库来进行<code>rest</code>请求的方法。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> kubeconfig *<span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> home := homedir.HomeDir(); home != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">kubeconfig = flag.String(<span class="string">&quot;kubeconfig&quot;</span>, filepath.Join(home, <span class="string">&quot;.kube&quot;</span>, <span class="string">&quot;config&quot;</span>), <span class="string">&quot;(optional) absolute path to the kubeconfig file&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kubeconfig = flag.String(<span class="string">&quot;kubeconfig&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;absolute path to the kubeconfig file&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Config 的初始化</span></span><br><span class="line">config, err := clientcmd.BuildConfigFromFlags(<span class="string">&quot;&quot;</span>, *kubeconfig)</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// clientset 的构造</span></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 resource client 进行 resource 资源的操作</span></span><br><span class="line">deploymentsClient := clientset.AppsV1().Deployments(apiv1.NamespaceDefault)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Deployment</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Creating deployment...&quot;</span>)</span><br><span class="line">result, err := deploymentsClient.Create(context.TODO(), deployment, metav1.CreateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Created deployment %q.\n&quot;</span>, result.GetObjectMeta().GetName())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update Deployment</span></span><br><span class="line">prompt()</span><br><span class="line">fmt.Println(<span class="string">&quot;Updating deployment...&quot;</span>)</span><br><span class="line"><span class="comment">//    You have two options to Update() this Deployment:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    1. Modify the &quot;deployment&quot; variable and call: Update(deployment).</span></span><br><span class="line"><span class="comment">//       This works like the &quot;kubectl replace&quot; command and it overwrites/loses changes</span></span><br><span class="line"><span class="comment">//       made by other clients between you Create() and Update() the object.</span></span><br><span class="line"><span class="comment">//    2. Modify the &quot;result&quot; returned by Get() and retry Update(result) until</span></span><br><span class="line"><span class="comment">//       you no longer get a conflict error. This way, you can preserve changes made</span></span><br><span class="line"><span class="comment">//       by other clients between Create() and Update(). This is implemented below</span></span><br><span class="line"><span class="comment">// using the retry utility package included with client-go. (RECOMMENDED)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// More Info:</span></span><br><span class="line"><span class="comment">// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency</span></span><br><span class="line"></span><br><span class="line">retryErr := retry.RetryOnConflict(retry.DefaultRetry, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Retrieve the latest version of Deployment before attempting update</span></span><br><span class="line"><span class="comment">// RetryOnConflict uses exponential backoff to avoid exhausting the apiserver</span></span><br><span class="line">result, getErr := deploymentsClient.Get(context.TODO(), <span class="string">&quot;demo-deployment&quot;</span>, metav1.GetOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> getErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Failed to get latest version of Deployment: %v&quot;</span>, getErr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result.Spec.Replicas = int32Ptr(<span class="number">1</span>)                           <span class="comment">// reduce replica count</span></span><br><span class="line">result.Spec.Template.Spec.Containers[<span class="number">0</span>].Image = <span class="string">&quot;nginx:1.13&quot;</span> <span class="comment">// change nginx version</span></span><br><span class="line">_, updateErr := deploymentsClient.Update(context.TODO(), result, metav1.UpdateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">return</span> updateErr</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> retryErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;Update failed: %v&quot;</span>, retryErr))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Updated deployment...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// List Deployments</span></span><br><span class="line">    ...</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Listing deployments in namespace %q:\n&quot;</span>, apiv1.NamespaceDefault)</span><br><span class="line">list, err := deploymentsClient.List(context.TODO(), metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> list.Items &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot; * %s (%d replicas)\n&quot;</span>, d.Name, *d.Spec.Replicas)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete Deployment</span></span><br><span class="line">    ...</span><br><span class="line">fmt.Println(<span class="string">&quot;Deleting deployment...&quot;</span>)</span><br><span class="line">deletePolicy := metav1.DeletePropagationForeground</span><br><span class="line"><span class="keyword">if</span> err := deploymentsClient.Delete(context.TODO(), <span class="string">&quot;demo-deployment&quot;</span>, metav1.DeleteOptions&#123;</span><br><span class="line">PropagationPolicy: &amp;deletePolicy,</span><br><span class="line">&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Deleted deployment.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计的重点就在于如何设计与实现<code>CRD</code>对应的 <code>resource</code>的<code>clientset</code>。</p><h3 id="clientset-的设计"><a href="#clientset-的设计" class="headerlink" title="clientset 的设计"></a><code>clientset</code> 的设计</h3><p>通过源码我们发现实际上就是通过 <code>Config</code> 去构造 <code>rest http</code> 的客户端。</p><h4 id="NewForConfig"><a href="#NewForConfig" class="headerlink" title="NewForConfig"></a><code>NewForConfig</code></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewForConfig</span><span class="params">(c *rest.Config)</span> <span class="params">(*Clientset, error)</span></span> &#123;</span><br><span class="line">configShallowCopy := *c</span><br><span class="line"></span><br><span class="line"><span class="comment">// share the transport between all clients</span></span><br><span class="line">httpClient, err := rest.HTTPClientFor(&amp;configShallowCopy)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Clientset"><a href="#Clientset" class="headerlink" title="Clientset"></a><code>Clientset</code></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">Discovery() discovery.DiscoveryInterface</span><br><span class="line">    ...</span><br><span class="line">    AppsV1() appsv1.AppsV1Interface <span class="comment">// Deployment 资源调用接口</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Clientset <span class="keyword">struct</span> &#123;</span><br><span class="line">    *discovery.DiscoveryClient</span><br><span class="line">    ...</span><br><span class="line">    appsV1                       *appsv1.AppsV1Client</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里我们发现 <code>Clientset</code> 就是对 <code>AppSV1</code> 下具体资源比如<code>Deployment</code>的抽象，对外暴露引用，我们最终需要的也是提供这样的一个抽象层面。</p><p>实际上<code>AppsV1</code> 也是一个维度的抽象，让我们继续往下看:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppsV1Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">RESTClient() rest.Interface</span><br><span class="line">    ...</span><br><span class="line">DeploymentsGetter</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AppsV1Client is used to interact with features provided by the apps group.</span></span><br><span class="line"><span class="keyword">type</span> AppsV1Client <span class="keyword">struct</span> &#123;</span><br><span class="line">restClient rest.Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AppsV1Client)</span> <span class="title">Deployments</span><span class="params">(namespace <span class="keyword">string</span>)</span> <span class="title">DeploymentInterface</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> newDeployments(c, namespace)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewForConfig</span><span class="params">(c *rest.Config)</span> <span class="params">(*AppsV1Client, error)</span></span> &#123;</span><br><span class="line">config := *c</span><br><span class="line">    <span class="comment">// 需要重点留意 setConfigDefaults(&amp;config)</span></span><br><span class="line"><span class="keyword">if</span> err := setConfigDefaults(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">httpClient, err := rest.HTTPClientFor(&amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NewForConfigAndClient(&amp;config, httpClient)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewForConfigAndClient</span><span class="params">(c *rest.Config, h *http.Client)</span> <span class="params">(*AppsV1Client, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> &amp;AppsV1Client&#123;client&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setConfigDefaults</span><span class="params">(config *rest.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需要重点留意 gv</span></span><br><span class="line">gv := v1.SchemeGroupVersion</span><br><span class="line">config.GroupVersion = &amp;gv</span><br><span class="line">config.APIPath = <span class="string">&quot;/apis&quot;</span></span><br><span class="line">config.NegotiatedSerializer = scheme.Codecs.WithoutConversion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.UserAgent == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">config.UserAgent = rest.DefaultKubernetesUserAgent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AppsV1Client)</span> <span class="title">RESTClient</span><span class="params">()</span> <span class="title">rest</span>.<span class="title">Interface</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.restClient</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信看到这里我们已经有了清晰的认识了，实际上这里就是去构造对应具体<code>Resource</code>的<code>rest client</code>。</p><p><code>Resource</code> 的<code>client</code> 大体构造我们是有了，那么客户端如何知道去请求啥<code>URL</code>的了？</p><p>这里考察我们对概念的理解与掌握，我们应该对<code>SchemeGroupVersion</code>这样的关键变量有敏锐的捕捉能力，我们去看看这个<code>SchemeGroupVersion</code>究竟是啥？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GroupName is the group name use in this package</span></span><br><span class="line"><span class="keyword">const</span> GroupName = <span class="string">&quot;apps&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SchemeGroupVersion is group version used to register these objects</span></span><br><span class="line"><span class="keyword">var</span> SchemeGroupVersion = schema.GroupVersion&#123;Group: GroupName, Version: <span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resource takes an unqualified resource and returns a Group qualified GroupResource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Resource</span><span class="params">(resource <span class="keyword">string</span>)</span> <span class="title">schema</span>.<span class="title">GroupResource</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> SchemeGroupVersion.WithResource(resource).GroupResource()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> move SchemeBuilder with zz_generated.deepcopy.go to k8s.io/api.</span></span><br><span class="line"><span class="comment">// localSchemeBuilder and AddToScheme will stay in k8s.io/kubernetes.</span></span><br><span class="line">SchemeBuilder      = runtime.NewSchemeBuilder(addKnownTypes)</span><br><span class="line">localSchemeBuilder = &amp;SchemeBuilder</span><br><span class="line">AddToScheme        = localSchemeBuilder.AddToScheme</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adds the list of known types to the given scheme.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKnownTypes</span><span class="params">(scheme *runtime.Scheme)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">scheme.AddKnownTypes(SchemeGroupVersion,</span><br><span class="line">&amp;Deployment&#123;&#125;,</span><br><span class="line">&amp;DeploymentList&#123;&#125;,</span><br><span class="line">&amp;StatefulSet&#123;&#125;,</span><br><span class="line">&amp;StatefulSetList&#123;&#125;,</span><br><span class="line">&amp;DaemonSet&#123;&#125;,</span><br><span class="line">&amp;DaemonSetList&#123;&#125;,</span><br><span class="line">&amp;ReplicaSet&#123;&#125;,</span><br><span class="line">&amp;ReplicaSetList&#123;&#125;,</span><br><span class="line">&amp;ControllerRevision&#123;&#125;,</span><br><span class="line">&amp;ControllerRevisionList&#123;&#125;,</span><br><span class="line">)</span><br><span class="line">metav1.AddToGroupVersion(scheme, SchemeGroupVersion)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信看到这里一切都柳暗花明了，其实就是告知<code>k8s</code> 我注册了这些<code>schema</code>，<code>k8s</code> 知道了这些<code>Resource</code>的存在，那么当我去请求的<code>Resouce</code>操作的时候能够按照我们的预期达到功能实现。</p><h3 id="CRD-关键实现"><a href="#CRD-关键实现" class="headerlink" title="CRD 关键实现"></a><code>CRD</code> 关键实现</h3><p>那么对于自定义的 <code>CRD</code> 实现肯定少不了如上分心的<code>setConfigDefaults</code>实现，如下为针对与<code>emqx-operator</code>实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">emqxbrokerGVR = schema.GroupVersion&#123;Group: <span class="string">&quot;apps.emqx.io&quot;</span>, Version: <span class="string">&quot;v1beta1&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setConfigDefaults</span><span class="params">(config *rest.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">gv := emqxbrokerGVR</span><br><span class="line">config.GroupVersion = &amp;gv</span><br><span class="line">config.APIPath = <span class="string">&quot;/apis&quot;</span></span><br><span class="line">config.NegotiatedSerializer = scheme.Codecs.WithoutConversion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.UserAgent == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">config.UserAgent = rest.DefaultKubernetesUserAgent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里对于<code>Client</code>的构造就算结束了，这其中的彩蛋还包括请求<code>API</code>的<code>URL</code>。</p><h3 id="CRD-资源操作具体实现"><a href="#CRD-资源操作具体实现" class="headerlink" title="CRD 资源操作具体实现"></a><code>CRD</code> 资源操作具体实现</h3><p>如上我们主要讲述了如何去构造<code>client</code>，那么对于<code>CRD</code>的具体操作我们是如何实现的呢？</p><p>这里让我们将注意力再返回到<code>AppsV1Interface</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppsV1Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">RESTClient() rest.Interface</span><br><span class="line">    ...</span><br><span class="line">DeploymentsGetter</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们看看<code>DeploymentGetter</code>究竟是啥。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">type</span> DeploymentsGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">Deployments(namespace <span class="keyword">string</span>) DeploymentInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeploymentInterface has methods to work with Deployment resources.</span></span><br><span class="line"><span class="keyword">type</span> DeploymentInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">Create(ctx context.Context, deployment *v1.Deployment, opts metav1.CreateOptions) (*v1.Deployment, error)</span><br><span class="line">Update(ctx context.Context, deployment *v1.Deployment, opts metav1.UpdateOptions) (*v1.Deployment, error)</span><br><span class="line">UpdateStatus(ctx context.Context, deployment *v1.Deployment, opts metav1.UpdateOptions) (*v1.Deployment, error)</span><br><span class="line">Delete(ctx context.Context, name <span class="keyword">string</span>, opts metav1.DeleteOptions) error</span><br><span class="line">DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error</span><br><span class="line">Get(ctx context.Context, name <span class="keyword">string</span>, opts metav1.GetOptions) (*v1.Deployment, error)</span><br><span class="line">List(ctx context.Context, opts metav1.ListOptions) (*v1.DeploymentList, error)</span><br><span class="line">Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error)</span><br><span class="line">Patch(ctx context.Context, name <span class="keyword">string</span>, pt types.PatchType, data []<span class="keyword">byte</span>, opts metav1.PatchOptions, subresources ...<span class="keyword">string</span>) (result *v1.Deployment, err error)</span><br><span class="line">Apply(ctx context.Context, deployment *appsv1.DeploymentApplyConfiguration, opts metav1.ApplyOptions) (result *v1.Deployment, err error)</span><br><span class="line">ApplyStatus(ctx context.Context, deployment *appsv1.DeploymentApplyConfiguration, opts metav1.ApplyOptions) (result *v1.Deployment, err error)</span><br><span class="line">GetScale(ctx context.Context, deploymentName <span class="keyword">string</span>, options metav1.GetOptions) (*autoscalingv1.Scale, error)</span><br><span class="line">UpdateScale(ctx context.Context, deploymentName <span class="keyword">string</span>, scale *autoscalingv1.Scale, opts metav1.UpdateOptions) (*autoscalingv1.Scale, error)</span><br><span class="line">ApplyScale(ctx context.Context, deploymentName <span class="keyword">string</span>, scale *applyconfigurationsautoscalingv1.ScaleApplyConfiguration, opts metav1.ApplyOptions) (*autoscalingv1.Scale, error)</span><br><span class="line"></span><br><span class="line">DeploymentExpansion</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看到这里实际上一切都已经明了，通过<code>Interface</code>抽象了对于<code>Deployment</code>的操作，具体的实现就不展开分析了。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>运行环境为通过<code>minikube</code>启动的本地<code>k8s</code>集群，另外在集群中注册<code>CRD</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> get crd | grep emqx </span><br><span class="line">emqxbrokers.apps.emqx.io                    2021-12-09T03:59:28Z</span><br><span class="line">emqxenterprises.apps.emqx.io                2021-12-09T03:59:28Z</span><br></pre></td></tr></table></figure><h3 id="验证CRD-Client"><a href="#验证CRD-Client" class="headerlink" title="验证CRD Client"></a>验证<code>CRD Client</code></h3><p>下面让我们验证下<code>Client</code>实际运行情况，验证对自定义的<code>CRD</code>实例的<code>Create</code>,<code>Get</code>,<code>List</code>,<code>Delete</code>的验证。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo 演示</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DemoForEmqxBroker</span><span class="params">(config *rest.Config, ns <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create emqxbroker restclient</span></span><br><span class="line">clientset, err := pkg.NewForConfig(config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emqxbrokerClient := clientset.EmqxBrokersV1Beta1().EmqxBrokers(ns)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create emqxbroker instance</span></span><br><span class="line">Prompt()</span><br><span class="line">fmt.Println(<span class="string">&quot;[&gt; create emqxbroker&quot;</span>)</span><br><span class="line">emqxbroker, err := emqxbrokerClient.Create(context.TODO(), resource.GenerateEmqxbroker(ns), metav1.CreateOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;create emqxbroker: %+v\n&quot;</span>, emqxbroker)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get emqxbroker instance</span></span><br><span class="line">Prompt()</span><br><span class="line">    fmt.Println(<span class="string">&quot;[&gt; get emqxbroker&quot;</span>)</span><br><span class="line">eb, err := emqxbrokerClient.Get(context.TODO(), <span class="string">&quot;emqx&quot;</span>, metav1.GetOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;emqxbroker found: %+v\n&quot;</span>, eb)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get emqxbroker list</span></span><br><span class="line">Prompt()</span><br><span class="line">    fmt.Println(<span class="string">&quot;[&gt; list emqxbroker&quot;</span>)</span><br><span class="line">eblist, err := emqxbrokerClient.List(context.TODO(), metav1.ListOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;emqxbroker list: %+v\n&quot;</span>, eblist)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete emqxbroker instance</span></span><br><span class="line">Prompt()</span><br><span class="line">    fmt.Println(<span class="string">&quot;[&gt; delete emqxbroker&quot;</span>)</span><br><span class="line">err = emqxbrokerClient.Delete(context.TODO(), <span class="string">&quot;emqx&quot;</span>, metav1.DeleteOptions&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Delete emqxbroker successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Create</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&gt; create emqxbroker</span><br><span class="line">create emqxbroker: EmqxBroker instance [emqx],Image [emqx/emqx:4.3.10]</span><br></pre></td></tr></table></figure><p>查看下<code>K8s</code>集群中实例的情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectl</span> get emqx emqx         </span><br><span class="line">NAME   AGE</span><br><span class="line">emqx   2m26s</span><br><span class="line"><span class="variable">$kubectl</span> get pods      </span><br><span class="line">NAME     READY   STATUS    RESTARTS   AGE</span><br><span class="line">emqx-0   1/1     Running   0          2m30s</span><br><span class="line">emqx-1   1/1     Running   0          2m30s</span><br><span class="line">emqx-2   1/1     Running   0          2m30s</span><br></pre></td></tr></table></figure><ul><li><code>Get</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&gt; get emqxbroker</span><br><span class="line">emqxbroker found: EmqxBroker instance [emqx],Image [emqx/emqx:4.3.10]</span><br></pre></td></tr></table></figure><ul><li><code>List</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&gt; list emqxbroker</span><br><span class="line">emqxbroker list: &amp;&#123;TypeMeta:&#123;Kind: APIVersion:&#125; ListMeta:&#123;SelfLink: ResourceVersion:157139 Continue: RemainingItemCount:&lt;nil&gt;&#125; Items:[&#123;TypeMeta:&#123;Kind:EmqxBroker APIVersion:apps.emqx.io/v1beta1&#125; ObjectMeta:&#123;Name:emqx GenerateName: Namespace:default SelfLink: UID:74896493-0134-460a-a04d-d3bdaed21902 ResourceVersion:157121 Generation:1 CreationTimestamp:2021-12-26 20:23:15 +0800 CST DeletionTimestamp:&lt;nil&gt; DeletionGracePeriodSeconds:&lt;nil&gt; Labels:map[] Annotations:map[] OwnerReferences:[] Finalizers:[] ClusterName: ManagedFields:[&#123;Manager:Go-http-client Operation:Update APIVersion:apps.emqx.io/v1beta1 Time:2021-12-26 20:23:15 +0800 CST FieldsType:FieldsV1 FieldsV1:&#123;<span class="string">&quot;f:spec&quot;</span>:&#123;<span class="string">&quot;.&quot;</span>:&#123;&#125;,<span class="string">&quot;f:image&quot;</span>:&#123;&#125;,<span class="string">&quot;f:labels&quot;</span>:&#123;<span class="string">&quot;.&quot;</span>:&#123;&#125;,<span class="string">&quot;f:cluster&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;f:listener&quot;</span>:&#123;<span class="string">&quot;.&quot;</span>:&#123;&#125;,<span class="string">&quot;f:nodePorts&quot;</span>:&#123;&#125;,<span class="string">&quot;f:ports&quot;</span>:&#123;&#125;&#125;,<span class="string">&quot;f:replicas&quot;</span>:&#123;&#125;,<span class="string">&quot;f:resources&quot;</span>:&#123;&#125;,<span class="string">&quot;f:serviceAccountName&quot;</span>:&#123;&#125;&#125;&#125; Subresource:&#125; &#123;Manager:__debug_bin4215542756 Operation:Update APIVersion:apps.emqx.io/v1beta1 Time:2021-12-26 20:23:15 +0800 CST FieldsType:FieldsV1 FieldsV1:&#123;<span class="string">&quot;f:status&quot;</span>:&#123;<span class="string">&quot;.&quot;</span>:&#123;&#125;,<span class="string">&quot;f:conditions&quot;</span>:&#123;&#125;&#125;&#125; Subresource:&#125;]&#125; Spec:&#123;Replicas:0xc000492ec8 Image:emqx/emqx:4.3.10 ServiceAccountName:emqx Resources:&#123;Limits:map[] Requests:map[]&#125; Storage:&lt;nil&gt; Labels:map[cluster:emqx] Listener:&#123;Type: LoadBalancerIP: LoadBalancerSourceRanges:[] ExternalIPs:[] Ports:&#123;MQTT:0 MQTTS:0 WS:0 WSS:0 Dashboard:0 API:0&#125; NodePorts:&#123;MQTT:0 MQTTS:0 WS:0 WSS:0 Dashboard:0 API:0&#125;&#125; Affinity:nil ToleRations:[] NodeSelector:map[] ImagePullPolicy: ExtraVolumes:[] ExtraVolumeMounts:[] Env:[] ACL:[] Plugins:[] Modules:[]&#125; Status:&#123;Conditions:[&#123;Type:Healthy Status:True LastUpdateTime:2021-12-26T20:27:26+08:00 LastUpdateAt:0001-01-01 00:00:00 +0000 UTC LastTransitionTime:2021-12-26T20:23:16+08:00 Reason:Cluster available Message:Cluster ok&#125; &#123;Type:Creating Status:True LastUpdateTime:2021-12-26T20:23:15+08:00 LastUpdateAt:0001-01-01 00:00:00 +0000 UTC LastTransitionTime:2021-12-26T20:23:15+08:00 Reason:Creating Message:Bootstrap emqx cluster&#125;]&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Delete</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&gt; delete emqxbroker</span><br><span class="line">Delete emqxbroker successfull</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求背景分析&quot;&gt;&lt;a href=&quot;#需求背景分析&quot; class=&quot;headerlink&quot; title=&quot;需求背景分析&quot;&gt;&lt;/a&gt;需求背景分析&lt;/h2&gt;&lt;p&gt;基于 &lt;code&gt;k8s&lt;/code&gt; 的二次开发过程中，有些场景我们会定制化的去开发自己的 &lt;code&gt;C</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="CRD" scheme="http://kiragoo.github.com/categories/kubernetes/CRD/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="client-go" scheme="http://kiragoo.github.com/tags/client-go/"/>
    
    <category term="设计" scheme="http://kiragoo.github.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>手撕kube-proxy iptables实例</title>
    <link href="http://kiragoo.github.com/archives/3562ba1.html"/>
    <id>http://kiragoo.github.com/archives/3562ba1.html</id>
    <published>2021-11-04T03:58:55.000Z</published>
    <updated>2022-04-21T12:46:07.735Z</updated>
    
    <content type="html"><![CDATA[<p>继 <a href="https://kiragoo.github.io/archives/26a027f0.html"><code>iptables</code> 入门出坑</a>之后，加深个人理解无非是实战，此篇我们来通过示例来加深个人理解。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本人是 <code>mbp</code>，由于 <code>Docker Desktop For Mac</code> 实在太黑盒了，打算用 <code>minikube</code> 来进行 <code>k8s</code> 实验环境的部署。</p><p>对于需要的 <code>minikube, kubectl</code> 这种基本依赖可执行文件具体就不写步骤了。<br>最终执行如下命令拉起 <code>k8s</code> 集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">minikube start --image-mirror-country=<span class="string">&#x27;cn&#x27;</span> --image-repository=<span class="string">&#x27;registry.cn-hangzhou.aliyuncs.com/google_containers&#x27;</span>  --kubernetes-version=v1.21.0</span><br><span class="line">😄  Darwin 11.6 上的 minikube v1.21.0</span><br><span class="line">❗  Kubernetes 1.21.0 has a known performance issue on cluster startup. It might take 2 to 3 minutes <span class="keyword">for</span> a cluster to start.</span><br><span class="line">❗  For more information, see: https://github.com/kubernetes/kubeadm/issues/2395</span><br><span class="line">🎉  minikube 1.23.2 is available! Download it: https://github.com/kubernetes/minikube/releases/tag/v1.23.2</span><br><span class="line">💡  To <span class="built_in">disable</span> this notice, run: <span class="string">&#x27;minikube config set WantUpdateNotification false&#x27;</span></span><br><span class="line"></span><br><span class="line">✨  根据现有的配置文件使用 docker 驱动程序</span><br><span class="line">👍  Starting control plane node minikube <span class="keyword">in</span> cluster minikube</span><br><span class="line">🚜  Pulling base image ...</span><br><span class="line">💾  Downloading Kubernetes v1.21.0 preload ...</span><br><span class="line">    &gt; preloaded-images-k8s-v11-v1...: 498.90 MiB / 498.90 MiB  100.00% 17.39 Mi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &gt; index.docker.io/kicbase/sta...: 359.09 MiB / 359.09 MiB  100.00% 4.53 MiB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">❗  minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.23, but successfully downloaded kicbase/stable:v0.0.23 as a fallback image</span><br><span class="line">🔥  Creating docker container (CPUs=2, Memory=4000MB) ...</span><br><span class="line">❗  This container is having trouble accessing https://k8s.gcr.io</span><br><span class="line">💡  To pull new external images, you may need to configure a proxy: https://minikube.sigs.k8s.io/docs/reference/networking/proxy/</span><br><span class="line">🐳  正在 Docker 20.10.7 中准备 Kubernetes v1.21.0…</span><br><span class="line">    ▪ Generating certificates and keys ...</span><br><span class="line">    ▪ Booting up control plane ...</span><br><span class="line">    ▪ Configuring RBAC rules ...</span><br><span class="line">🔎  Verifying Kubernetes components...</span><br><span class="line">    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5</span><br><span class="line">🌟  Enabled addons: storage-provisioner, default-storageclass</span><br><span class="line">🏄  Done! kubectl is now configured to use <span class="string">&quot;minikube&quot;</span> cluster and <span class="string">&quot;default&quot;</span> namespace by default</span><br></pre></td></tr></table></figure><p>构建实验 <code>manifests</code>，准备的<code>yaml</code> 文件如下：<br><strong>本例的<code>service type</code> 是 <code>ClusterIP</code></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web-server</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>待资源全部就绪后，查看资源详情，重点关注 <code>Pod</code> 和 <code>Service</code> 的 <code>IP</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl get all -o wide</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/nginx-deployment-74bc56fb4b-9xqkt   1/1     Running   0          4m23s   172.17.0.5   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/nginx-deployment-74bc56fb4b-c9zp4   1/1     Running   0          4m23s   172.17.0.4   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/nginx-deployment-74bc56fb4b-h7rhz   1/1     Running   0          4m23s   172.17.0.6   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod/web-server                          1/1     Running   0          4m23s   172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE     SELECTOR</span><br><span class="line">service/kubernetes      ClusterIP   10.96.0.1      &lt;none&gt;        443/TCP   3h22m   &lt;none&gt;</span><br><span class="line">service/nginx-service   ClusterIP   10.97.79.231   &lt;none&gt;        80/TCP    4m23s   app=nginx</span><br><span class="line"></span><br><span class="line">NAME                               READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS   IMAGES   SELECTOR</span><br><span class="line">deployment.apps/nginx-deployment   3/3     3            3           4m23s   nginx        nginx    app=nginx</span><br><span class="line"></span><br><span class="line">NAME                                          DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES   SELECTOR</span><br><span class="line">replicaset.apps/nginx-deployment-74bc56fb4b   3         3         3       4m23s   nginx        nginx    app=nginx,pod-template-hash=74bc56fb4b</span><br></pre></td></tr></table></figure><p>至此实验环境准备完成。</p><h2 id="流量转发分析"><a href="#流量转发分析" class="headerlink" title="流量转发分析"></a>流量转发分析</h2><p>首先需要登陆到 <code>minukube</code> 节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minikube ssh</span><br><span class="line">docker@minikube:~$ iptables</span><br><span class="line">iptables v1.8.4 (legacy): no <span class="built_in">command</span> specified</span><br><span class="line">Try `iptables -h<span class="string">&#x27; or &#x27;</span>iptables --<span class="built_in">help</span><span class="string">&#x27; for more information.</span></span><br><span class="line"><span class="string">docker@minikube:~$sudo su # 切换到root 用户</span></span><br></pre></td></tr></table></figure><h3 id="kube-proxy-iptable-模式分析之ClusterIP"><a href="#kube-proxy-iptable-模式分析之ClusterIP" class="headerlink" title="kube-proxy iptable 模式分析之ClusterIP"></a><code>kube-proxy iptable</code> 模式分析之<code>ClusterIP</code></h3><h4 id="流量的源与目的大概如下："><a href="#流量的源与目的大概如下：" class="headerlink" title="流量的源与目的大概如下："></a>流量的源与目的大概如下：</h4><pre class="mermaid">graph LR    web[web-server:172.17.0.3]-->nginx[nginx-service:10.97.79.231]</pre><blockquote><p>分析下为啥是从本机出去的流量？<br>因为<code>kube-proxy</code>是以<code>daemonSet</code>的形式部署在所有节点上的，所以每个节点都会有相同的<code>iptable</code>规则，当任何一个节点上的<code>pod</code>访问<code>service</code>时，其实都是可以在该<code>pod</code>所在的node的的<code>iptable</code>中找到对应的<code>service</code>规则从而找到<code>service</code>所代理的<code>pod</code>的，而对于<code>node</code>而言，寄宿在自己上的<code>pod</code>的发出的流量就是从本机的某进程出去的流量。</p></blockquote><p>在 <code>iptables</code> 的学习中可以知道，从本机出去的流量经过的链路流程如下：</p><pre class="mermaid">graph LR   output[OUTPUT链]-->postroting[POSTROUTING链]</pre><h4 id="OUTPUT-链分析"><a href="#OUTPUT-链分析" class="headerlink" title="OUTPUT 链分析"></a><code>OUTPUT</code> 链分析</h4><p><code>OUTPUT</code> 链涉及到4张表：<code>raw</code>，<code>mangle</code>，<code>nat</code>，<code>filter</code>。以下分析中会忽略与本例无关的 <code>rule</code>。<strong>重点看<code>nat</code>表和<code>filter</code>表，<code>raw</code>表和<code>mangle</code>表是空表</strong>。</p><h5 id="NAT-表"><a href="#NAT-表" class="headerlink" title="NAT 表"></a><code>NAT</code> 表</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -nvL</span><br><span class="line">...</span><br><span class="line">Chain OUTPUT (policy ACCEPT 819 packets, 49140 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">15746  946K KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */</span><br><span class="line">   72  4789 DOCKER_OUTPUT  all  --  *      *       0.0.0.0/0            192.168.65.2</span><br><span class="line">10852  651K DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，所有OUTPUT流量都被导向了名叫<code>KUBE-SERVICES</code>的自定义链，我们来看看它是做什么的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> ...</span><br><span class="line">    0     0 KUBE-MARK-MASQ  tcp  --  *      *      !10.244.0.0/16        10.97.79.231         /* default/nginx-service cluster IP */ tcp dpt:80</span><br><span class="line">    0     0 KUBE-SVC-V2OKYYMBY3REGZOG  tcp  --  *      *       0.0.0.0/0            10.97.79.231         /* default/nginx-service cluster IP */ tcp dpt:80</span><br><span class="line"> ...   </span><br><span class="line">    0     0 KUBE-SVC-TCOU7JCQXEZGVUNU  udp  --  *      *       0.0.0.0/0            10.96.0.10           /* kube-system/kube-dns:dns cluster IP */ udp dpt:53</span><br><span class="line">  719 43140 KUBE-NODEPORTS  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule <span class="keyword">in</span> this chain */ ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><p>可以看到这里定义了所有<code>namespace</code>的<code>service</code>相关的规则，其中就有我们创建的<code>nginx-service</code>规则（其他几条<code>service</code>与<code>kube-dns</code>和<code>apiServer</code>相关，大家感兴趣的话可以自己分析一下），可以看到它匹配的是目标地址为<code>10.97.79.231</code>，端口为<code>80</code>的数据包，而我们发往<code>nginx-service</code>的数据包正好匹配这条规则，我们看到这条规则的<code>target</code>是名叫<code>KUBE-SVC-V2OKYYMBY3REGZOG</code>的自定义链，我们来继续挖这个链：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SVC-V2OKYYMBY3REGZOG (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 KUBE-SEP-3VDHYO53IOQ2XWUD  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ statistic mode random probability 0.33333333349</span><br><span class="line">    0     0 KUBE-SEP-C54WIGIB4NQVIFB3  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ statistic mode random probability 0.50000000000</span><br><span class="line">    0     0 KUBE-SEP-KN3IA7DQGTHQJWSD  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */</span><br></pre></td></tr></table></figure><p>我们看到这个<code>KUBE-SVC-V2OKYYMBY3REGZOG</code>链里面定义了3条规则，第一条规则有<code>0.33333333349</code>的概率匹配，也就是<code>1/3</code>的概率命中，第一条没命中的话第二条规则有<code>1/2</code>的概率命中，也就是<code>2/3 * 1/2 = 1/3</code>，第二条没命中的话就去第3条了。很明显，这里是在做负载均衡，那我们可以猜到这3条规则后面的<code>target</code>就是这个<code>service</code>代理的3个<code>pod</code>相关的规则了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SEP-3VDHYO53IOQ2XWUD (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 KUBE-MARK-MASQ  all  --  *      *       172.17.0.4           0.0.0.0/0            /* default/nginx-service */</span><br><span class="line">    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ tcp to:172.17.0.4:80</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-C54WIGIB4NQVIFB3 (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 KUBE-MARK-MASQ  all  --  *      *       172.17.0.5           0.0.0.0/0            /* default/nginx-service */</span><br><span class="line">    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ tcp to:172.17.0.5:80</span><br><span class="line"></span><br><span class="line">Chain KUBE-SEP-KN3IA7DQGTHQJWSD (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 KUBE-MARK-MASQ  all  --  *      *       172.17.0.6           0.0.0.0/0            /* default/nginx-service */</span><br><span class="line">    0     0 DNAT       tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-service */ tcp to:172.17.0.6:80</span><br></pre></td></tr></table></figure><p>可以看到这3个自定义链的规则很类似，注意到第一条匹配的是是<code>Pod</code>自己访问自己的情况，会去<code>KUBE-MARK-MASQ</code>这个<code>target</code>，其他的情况会去第二条规则，也就是<code>DNAT</code>。在我们的假设中，是另外一个<code>pod</code>访问<code>nginx-service</code>，所以不会命中第一条，命中第二条<code>DNAT</code>。</p><p>假设我们的数据包在<code>KUBE-SVC-V2OKYYMBY3REGZOG</code>链中被负载均衡分配到了第一个<code>target</code>，也就是<code>KUBE-SEP-3VDHYO53IOQ2XWUD</code>，那么<code>DNAT</code>之后，该数据包的<code>destination</code>从<code>10.97.79.231:80</code>被改成了<code>172.17.0.4:80</code>，即：</p><pre class="mermaid">graph LR    orignal[orginal:172.17.0.3:xxx]-->dst1[10.97.79.231:80]    afterdnat[after dnat:172.17.0.3:xxx]-->dst2[172.17.0.4:80]</pre><p>至此，<code>nat</code> 表中 <code>OUTPUT</code> 链分析技术，进入<code>filter</code>表进行分析。</p><h5 id="filter-表"><a href="#filter-表" class="headerlink" title="filter 表"></a><code>filter</code> 表</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -nvL</span><br><span class="line">...</span><br><span class="line">Chain OUTPUT (policy ACCEPT 193K packets, 30M bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">17326 1040K KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            ctstate NEW /* kubernetes service portals */</span><br><span class="line">1379K  225M KUBE-FIREWALL  all  --  *      *       0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br></pre></td></tr></table></figure><p>可以看到所有所有的新的连接（ctstate NEW）都会匹配到第一条规则<code>KUBE-SERVICES</code>。但是我们会发现 <code>KUBE-SERVICES</code> 是一条空链，在此着重看第二条表<code>KUBE-FIREWALL</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-FIREWALL (2 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 DROP       all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes firewall <span class="keyword">for</span> dropping marked packets */ mark match 0x8000/0x8000</span><br><span class="line">    0     0 DROP       all  --  *      *      !127.0.0.0/8          127.0.0.0/8          /* block incoming localnet connections */ ! ctstate RELATED,ESTABLISHED,DNAT</span><br></pre></td></tr></table></figure><p>可以看到，所有被标记了<code>0x8000/0x8000</code>的数据包都会被直接<code>DROP</code>掉，而我们的数据包一路走过来没有被标记，所以不会被<code>DROP</code>。这样一来<code>filter</code>的<code>OUTPUT</code>规则也走完了，终于进入了下一个阶段 – <code>POSTROUTRING</code>链。</p><h5 id="POSTROUTING-链"><a href="#POSTROUTING-链" class="headerlink" title="POSTROUTING 链"></a><code>POSTROUTING</code> 链</h5><p><code>POSTROUTING</code> 链主要涉及两张表：<code>mangle</code> 和 <code>nat</code>。由于<code>mangle</code>表示空表，只需关注<code>nat</code>表的<code>POSTROUTING</code>规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -nvL</span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT 488 packets, 29280 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"> 8165  491K KUBE-POSTROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */</span><br><span class="line">   13   780 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">    0     0 DOCKER_POSTROUTING  all  --  *      *       0.0.0.0/0            192.168.65.2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先进入第一个 <code>target</code>，<code>KUBE-POSTROUTING</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-POSTROUTING (1 references)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">  486 29160 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0            mark match ! 0x4000/0x4000</span><br><span class="line">    0     0 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            MARK xor 0x4000</span><br><span class="line">    0     0 MASQUERADE  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */ random-fully</span><br></pre></td></tr></table></figure><p>最终会发现数据包是从<code>docker0</code>网卡发送出来，并没有做<code>SNAT</code>操作，<code>source ip</code> 依然是 <code>172.17.0.3</code>，但是这个时候的<code>DST IP</code>是<code>10.172.0.4</code> 而不是<code>service ip: 10.97.79.231</code>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>ClusterIP</code> 类型的数据包经历的链路是：</p><pre class="mermaid">graph TB    s((数据包))-->1[nat:OUTPUT]    1-->2[nat:KUBE-SERVICES]    2-->3[nat:KUBE-SVC-V2OKYYMBY3REGZOG]    3-->4[nat:KUBE-SEP-*:3选一]    4-->5[filter:OUTPUT]    5-->6[filter:KUBE-FIREWALL]    6-->7[nat:POSTROUTING]    7-->8[nat:KUBE-POSTROUTING]    8-->9((未被SNAT))</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继 &lt;a href=&quot;https://kiragoo.github.io/archives/26a027f0.html&quot;&gt;&lt;code&gt;iptables&lt;/code&gt; 入门出坑&lt;/a&gt;之后，加深个人理解无非是实战，此篇我们来通过示例来加深个人理解。&lt;/p&gt;
&lt;h2 id=&quot;环</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="网络" scheme="http://kiragoo.github.com/categories/kubernetes/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="iptables" scheme="http://kiragoo.github.com/tags/iptables/"/>
    
    <category term="kube-proxy" scheme="http://kiragoo.github.com/tags/kube-proxy/"/>
    
  </entry>
  
  <entry>
    <title>iptables 入门出坑</title>
    <link href="http://kiragoo.github.com/archives/26a027f0.html"/>
    <id>http://kiragoo.github.com/archives/26a027f0.html</id>
    <published>2021-11-02T02:42:35.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自<a href="https://mp.weixin.qq.com/s/Dgv5BU9YU0tuSMxtzcuiVw"><code>iptables</code>长文详解，值得收藏细读</a><br>整理此篇博文的初衷还是因为目前很多 <code>k8s</code> 的内部的 <code>service</code> 路由规则还是通过 <code>iptables</code> 来实现的，否则最终还是只停留在使用层面，能够让我们对某个服务夯住又多了个排查利器。</p></blockquote><p><code>Linux</code> 的网络控制模块在内核中，叫做<code>netfilter</code>。而<code>iptables</code>是位于用户空间的一个命令行工具，它作用在OIS7层网络模型中的第四层[物理层，数据链路层，网络层，<strong>传输层</strong>，会话层，表示层，应用层]，用来和内核的<code>netfilter</code>交互，配置<code>netfilter</code>进而实现对网络的控制、流量的转发。</p><p>主要功能：</p><ul><li>流量转发：<code>DNAT</code> 实现 <code>IP</code> 地址和端口的映射</li><li>负载均衡：<code>statistic</code> 模块为每个后端设置权重</li><li>会话保持：<code>recent</code> 模块设置会话保持时间</li></ul><h2 id="基本两要素"><a href="#基本两要素" class="headerlink" title="基本两要素"></a>基本两要素</h2><p>表和链路，5表5链路。</p><p>5张表分别是：<code>raw</code>,<code>filter</code>,<code>nat</code>,<code>mangle</code>,<code>security</code><br>5条链路分别是：<code>prerouting</code>,<code>input</code>,<code>forward</code>,<code>output</code>,<code>postrouting</code></p><p>通过 <code>iptables -t $&#123;table&#125; -nL</code> 查看相关表：</p><p><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/iptables-nl.png" alt="`filter` 表查看"></p><pre class="mermaid">graph LRR[iptables]-->FT(filter表)FT-->FTFIC(input链)FTFIC-->在入口对流量做过滤FT-->FTFC(forward链)FTFC-->做流量转发FT-->FTOC(output链)FTOC-->在出口对流量做过滤FT-->作用:常用于控制到达某条链路上的数据是继续放行,丢弃,拒绝R-->NT(nat表)NT-->NTPREC(prerouting链)NTPREC-->做dnat目标地址转换NT-->NTIC(input链)NT-->NTOC(output链)NT-->NTPOSTC(postouting链)NTPOSTC-->做snat源地址转换NT-->常用于修改数据包的原地址,目的地址R-->MT(mangle表)MT-->MTPREC(prerouting)MT-->MTIC(input链)MT-->MTFC(forward链)MT-->MTOC(output链)MT-->MTPOSTC(postouting链)MT-->常用于修改ip数据包的头信息R-->RT(raw表)RT-->RTPREC(prerouting链)RT-->RTOC(output链)RT-->对连接的状态进行追踪,常见的状态有new,establishedR-->ST(security表)ST-->是新加入的表,用于将数据包应用在selinux上</pre><h2 id="流量走向分析"><a href="#流量走向分析" class="headerlink" title="流量走向分析"></a>流量走向分析</h2><p>对于流量的分析，我们可以考虑两个场景：</p><ul><li>来及本机的流量经过了 <code>iptables</code> 的哪些节点，最终又到哪里去了？</li><li>来自互联网的外界流量，是如何经历 <code>iptables</code> 的，然后最终的去处？</li></ul><h3 id="iptables-处理流程"><a href="#iptables-处理流程" class="headerlink" title="iptables 处理流程"></a><code>iptables</code> 处理流程</h3><p><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/Netfilter-packet-flow.svg.png" alt="`netfilter-packet-filter`"></p><h3 id="iptables-在-kube-proxy-的处理流程"><a href="#iptables-在-kube-proxy-的处理流程" class="headerlink" title="iptables 在 kube-proxy 的处理流程"></a><code>iptables</code> 在 <code>kube-proxy</code> 的处理流程</h3><p><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/kube-proxy-its.png" alt="`kube-proxy-iptables`"></p><blockquote><p>关于 <code>kube-proxy</code> 的规则处理，可以借鉴博文<a href="https://zjj2wry.github.io/network/iptables/">理解<code>kube-proxy</code>中<code>iptable</code>规则</a></p></blockquote><p>如上表解析：<br>1、 红，蓝，绿，紫分别代表上<code>iptables</code>的四张表，如果开启了<code>seLinux</code>，会多出一个<code>security</code>表。</p><p>2、上图左上角部分：<code>incoming packet</code>，表示这是从互联网设备过来的流量，会经历各个表的<code>preouting</code>阶段，再由<code>routing decision</code>(路由选择)决定这些流量是由本机处理还是<code>forward</code>转发走。</p><p>3、上图左上角部分：<code>incoming packet</code> 在做 <code>routing descision</code> 之前会经过<code>nat preouting</code>阶段，在此阶段可以做<code>dnat</code>，可以简单理解为：比如这个数据包原来的<code>dst ip</code>是百度的，经过<code>routing desicion</code> 之后进入<code>forward</code> 转发阶段，这个时候改写目标地址为自己本机，让数据进入<code>input</code>通路，可以在本机截获这个数据包。</p><p>4、上图右上角部分：<code>locally generated packet</code>，表示这是本机自己生成的流量。它会一路经过各个表的<code>output</code>链，然后流到<code>output interface</code>（网卡）上。你注意下，流量在被打包成<code>outgoing packet</code>之前，会有个<code>localhost dest</code>的判断，如果它判断流量不是发往本机的话，流量会经过<code>nat</code>表的<code>postrouting</code>阶段。一般会在这里做DNAT源地址改写。</p><p>理解如上流程，我们可以灵活的对流量进行自定义控制，通常的流量控制无非如下：</p><p>1、 丢弃来自XXX的流量 （<code>filter</code> 表 <code>INPUT</code> 链）</p><p>2、 丢弃去往XXX的流量 （<code>filter</code> 表 <code>OUTPUT</code>链）</p><p>3、 只接收来自XXX的流量 （<code>filter</code> 表 <code>INPUT</code> 链）</p><p>4、 在流量刚流入时，将目的地址改写成其他地址（<code>nat</code>表<code>preouting</code>链）</p><p>5、 在流量即将流出时，将源地址改写成其他地址（<code>nat</code>表<code>postouting</code>链)</p><p>6、 将发往 <code>A</code> 的数据包，转发给<code>B</code>(<code>filter</code>表<code>forward</code>链)</p><p><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/iptables-flow.png" alt="iptables-flow-zsy(出自https://www.zsythink.net/archives/1199)"></p><p><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/iptable-flow.drawio.png" alt="iptable-flow"></p><h2 id="iptables-commands"><a href="#iptables-commands" class="headerlink" title="iptables commands"></a><code>iptables commands</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptabls -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;Commands&#125;</span> <span class="variable">$&#123;链名&#125;</span> <span class="variable">$&#123;链中规则&#125;</span> <span class="variable">$&#123;匹配条件&#125;</span> <span class="variable">$&#123;目标动作&#125;</span></span><br></pre></td></tr></table></figure><table>    <tr>        <th>命令行属性</th>        <th>属性列表</th>        <th>说明</th>    </tr>    <tr>        <td rowspan="5">表名</td>        <td> raw </td>        <td>iptables 是有状态的，其对数据包有链接追踪机制，链接追踪信息在/proc/net/nf_conntrack 中可以看到记录</td>    </tr>    <tr>        <td> filter </td>        <td> 用于控制到达某条链接上的数据包是继续放行，直接丢弃还是拒绝</td>    </tr>    <tr>        <td> mangle</td>        <td> 用于修改数据包的IP头信息</td>    </tr>    <tr>        <td> nat </td>        <td>network address translation 网络地址转换，用于修改数据包的源地址和目的地址 </td>    </tr>    <tr>        <td> security </td>        <td> 不常用的表，用在SeLinux上</td>    </tr>    <tr>        <td rowspan="5"> Commands </td>        <td> PREOUTING </td>        <td> 数据包进入之前，可以在此进行DNAT</td>    </tr>    <tr>        <td> POSTOUTING </td>        <td> 发送到网卡之前，可以在此处进行SNAT</td>    </tr>    <tr>        <td> INPUT </td>        <td> 一般处理本地进程的数据包，目的地址为本机</td>    </tr>    <tr>        <td> OUTPUT </td>        <td>原地址为本机，向外发送，一般处理本地进程的数据数据包 </td>    </tr>    <tr>        <td> FORWARD </td>        <td> </td>    </tr>    <tr>        <td> POSTROUTING </td>        <td> </td>    </tr>    <tr>        <td rowspan="10">Commands</td>        <td>-A</td>        <td>添加</td>    </tr>    <tr>        <td>-C</td>        <td>检查</td>    </tr>        <tr>        <td>-C</td>        <td>检查</td>    </tr>    <tr>        <td>-D</td>        <td>删除</td>    </tr>    <tr>        <td>-I</td>        <td>在头部插入</td>    </tr>    <tr>        <td>-R</td>        <td>替换</td>    </tr>    <tr>        <td>-L</td>        <td>查看全部</td>    </tr>    <tr>        <td>-F</td>        <td>清空</td>    </tr>    <tr>        <td>-N</td>        <td>新建</td>    </tr>    <tr>        <td>-P</td>        <td>默认是ACCEPT</td>    </tr>    <tr>        <td rowspan="4">匹配条件</td>        <td>-p</td>        <td>协议，-4,-6</td>    </tr>    <tr>        <td>-s</td>        <td>源地址</td>    </tr>    <tr>        <td>-d</td>        <td>目的地址</td>    </tr>    <tr>        <td>-i</td>        <td>网络接口名称</td>    </tr>    <tr>        <td rowspan="7">目标动作</td>        <td>-j REJECT</td>        <td>拒绝访问</td>    </tr>    <tr>        <td>-j ACCEPT</td>        <td>允许通过</td>    </tr>    <tr>        <td>-j DROP</td>        <td>丢弃</td>    </tr>    <tr>        <td>-j LOG</td>        <td>记录日志</td>    </tr>    <tr>        <td>-j SNAT</td>        <td>源地址转换</td>    </tr>    <tr>        <td>-j DNAT</td>        <td>目标地址转换</td>    </tr>    <tr>        <td>RETURN,QUEUE</td>        <td></td>    </tr></table><h2 id="iptables-的匹配规则"><a href="#iptables-的匹配规则" class="headerlink" title="iptables 的匹配规则"></a><code>iptables</code> 的匹配规则</h2><p>常见的规则如下：<br>源地址：<code>-s 192.168.1.0/24</code><br>目标地址：<code>-d 192.168.1.11</code><br>协议：<code>-p tcp|udp|icmp</code><br>从哪个网卡进来：<code>-i eth0|lo</code><br>从哪个网卡出去：<code>-o eth0|lo</code><br>目标端口（必须制定协议）：<code>-p tcp|udp --dport 8080</code><br>源端口（必须制定协议）：<code>-p tcp|udp --sport 8080</code></p><p><code>iptables</code> 中的每条规则顺序都是由上至下顺序执行的，除非碰到了 <code>DROP</code>,<code>REJECT</code>,<code>RETURN</code>。</p><p>还有就是如果定义的动作是<code>JUMP</code>，那就会相应的 <code>jump</code> 到指定链路上的指定规则：</p><pre class="mermaid">graph TB    chain1((chain1)) --> rule1-1((rule1-1))    chain2((chain2)) --> rule2-1((rule2-1))    rule1-1 --> rule1-2((rule1-2))    rule1-2 --> rule1-3((rule1-3))    rule2-1 --> rule2-2((rule2-2))    rule2-2 --> rule2-3((rule2-3))    rule1-2 --JUMP--> rule2-1    rule2-3 --JUMP--> rule1-3</pre><h2 id="iptables-中的模块"><a href="#iptables-中的模块" class="headerlink" title="iptables 中的模块"></a><code>iptables</code> 中的模块</h2><ul><li>多端口</li></ul><p>可以如下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中的20:30表示20和30之间的所有端口</span></span><br><span class="line">iptables -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;commands&#125;</span> <span class="variable">$&#123;chain&#125;</span> <span class="variable">$&#123;规则号&#125;</span> --dport 20:30 -j <span class="variable">$&#123;动作&#125;</span></span><br></pre></td></tr></table></figure><p>想指定多个不连续的端口可以使用<code>iptables</code>的<code>multiport</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看帮助文档</span></span><br><span class="line">~]<span class="comment"># iptables -m multiport --help</span></span><br><span class="line">...</span><br><span class="line">multiport match options:</span><br><span class="line">[!] --source-ports port[,port:port,port...]</span><br><span class="line"> --sports ...</span><br><span class="line">    match <span class="built_in">source</span> port(s)</span><br><span class="line">[!] --destination-ports port[,port:port,port...]</span><br><span class="line"> --dports ...</span><br><span class="line">    match destination port(s)</span><br><span class="line">[!] --ports port[,port:port,port]</span><br><span class="line">    match both <span class="built_in">source</span> and destination port(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令例子</span></span><br><span class="line">iptables -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;commands&#125;</span> <span class="variable">$&#123;chain&#125;</span> <span class="variable">$&#123;规则号&#125;</span>  </span><br><span class="line">     <span class="variable">$&#123;-p 协议&#125;</span> -m multiport --dports 20,30 -j <span class="variable">$&#123;动作&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#相当于如下两行命令</span></span><br><span class="line">iptables -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;commands&#125;</span> <span class="variable">$&#123;chain&#125;</span>  <span class="variable">$&#123;规则号&#125;</span> -p <span class="variable">$&#123;协议&#125;</span> --dprot 20 -j <span class="variable">$&#123;动作&#125;</span></span><br><span class="line">iptables -t <span class="variable">$&#123;表名&#125;</span> <span class="variable">$&#123;commands&#125;</span> <span class="variable">$&#123;chain&#125;</span>  <span class="variable">$&#123;规则号&#125;</span> -p <span class="variable">$&#123;协议&#125;</span> --dprot 30 -j <span class="variable">$&#123;动作&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>ip</code> 范围</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># iptables -m iprange --help</span></span><br><span class="line">iprange match options:</span><br><span class="line">[!] --src-range ip[-ip]    Match <span class="built_in">source</span> IP <span class="keyword">in</span> the specified range</span><br><span class="line">[!] --dst-range ip[-ip]    Match destination IP <span class="keyword">in</span> the specified range</span><br></pre></td></tr></table></figure><ul><li>连接状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># iptables -m state --help</span></span><br><span class="line">state match options:</span><br><span class="line"> [!] --state [INVALID|ESTABLISHED|NEW|RELATED|UNTRACKED][,...]</span><br></pre></td></tr></table></figure><blockquote><p>参考借鉴</p></blockquote><ul><li><a href="https://mp.weixin.qq.com/s/Dgv5BU9YU0tuSMxtzcuiVw"><code>iptables</code>长文详解，值得收藏细读</a></li><li><a href="http://www.tianfeiyu.com/?p=2894"><code>kube-proxy iptables</code> 模式源码分析</a></li><li><a href="https://www.zsythink.net/archives/1199"><code>iptables详解（1）</code></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文整理自&lt;a href=&quot;https://mp.weixin.qq.com/s/Dgv5BU9YU0tuSMxtzcuiVw&quot;&gt;&lt;code&gt;iptables&lt;/code&gt;长文详解，值得收藏细读&lt;/a&gt;&lt;br&gt;整理此篇博文的初衷还是因为目前很多 &lt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://kiragoo.github.com/categories/Linux/"/>
    
    
    <category term="iptables" scheme="http://kiragoo.github.com/tags/iptables/"/>
    
    <category term="网络" scheme="http://kiragoo.github.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes源码分析系列之源码分析系列之Statefulset Controller</title>
    <link href="http://kiragoo.github.com/archives/f7f100a2.html"/>
    <id>http://kiragoo.github.com/archives/f7f100a2.html</id>
    <published>2021-10-21T03:01:43.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于分析 <code>Controller</code> 源码选用 <code>StatefulSet Controller</code> 来，其它控制器源码分析一个套路，可以做参考。</p></blockquote><h1 id="StatefulSet-简介"><a href="#StatefulSet-简介" class="headerlink" title="StatefulSet 简介"></a><code>StatefulSet</code> 简介</h1><p>此篇文章默认你已经具备了熟练使用 <code>Statefulset</code> 的基础知识，所以常规介绍及使用 <code>Demo</code> 的描述不在阐述，具体可参考 <a href="https://kubernetes.io/zh/docs/tutorials/stateful-application/basic-stateful-set/">StatefulSet 基础</a></p><h1 id="StatefulSet-Controller-启动分析"><a href="#StatefulSet-Controller-启动分析" class="headerlink" title="StatefulSet Controller 启动分析"></a><code>StatefulSet Controller</code> 启动分析</h1><h2 id="kube-manager-controller-入口调用链分析"><a href="#kube-manager-controller-入口调用链分析" class="headerlink" title="kube-manager-controller 入口调用链分析"></a><code>kube-manager-controller</code> 入口调用链分析</h2><p><em>对于 <code>Kubernetes</code> 的源码组织结构不做过多介绍，希望你有一定的了解。</em></p><p>对于 <code>k8s</code> 是如何启动 <code>kube-controller-manager</code>，可以通过<a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-controller-manager/">文档<code>kube-controller-manager </code></a> 查找到对应如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--controllers strings     默认值：[*]</span><br><span class="line">要启用的控制器列表。\* 表示启用所有默认启用的控制器； foo 启用名为 foo 的控制器； -foo 表示禁用名为 foo 的控制器。</span><br><span class="line">控制器的全集：attachdetach、bootstrapsigner、cloud-node-lifecycle、clusterrole-aggregation、cronjob、csrapproving、csrcleaner、csrsigning、daemonset、deployment、disruption、endpoint、endpointslice、endpointslicemirroring、ephemeral-volume、garbagecollector、horizontalpodautoscaling、job、namespace、nodeipam、nodelifecycle、persistentvolume-binder、persistentvolume-expander、podgc、pv-protection、pvc-protection、replicaset、replicationcontroller、resourcequota、root-ca-cert-publisher、route、service、serviceaccount、serviceaccount-token、statefulset、tokencleaner、ttl、ttl-after-finished</span><br><span class="line">默认禁用的控制器有：bootstrapsigner 和 tokencleaner。</span><br></pre></td></tr></table></figure><p>这里我们发现默认值启动中已经加入了 <code>statefulset</code> 的初始化，那么在代码是在哪里体现的呢？继续往下看。</p><p>进入 <code>cmd/controller-manager</code> 的 <code>main</code> 函数，实际上就做两个事情：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">command := app.NewControllerManagerCommand()    <span class="comment">// 初始化</span></span><br><span class="line">code := cli.Run(command)    <span class="comment">//真正执行</span></span><br><span class="line">os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数调用关系，我们进入 <code>cmd/kube-controller-manager/controllermanager.go</code> 中，查看 <code>Run</code> 执行究竟做了啥。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">verflag.PrintAndExitIfRequested()</span><br><span class="line">cliflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">err := checkNonZeroInsecurePort(cmd.Flags())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是我们需要关注的点，就是 `KnownControllers() 实际上就是将我们进行需要我们初始化已知的 `Controllers`</span></span><br><span class="line">c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List())     </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := Run(c.Complete(), wait.NeverStop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>深入 <code>KnowControllers()</code> 函数分析：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KnownControllers returns all known controllers&#x27;s name</span></span><br><span class="line"><span class="comment">// 这里我们发现实际上这边就是之前 `daemon` 进程启动需要的参数，为一个 `controller` 控制器数组。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KnownControllers</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">ret := sets.StringKeySet(NewControllerInitializers(IncludeCloudLoops))</span><br><span class="line"></span><br><span class="line"><span class="comment">// add &quot;special&quot; controllers that aren&#x27;t initialized normally.  These controllers cannot be initialized</span></span><br><span class="line"><span class="comment">// using a normal function.  The only known special case is the SA token controller which *must* be started</span></span><br><span class="line"><span class="comment">// first to ensure that the SA tokens for future controllers will exist.  Think very carefully before adding</span></span><br><span class="line"><span class="comment">// to this list.</span></span><br><span class="line">ret.Insert(</span><br><span class="line">saTokenControllerName,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret.List()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>NewControllerInitializers</code> 可以知道的是真正执行 <code>controller-manager</code> 初始化的执行函数是这个。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewControllerInitializers is a public map of named controller groups (you can start more than one in an init func)</span></span><br><span class="line"><span class="comment">// paired to their InitFunc.  This allows for structured downstream composition and subdivision.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">controllers := <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处即为在 `map` 中进行实质性的初始化赋值</span></span><br><span class="line">controllers[<span class="string">&quot;statefulset&quot;</span>] = startStatefulSetController  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> loopMode == IncludeCloudLoops &#123;</span><br><span class="line">controllers[<span class="string">&quot;service&quot;</span>] = startServiceController</span><br><span class="line">controllers[<span class="string">&quot;route&quot;</span>] = startRouteController</span><br><span class="line">controllers[<span class="string">&quot;cloud-node-lifecycle&quot;</span>] = startCloudNodeLifecycleController</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> volume controller into the IncludeCloudLoops only set.</span></span><br><span class="line">&#125;</span><br><span class="line">controllers[<span class="string">&quot;persistentvolume-binder&quot;</span>] = startPersistentVolumeBinderController</span><br><span class="line">controllers[<span class="string">&quot;attachdetach&quot;</span>] = startAttachDetachController</span><br><span class="line">controllers[<span class="string">&quot;persistentvolume-expander&quot;</span>] = startVolumeExpandController</span><br><span class="line">controllers[<span class="string">&quot;clusterrole-aggregation&quot;</span>] = startClusterRoleAggregrationController</span><br><span class="line">controllers[<span class="string">&quot;pvc-protection&quot;</span>] = startPVCProtectionController</span><br><span class="line">controllers[<span class="string">&quot;pv-protection&quot;</span>] = startPVProtectionController</span><br><span class="line">controllers[<span class="string">&quot;ttl-after-finished&quot;</span>] = startTTLAfterFinishedController</span><br><span class="line">controllers[<span class="string">&quot;root-ca-cert-publisher&quot;</span>] = startRootCACertPublisher</span><br><span class="line">controllers[<span class="string">&quot;ephemeral-volume&quot;</span>] = startEphemeralVolumeController</span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(genericfeatures.APIServerIdentity) &amp;&amp;</span><br><span class="line">utilfeature.DefaultFeatureGate.Enabled(genericfeatures.StorageVersionAPI) &#123;</span><br><span class="line">controllers[<span class="string">&quot;storage-version-gc&quot;</span>] = startStorageVersionGCController</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> controllers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如上可以得知 <code>StatefulSet</code> 是如何被初始化到 <code>kube-controller-manager</code> 中的。</p><h2 id="Statefulset-Controller-启动过程"><a href="#Statefulset-Controller-启动过程" class="headerlink" title="Statefulset Controller 启动过程"></a><code>Statefulset Controller</code> 启动过程</h2><p>通过 <code>cmd/kube-manager-controller/app/controllermanager.go</code> 中 <code>Run</code> 函数分析，其中</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">verflag.PrintAndExitIfRequested()</span><br><span class="line">cliflag.PrintFlags(cmd.Flags())</span><br><span class="line"></span><br><span class="line">err := checkNonZeroInsecurePort(cmd.Flags())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c, err := s.Config(KnownControllers(), ControllersDisabledByDefault.List()) </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处是对 `Controller manager` 进行 `config` 的初始化，然后对其中所管理的 `controller` 进行 `Run` 执行</span></span><br><span class="line"><span class="keyword">if</span> err := Run(c.Complete(), wait.NeverStop); err != <span class="literal">nil</span> &#123; </span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>进入 <code>Run</code> 函数进行分析：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(c *config.CompletedConfig, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// To help debugging, immediately log version</span></span><br><span class="line">klog.Infof(<span class="string">&quot;Version: %+v&quot;</span>, version.Get())</span><br><span class="line">...</span><br><span class="line">clientBuilder, rootClientBuilder := createClientBuilders(c)</span><br><span class="line"></span><br><span class="line">saTokenControllerInitFunc := serviceAccountTokenControllerStarter&#123;rootClientBuilder: rootClientBuilder&#125;.startServiceAccountTokenController</span><br><span class="line"></span><br><span class="line">run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, startSATokenController InitFunc, initializersFunc ControllerInitializersFunc)</span></span> &#123; <span class="comment">// 此处是我们需要关注的 `Controller` 初始化。</span></span><br><span class="line"></span><br><span class="line">controllerContext, err := CreateControllerContext(c, rootClientBuilder, clientBuilder, ctx.Done())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">&quot;error building controller context: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">controllerInitializers := initializersFunc(controllerContext.LoopMode)</span><br><span class="line">        <span class="comment">// 在这里是真正意义上开始对管理的控制器执行启动</span></span><br><span class="line"><span class="keyword">if</span> err := StartControllers(ctx, controllerContext, startSATokenController, controllerInitializers, unsecuredMux, healthzHandler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Fatalf(<span class="string">&quot;error starting controllers: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">controllerContext.InformerFactory.Start(stopCh)</span><br><span class="line">controllerContext.ObjectOrMetadataInformerFactory.Start(stopCh)</span><br><span class="line"><span class="built_in">close</span>(controllerContext.InformersStarted)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <code>StartControllers</code> 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartControllers starts a set of controllers with a specified ControllerContext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartControllers</span><span class="params">(ctx context.Context, controllerCtx ControllerContext, startSATokenController InitFunc, controllers <span class="keyword">map</span>[<span class="keyword">string</span>]InitFunc,</span></span></span><br><span class="line"><span class="function"><span class="params">unsecuredMux *mux.PathRecorderMux, healthzHandler *controllerhealthz.MutableHealthzHandler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 这里会 `for` 循环遍历初始化过的 `controllers` 进行处理，需要关注下 `initFn` 究竟做了啥.</span></span><br><span class="line"><span class="keyword">for</span> controllerName, initFn := <span class="keyword">range</span> controllers &#123;</span><br><span class="line"><span class="keyword">if</span> !controllerCtx.IsControllerEnabled(controllerName) &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;%q is disabled&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(wait.Jitter(controllerCtx.ComponentConfig.Generic.ControllerStartInterval.Duration, ControllerStartJitter))</span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">1</span>).Infof(<span class="string">&quot;Starting %q&quot;</span>, controllerName)</span><br><span class="line">ctrl, started, err := initFn(ctx, controllerCtx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Errorf(<span class="string">&quot;Error starting %q&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !started &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;Skipping %q&quot;</span>, controllerName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">klog.Infof(<span class="string">&quot;Started %q&quot;</span>, controllerName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">healthzHandler.AddHealthChecker(controllerChecks...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于判断具体的 `controller` 是否满足接口需求来得到 `controller manager` 支持的特性</span></span><br><span class="line"><span class="keyword">type</span> InitFunc <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, controllerCtx ControllerContext)</span> <span class="params">(controller controller.Interface, enabled <span class="keyword">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>看到这里我们似乎还是没看到 <code>StatefulSet Controller</code> 真正执行的地方，请再次回顾下我们之前 <code>NewControllerInitializers</code> 中的内容：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewControllerInitializers</span><span class="params">(loopMode ControllerLoopMode)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">InitFunc</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    controllers[<span class="string">&quot;statefulset&quot;</span>] = startStatefulSetController</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉看到了一丝丝曙光，继续往下看 <code>startStatefulSetController</code> 的具体实现。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startStatefulSetController</span><span class="params">(ctx context.Context, controllerContext ControllerContext)</span> <span class="params">(controller.Interface, <span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> statefulset.NewStatefulSetController(</span><br><span class="line"><span class="comment">// 如下是 `Sts` 直接相关类型</span></span><br><span class="line">controllerContext.InformerFactory.Core().V1().Pods(),</span><br><span class="line">controllerContext.InformerFactory.Apps().V1().StatefulSets(),</span><br><span class="line">controllerContext.InformerFactory.Core().V1().PersistentVolumeClaims(),</span><br><span class="line">controllerContext.InformerFactory.Apps().V1().ControllerRevisions(),</span><br><span class="line">controllerContext.ClientBuilder.ClientOrDie(<span class="string">&quot;statefulset-controller&quot;</span>),</span><br><span class="line">).Run(<span class="keyword">int</span>(controllerContext.ComponentConfig.StatefulSetController.ConcurrentStatefulSetSyncs), ctx.Done())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里我们终于知道了 <code>StatefulSet Controller</code> 真正意义上是被如何启动的了。</p><h1 id="StatefulSet-Controller-明细分析"><a href="#StatefulSet-Controller-明细分析" class="headerlink" title="StatefulSet Controller 明细分析"></a><code>StatefulSet Controller</code> 明细分析</h1><p>通过如上的分析，下面就到了 <code>StatefulSet Controller</code> 具体的范畴了。</p><h2 id="StatefulSetController"><a href="#StatefulSetController" class="headerlink" title="StatefulSetController"></a><code>StatefulSetController</code></h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StatefulSetController <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// client interface</span></span><br><span class="line">kubeClient clientset.Interface</span><br><span class="line"><span class="comment">// control returns an interface capable of syncing a stateful set.</span></span><br><span class="line"><span class="comment">// Abstracted out for testing.</span></span><br><span class="line">control StatefulSetControlInterface</span><br><span class="line"><span class="comment">// podControl is used for patching pods.</span></span><br><span class="line">podControl controller.PodControlInterface</span><br><span class="line"><span class="comment">// podLister is able to list/get pods from a shared informer&#x27;s store</span></span><br><span class="line">podLister corelisters.PodLister</span><br><span class="line"><span class="comment">// podListerSynced returns true if the pod shared informer has synced at least once</span></span><br><span class="line">podListerSynced cache.InformerSynced</span><br><span class="line"><span class="comment">// setLister is able to list/get stateful sets from a shared informer&#x27;s store</span></span><br><span class="line">setLister appslisters.StatefulSetLister</span><br><span class="line"><span class="comment">// setListerSynced returns true if the stateful set shared informer has synced at least once</span></span><br><span class="line">setListerSynced cache.InformerSynced</span><br><span class="line"><span class="comment">// pvcListerSynced returns true if the pvc shared informer has synced at least once</span></span><br><span class="line">pvcListerSynced cache.InformerSynced</span><br><span class="line"><span class="comment">// revListerSynced returns true if the rev shared informer has synced at least once</span></span><br><span class="line">revListerSynced cache.InformerSynced</span><br><span class="line"><span class="comment">// StatefulSets that need to be synced.</span></span><br><span class="line">queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对 <code>StatefulSetController</code> 结构体的大纲，了解下大概的结构：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/ssc.png" alt="ssc"></p><h2 id="NewStatefulSetController"><a href="#NewStatefulSetController" class="headerlink" title="NewStatefulSetController"></a><code>NewStatefulSetController</code></h2><p>对于 <code>ssc</code> 的构造函数分析：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStatefulSetController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">// 可以观察到，这边都是 `ssc` 关心的 `resource` 对象，Pod/Sts/Pvc/Revision</span></span></span><br><span class="line"><span class="function"><span class="params">podInformer coreinformers.PodInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">setInformer appsinformers.StatefulSetInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">pvcInformer coreinformers.PersistentVolumeClaimInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">revInformer appsinformers.ControllerRevisionInformer,</span></span></span><br><span class="line"><span class="function"><span class="params">kubeClient clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">StatefulSetController</span></span> &#123;</span><br><span class="line">eventBroadcaster := record.NewBroadcaster()</span><br><span class="line">eventBroadcaster.StartStructuredLogging(<span class="number">0</span>)</span><br><span class="line">eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl&#123;Interface: kubeClient.CoreV1().Events(<span class="string">&quot;&quot;</span>)&#125;)</span><br><span class="line">recorder := eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: <span class="string">&quot;statefulset-controller&quot;</span>&#125;)</span><br><span class="line">ssc := &amp;StatefulSetController&#123;</span><br><span class="line">kubeClient: kubeClient,</span><br><span class="line">control: NewDefaultStatefulSetControl(</span><br><span class="line">NewRealStatefulPodControl(</span><br><span class="line">kubeClient,</span><br><span class="line">setInformer.Lister(),</span><br><span class="line">podInformer.Lister(),</span><br><span class="line">pvcInformer.Lister(),</span><br><span class="line">recorder),</span><br><span class="line">NewRealStatefulSetStatusUpdater(kubeClient, setInformer.Lister()),</span><br><span class="line">history.NewHistory(kubeClient, revInformer.Lister()),</span><br><span class="line">recorder,</span><br><span class="line">),</span><br><span class="line">pvcListerSynced: pvcInformer.Informer().HasSynced,</span><br><span class="line">queue:           workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">&quot;statefulset&quot;</span>),</span><br><span class="line">podControl:      controller.RealPodControl&#123;KubeClient: kubeClient, Recorder: recorder&#125;,</span><br><span class="line"></span><br><span class="line">revListerSynced: revInformer.Informer().HasSynced,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Sts` 管理的 `Pod crud` 时对应的处理方法</span></span><br><span class="line">podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line"><span class="comment">// lookup the statefulset and enqueue</span></span><br><span class="line">AddFunc: ssc.addPod,</span><br><span class="line"><span class="comment">// lookup current and old statefulset if labels changed</span></span><br><span class="line">UpdateFunc: ssc.updatePod,</span><br><span class="line"><span class="comment">// lookup statefulset accounting for deletion tombstones</span></span><br><span class="line">DeleteFunc: ssc.deletePod,</span><br><span class="line">&#125;)</span><br><span class="line">ssc.podLister = podInformer.Lister()</span><br><span class="line">ssc.podListerSynced = podInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Sts crud` 时对应的方法 </span></span><br><span class="line">setInformer.Informer().AddEventHandler(</span><br><span class="line">cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">AddFunc: ssc.enqueueStatefulSet,</span><br><span class="line">UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, cur <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">oldPS := old.(*apps.StatefulSet)</span><br><span class="line">curPS := cur.(*apps.StatefulSet)</span><br><span class="line"><span class="keyword">if</span> oldPS.Status.Replicas != curPS.Status.Replicas &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Observed updated replica count for StatefulSet: %v, %d-&gt;%d&quot;</span>, curPS.Name, oldPS.Status.Replicas, curPS.Status.Replicas)</span><br><span class="line">&#125;</span><br><span class="line">ssc.enqueueStatefulSet(cur)</span><br><span class="line">&#125;,</span><br><span class="line">DeleteFunc: ssc.enqueueStatefulSet,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">ssc.setLister = setInformer.Lister()</span><br><span class="line">ssc.setListerSynced = setInformer.Informer().HasSynced</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Watch volumes</span></span><br><span class="line"><span class="keyword">return</span> ssc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ControllerRevision"><a href="#ControllerRevision" class="headerlink" title="ControllerRevision"></a><code>ControllerRevision</code></h3><p>这里了解下 <code>ControllerRevision</code> 究竟是啥，为啥需要关注。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ControllerRevision implements an immutable snapshot of state data. Clients</span></span><br><span class="line"><span class="comment">// are responsible for serializing and deserializing the objects that contain</span></span><br><span class="line"><span class="comment">// their internal state.</span></span><br><span class="line"><span class="comment">// Once a ControllerRevision has been successfully created, it can not be updated.</span></span><br><span class="line"><span class="comment">// The API Server will fail validation of all requests that attempt to mutate</span></span><br><span class="line"><span class="comment">// the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both</span></span><br><span class="line"><span class="comment">// the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However,</span></span><br><span class="line"><span class="comment">// it may be subject to name and representation changes in future releases, and clients should not</span></span><br><span class="line"><span class="comment">// depend on its stability. It is primarily for internal use by controllers.</span></span><br><span class="line"><span class="keyword">type</span> ControllerRevision <span class="keyword">struct</span> &#123;</span><br><span class="line">metav1.TypeMeta <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line"><span class="comment">// Standard object&#x27;s metadata.</span></span><br><span class="line"><span class="comment">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</span></span><br><span class="line"><span class="comment">// +optional</span></span><br><span class="line">metav1.ObjectMeta <span class="string">`json:&quot;metadata,omitempty&quot; protobuf:&quot;bytes,1,opt,name=metadata&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Data is the serialized representation of the state.</span></span><br><span class="line">Data runtime.RawExtension <span class="string">`json:&quot;data,omitempty&quot; protobuf:&quot;bytes,2,opt,name=data&quot;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Revision indicates the revision of the state represented by Data.</span></span><br><span class="line">Revision <span class="keyword">int64</span> <span class="string">`json:&quot;revision&quot; protobuf:&quot;varint,3,opt,name=revision&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由对应的注释可以知道：<br><code>ControllerRevision</code> 提供给 <code>DaemonSet</code>和 <code>StatefulSet</code> 用作更新和回滚，<code>ControllerRevision</code> 存放的是数据的快照，<code>ControllerRevision</code> 生成之后内容是不可修改的，由调用端来负责序列化写入和反序列化读取。其中 <code>Revision(int64)</code> 字段相当于 <code>ControllerRevision</code> 的版本 <code>id</code> 号，Data字段则存放序列化后的数据。<br>所以 <code>Sts</code> 的更新以及回滚是基于新旧 <code>ControllerRevision</code> 的对比来进行的。</p><h3 id="NewDefaultStatefulSetControl"><a href="#NewDefaultStatefulSetControl" class="headerlink" title="NewDefaultStatefulSetControl"></a><code>NewDefaultStatefulSetControl</code></h3><p>深入看下 <code>NewDefaultStatefulSetControl</code> 定义：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDefaultStatefulSetControl returns a new instance of the default implementation StatefulSetControlInterface that</span></span><br><span class="line"><span class="comment">// implements the documented semantics for StatefulSets. podControl is the PodControlInterface used to create, update,</span></span><br><span class="line"><span class="comment">// and delete Pods and to create PersistentVolumeClaims. statusUpdater is the StatefulSetStatusUpdaterInterface used</span></span><br><span class="line"><span class="comment">// to update the status of StatefulSets. You should use an instance returned from NewRealStatefulPodControl() for any</span></span><br><span class="line"><span class="comment">// scenario other than testing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultStatefulSetControl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">// 管理 Sts 对应的 Pod 的接口</span></span></span><br><span class="line"><span class="function"><span class="params">podControl StatefulPodControlInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">// 管理 Sts 的  Status 的更新接口</span></span></span><br><span class="line"><span class="function"><span class="params">statusUpdater StatefulSetStatusUpdaterInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">// 管理 ControllerRevision 的接口</span></span></span><br><span class="line"><span class="function"><span class="params">controllerHistory history.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">// 事件记录器接口</span></span></span><br><span class="line"><span class="function"><span class="params">recorder record.EventRecorder)</span> <span class="title">StatefulSetControlInterface</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;defaultStatefulSetControl&#123;podControl, statusUpdater, controllerHistory, recorder&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Run-函数执行过程"><a href="#Run-函数执行过程" class="headerlink" title="Run 函数执行过程"></a><code>Run</code> 函数执行过程</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run runs the statefulset controller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">Run</span><span class="params">(workers <span class="keyword">int</span>, stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"><span class="keyword">defer</span> ssc.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">klog.Infof(<span class="string">&quot;Starting stateful set controller&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> klog.Infof(<span class="string">&quot;Shutting down statefulset controller&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !cache.WaitForNamedCacheSync(<span class="string">&quot;stateful set&quot;</span>, stopCh, ssc.podListerSynced, ssc.setListerSynced, ssc.pvcListerSynced, ssc.revListerSynced) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> wait.Until(ssc.worker, time.Second, stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-stopCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处关注下 <code>wait.Until</code> 工具：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Until loops until stop channel is closed, running f every period.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Until is syntactic sugar on top of JitterUntil with zero jitter factor and</span></span><br><span class="line"><span class="comment">// with sliding = true (which means the timer for period starts after the f</span></span><br><span class="line"><span class="comment">// completes).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Until</span><span class="params">(f <span class="keyword">func</span>()</span>, <span class="title">period</span> <span class="title">time</span>.<span class="title">Duration</span>, <span class="title">stopCh</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125;) &#123;</span><br><span class="line">JitterUntil(f, period, <span class="number">0.0</span>, <span class="literal">true</span>, stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过注释可以知道， <code>Until</code> 工具会根据 <code>channel</code> 的关闭来周期性的执行函数 <code>f</code>。<br>主要解决的是当我们执行完某些操作后，还需要等待其他资源执行的情况，例如对于有依赖条件的资源释放的时候，<code>A</code> 依赖于 <code>B</code>，那么对 <code>A</code> 资源释放的时候还需要对 <code>B</code> 资源的释放进行观望。这在 <code>k8s</code> 的资源操作场景是常见的。</p><p>继续关注 <code>wait.Until</code> 中包的函数 <code>ssc.worker</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker runs a worker goroutine that invokes processNextWorkItem until the controller&#x27;s queue is closed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ssc.processNextWorkItem() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>worker</code> 通过运行一个 <code>goroutine</code> 来处理 <code>processNextWorkItem</code> 直到 <code>controller</code> 相关的 <code>queue</code> 被关闭。</p><p>毫无疑问，需要分析 <code>processNextWorkItem()</code> 对应函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processNextWorkItem dequeues items, processes them, and marks them done. It enforces that the syncHandler is never</span></span><br><span class="line"><span class="comment">// invoked concurrently with the same key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">key, quit := ssc.queue.Get()</span><br><span class="line"><span class="keyword">if</span> quit &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ssc.queue.Done(key)</span><br><span class="line"><span class="comment">// 其它语义很容易理解，需要关注的是 ssc.sync() 函数</span></span><br><span class="line"><span class="keyword">if</span> err := ssc.sync(key.(<span class="keyword">string</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error syncing StatefulSet %v, requeuing: %v&quot;</span>, key.(<span class="keyword">string</span>), err))</span><br><span class="line">ssc.queue.AddRateLimited(key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ssc.queue.Forget(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>processNextWorkItem()</code> 主要用于对 <code>queue</code> 的元素出队,并标记为已处理。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync syncs the given statefulset.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">sync</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">startTime := time.Now()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Finished syncing statefulset %q (%v)&quot;</span>, key, time.Since(startTime))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对缓存中的 key 进行 split操作</span></span><br><span class="line">namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对缓存根据 namespace 及 name 进行 get 操作</span></span><br><span class="line">set, err := ssc.setLister.StatefulSets(namespace).Get(name)</span><br><span class="line"><span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">klog.Infof(<span class="string">&quot;StatefulSet has been deleted %v&quot;</span>, key)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;unable to retrieve StatefulSet %v from store: %v&quot;</span>, key, err))</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 sts 的 selector</span></span><br><span class="line">selector, err := metav1.LabelSelectorAsSelector(set.Spec.Selector)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;error converting StatefulSet %v selector: %v&quot;</span>, key, err))</span><br><span class="line"><span class="comment">// This is a non-transient error, so don&#x27;t retry.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ssc.adoptOrphanRevisions 检查是否有孤儿 controllerrevisions 对象，若有且能匹配 selector 的则添加 ownerReferences 进行关联，已关联但 label 不匹配的则进行释放。</span></span><br><span class="line"><span class="keyword">if</span> err := ssc.adoptOrphanRevisions(set); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ssc.getPodsForStatefulSet 通过 selector 获取 sts 关联的 pod，若有孤儿 pod 的 label 与 sts 的能匹配则进行关联，若已关联的 pod label 有变化则解除与 sts 的关联关系。</span></span><br><span class="line">pods, err := ssc.getPodsForStatefulSet(set, selector)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行真正的 sync 操作</span></span><br><span class="line"><span class="keyword">return</span> ssc.syncStatefulSet(set, pods)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syncStatefulSet</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncStatefulSet syncs a tuple of (statefulset, []*v1.Pod).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *StatefulSetController)</span> <span class="title">syncStatefulSet</span><span class="params">(set *apps.StatefulSet, pods []*v1.Pod)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Syncing StatefulSet %v/%v with %d pods&quot;</span>, set.Namespace, set.Name, <span class="built_in">len</span>(pods))</span><br><span class="line"><span class="keyword">var</span> status *apps.StatefulSetStatus</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> investigate where we mutate the set during the update as it is not obvious.</span></span><br><span class="line"><span class="comment">// 中仅仅是调用了 ssc.control.UpdateStatefulSet 方法进行处理。</span></span><br><span class="line">status, err = ssc.control.UpdateStatefulSet(set.DeepCopy(), pods)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;Successfully synced StatefulSet %s/%s successful&quot;</span>, set.Namespace, set.Name)</span><br><span class="line"><span class="comment">// One more sync to handle the clock skew. This is also helping in requeuing right after status update</span></span><br><span class="line"><span class="keyword">if</span> utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetMinReadySeconds) &amp;&amp; set.Spec.MinReadySeconds &gt; <span class="number">0</span> &amp;&amp; status != <span class="literal">nil</span> &amp;&amp; status.AvailableReplicas != *set.Spec.Replicas &#123;</span><br><span class="line">ssc.enqueueSSAfter(set, time.Duration(set.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UpdateStatefulSet</code>：</p><ol><li>获取历史 <code>revisions</code>；</li><li>计算 <code>currentRevision</code> 和 <code>updateRevision</code>，若 <code>sts</code> 处于更新过程中则 <code>currentRevision</code> 和 <code>updateRevision</code> 值不同；</li><li>调用 <code>ssc.performUpdate</code> 执行实际的 <code>sync</code> 操作；</li><li>调用 <code>ssc.updateStatefulSetStatus</code> 更新 <code>status subResource</code>；</li><li>根据 <code>sts</code> 的 <code>spec.revisionHistoryLimit</code> 字段清理过期的 <code>controllerrevision</code>；</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *defaultStatefulSetControl)</span> <span class="title">UpdateStatefulSet</span><span class="params">(set *apps.StatefulSet, pods []*v1.Pod)</span> <span class="params">(*apps.StatefulSetStatus, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取 revisions 并排序</span></span><br><span class="line">revisions, err := ssc.ListRevisions(set)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">history.SortControllerRevisions(revisions)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 Revison</span></span><br><span class="line">currentRevision, updateRevision, status, err := ssc.performUpdate(set, pods, revisions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, utilerrors.NewAggregate([]error&#123;err, ssc.truncateHistory(set, pods, revisions, currentRevision, updateRevision)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除过期的历史版本</span></span><br><span class="line"><span class="keyword">return</span> status, ssc.truncateHistory(set, pods, revisions, currentRevision, updateRevision)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ssc *defaultStatefulSetControl)</span> <span class="title">performUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">set *apps.StatefulSet, pods []*v1.Pod, revisions []*apps.ControllerRevision)</span> <span class="params">(*apps.ControllerRevision, *apps.ControllerRevision, *apps.StatefulSetStatus, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> currentStatus *apps.StatefulSetStatus</span><br><span class="line"><span class="comment">// get the current, and update revisions</span></span><br><span class="line">currentRevision, updateRevision, collisionCount, err := ssc.getStatefulSetRevisions(set, revisions)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentRevision, updateRevision, currentStatus, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的 update 操作</span></span><br><span class="line">currentStatus, err = ssc.updateStatefulSet(set, currentRevision, updateRevision, collisionCount, pods)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentRevision, updateRevision, currentStatus, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update  status</span></span><br><span class="line">err = ssc.updateStatefulSetStatus(set, currentStatus)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> currentRevision, updateRevision, currentStatus, err</span><br><span class="line">&#125;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;StatefulSet %s/%s pod status replicas=%d ready=%d current=%d updated=%d&quot;</span>,</span><br><span class="line">set.Namespace,</span><br><span class="line">set.Name,</span><br><span class="line">currentStatus.Replicas,</span><br><span class="line">currentStatus.ReadyReplicas,</span><br><span class="line">currentStatus.CurrentReplicas,</span><br><span class="line">currentStatus.UpdatedReplicas)</span><br><span class="line"></span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;StatefulSet %s/%s revisions current=%s update=%s&quot;</span>,</span><br><span class="line">set.Namespace,</span><br><span class="line">set.Name,</span><br><span class="line">currentStatus.CurrentRevision,</span><br><span class="line">currentStatus.UpdateRevision)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> currentRevision, updateRevision, currentStatus, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateStatefulSet</code>：</p><pre><code class="golang">// 作为updateStatefulSet的核心方法，重试保障Statefulset到达期望状态，update策略主要分为三类：// 1.RollingUpdateStatefulSetStrategyType// 2.OnDeleteStatefulSetStrategyType// 3.PartitionStatefulSetStrategyTypefunc (ssc *defaultStatefulSetControl) updateStatefulSet(    set *apps.StatefulSet,    currentRevision *apps.ControllerRevision,    updateRevision *apps.ControllerRevision,    collisionCount int32,    pods []*v1.Pod) (*apps.StatefulSetStatus, error) &#123;    ...    // 获取当前和更新的 Revision    currentSet, err := ApplyRevision(set, currentRevision)    ...    // 构建 sts 对象    currentSet, err := ApplyRevision(set, currentRevision)    ...    // 构建 sts 对象    updateSet, err := ApplyRevision(set, updateRevision)    ...    // status 赋值    status := apps.StatefulSetStatus&#123;&#125;    status.ObservedGeneration = set.Generation    status.CurrentRevision = currentRevision.Name    status.UpdateRevision = updateRevision.Name    status.CollisionCount = new(int32)    *status.CollisionCount = collisionCount    // replicas 存放  Pods such that 0 &lt;= getOrdinal(pod) &lt; set.Spec.Replicas    replicas := make([]*v1.Pod, replicaCount)    // condemned 存放  Pods such that set.Spec.Replicas &lt;= getOrdinal(pod)    condemned := make([]*v1.Pod, 0, len(pods))    ...    // 对 pods 进行处理分别存放到 replicas  和 condemned 切片中    for i := range pods &#123;        status.Replicas++        // 统计 running 和 ready 的副本数        if isRunningAndReady(pods[i]) &#123;            status.ReadyReplicas++            // 对门控是否开启特性的判断            if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetMinReadySeconds) &#123;                if isRunningAndAvailable(pods[i], set.Spec.MinReadySeconds) &#123;                    status.AvailableReplicas++                &#125;            &#125; else &#123;                // 如果门控特性未开启，那么所有ready 的副本数将被认为是可用状态的副本数                status.AvailableReplicas = status.ReadyReplicas            &#125;        &#125;        // 统计 current 和 update 的副本数        if isCreated(pods[i]) &amp;&amp; !isTerminating(pods[i]) &#123;            if getPodRevision(pods[i]) == currentRevision.Name &#123;                status.CurrentReplicas++            &#125;            if getPodRevision(pods[i]) == updateRevision.Name &#123;                status.UpdatedReplicas++            &#125;        &#125;        if ord := getOrdinal(pods[i]); 0 &lt;= ord &amp;&amp; ord &lt; replicaCount &#123;            // replicas 的赋值            replicas[ord] = pods[i]        &#125; else if ord &gt;= replicaCount &#123;            // condemned 的赋值            condemned = append(condemned, pods[i])        &#125;    &#125;    // 检查 replicas数组中 [0,set.Spec.Replicas) 下标是否有缺失的 pod，若有缺失的则创建对应的 pod object     // 在 newVersionedStatefulSetPod 中会判断是使用 currentSet 还是 updateSet 来创建    for ord := 0; ord &lt; replicaCount; ord++ &#123;        if replicas[ord] == nil &#123;            replicas[ord] = newVersionedStatefulSetPod(                currentSet,                updateSet,                currentRevision.Name,                updateRevision.Name, ord)        &#125;    &#125;    // 对 condemned 数组进行排序     sort.Sort(ascendingOrdinal(condemned))    // 根据 ord 在 replicas 和 condemned 数组中找出 first unhealthy Pod    for i := range replicas &#123;        if !isHealthy(replicas[i]) &#123;            unhealthy++            if firstUnhealthyPod == nil &#123;                firstUnhealthyPod = replicas[i]            &#125;        &#125;    &#125;    for i := range condemned &#123;        if !isHealthy(condemned[i]) &#123;            unhealthy++            if firstUnhealthyPod == nil &#123;                firstUnhealthyPod = condemned[i]            &#125;        &#125;    &#125;    if unhealthy &gt; 0 &#123;        klog.V(4).Infof(&quot;StatefulSet %s/%s has %d unhealthy Pods starting with %s&quot;,            set.Namespace,            set.Name,            unhealthy,            firstUnhealthyPod.Name)    &#125;    // 判断 set 是否处于 deleting     if set.DeletionTimestamp != nil &#123;        return &amp;status, nil    &#125;    // 默认设置为非并行模式    monotonic := !allowsBurst(set)    // 确保 replicas 数组中的所有 pod 都是 running 状态    for i := range replicas &#123;        // 删除和重建失败的 pods        if isFailed(replicas[i]) &#123;            ssc.recorder.Eventf(set, v1.EventTypeWarning, &quot;RecreatingFailedPod&quot;,                &quot;StatefulSet %s/%s is recreating failed Pod %s&quot;,                set.Namespace,                set.Name,                replicas[i].Name)            if err := ssc.podControl.DeleteStatefulPod(set, replicas[i]); err != nil &#123;                return &amp;status, err            &#125;            if getPodRevision(replicas[i]) == currentRevision.Name &#123;                status.CurrentReplicas--            &#125;            if getPodRevision(replicas[i]) == updateRevision.Name &#123;                status.UpdatedReplicas--            &#125;            status.Replicas--            replicas[i] = newVersionedStatefulSetPod(                currentSet,                updateSet,                currentRevision.Name,                updateRevision.Name,                i)        &#125;        // 如果 pod 未被创建则进行创建        if !isCreated(replicas[i]) &#123;            if err := ssc.podControl.CreateStatefulPod(set, replicas[i]); err != nil &#123;                return &amp;status, err            &#125;            status.Replicas++            if getPodRevision(replicas[i]) == currentRevision.Name &#123;                status.CurrentReplicas++            &#125;            if getPodRevision(replicas[i]) == updateRevision.Name &#123;                status.UpdatedReplicas++            &#125;            // if the set does not allow bursting, return immediately            if monotonic &#123;                return &amp;status, nil            &#125;            // pod created, no more work possible for this round            continue        &#125;        // 当 pod 处于 terminating 状态的时候且不允许并行的情况下 则进行等待删除完成        if isTerminating(replicas[i]) &amp;&amp; monotonic &#123;            klog.V(4).Infof(                &quot;StatefulSet %s/%s is waiting for Pod %s to Terminate&quot;,                set.Namespace,                set.Name,                replicas[i].Name)            return &amp;status, nil        &#125;        // 当 pod 已经被创建且不运行并行的情况下，状态并不是 running 和 ready 状态的处理。        if !isRunningAndReady(replicas[i]) &amp;&amp; monotonic &#123;            klog.V(4).Infof(                &quot;StatefulSet %s/%s is waiting for Pod %s to be Running and Ready&quot;,                set.Namespace,                set.Name,                replicas[i].Name)            return &amp;status, nil        &#125;        // pod creates 成功但是并不是可用状态时的处理。        if utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetMinReadySeconds) &amp;&amp; !isRunningAndAvailable(replicas[i], set.Spec.MinReadySeconds) &amp;&amp; monotonic &#123;            klog.V(4).Infof(                &quot;StatefulSet %s/%s is waiting for Pod %s to be Available&quot;,                set.Namespace,                set.Name,                replicas[i].Name)            return &amp;status, nil        &#125;        // 对 sts 的唯一性及相关存储唯一性的检查        if identityMatches(set, replicas[i]) &amp;&amp; storageMatches(set, replicas[i]) &#123;            continue        &#125;        ...    &#125;&#125;至此结束。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对于分析 &lt;code&gt;Controller&lt;/code&gt; 源码选用 &lt;code&gt;StatefulSet Controller&lt;/code&gt; 来，其它控制器源码分析一个套路，可以做参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;State</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="源码分析" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="Controller" scheme="http://kiragoo.github.com/tags/Controller/"/>
    
    <category term="StatefulSet" scheme="http://kiragoo.github.com/tags/StatefulSet/"/>
    
    <category term="源码分析" scheme="http://kiragoo.github.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes之编写Controller</title>
    <link href="http://kiragoo.github.com/archives/a66802dc.html"/>
    <id>http://kiragoo.github.com/archives/a66802dc.html</id>
    <published>2021-10-14T03:50:53.000Z</published>
    <updated>2022-04-21T12:46:07.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://github.com/kubernetes/community/blob/8cafef897a22026d42f5e5bb3f104febe7e29830/contributors/devel/controllers.md">Writing Controllers</a></p></blockquote><h1 id="Writing-Controller"><a href="#Writing-Controller" class="headerlink" title="Writing Controller"></a><code>Writing Controller</code></h1><p><code>Kubernetes Controller</code> 是个“常驻调谐进程”。它除了会“监视”对象的期望状态外，也会“监视”对象的运行状态。会通过发送“指令”尝试着将对象的运行状态更加趋近于期望状态。</p><p>如下是个简单的 <code>loop</code> 循环:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  desired := getDesiredState()</span><br><span class="line">  current := getCurrentState()</span><br><span class="line">  makeChanges(desired, current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Guidelines"><a href="#Guidelines" class="headerlink" title="Guidelines"></a><code>Guidelines</code></h1><p>当我们写 <code>Controller</code> 的时候，有如下知道方针来帮助我们实现我们想要的结果和表现。</p><ol><li><strong>一次之操作一个元素</strong>。 如果你使用 <code>workqueue.Interface</code>，你将能够将一个具体的<code>Resource</code>入队，然后稍后将它们 <code>pop</code> 到 <code>worker gofuncs</code>，此处需要保证的是同一时间不能有多个 <code>gofuncs</code> 处理同一个元素。</li></ol><p><code>Controllers</code> 会引发多个 <code>Resource</code> 之前的关联关系（例如 Y 发生改变了 我需要检查 X），但是几乎所有的 <code>Controller</code> 会基于 <code>relationships</code> 将检查X的所有放入到队列中。例如，<code>RepicaSet Controller</code> 需要对正在进行删除 <code>pod</code> 做出反应，但是它需要发现关联的<code>RepicaSets</code> 并且对此做出入队。</p><ol start="2"><li><strong><code>Resources</code> 随件排序</strong>。当 <code>queue off</code> 多种 <code>resources</code> 的时候，将不会保证这些 <code>resources</code> 的顺序。</li></ol><p>“监视” 将会实时的进行更新，即使在明显顺序如“create resource A/X”，“create resource B/Y”，<code>Controller</code> 也许注意到的为 <code>create resource B/Y</code>，<code>create resource A/X</code>。</p><ol start="3"><li><strong>水平驱逐而不是边缘驱逐</strong>。比如某个 <code>shell</code> 脚本没有一直运行，你的 <code>controller</code> 将再重新运行该 <code>shell</code> 之间“休眠”不确定时间。</li></ol><p>如果某个 <code>API</code> 对象出现某个 <code>marker</code> 为 <code>true</code>，你也无法判断出它是由 <code>false</code> 变成 <code>true</code> 的，你只能知道它当前为 <code>true</code>。即使 <code>API</code> “监视”深受其害，所以你将无法对此看出变化，除非你的 <code>controller</code> 在对象的 <code>status</code> 中记录相关信息。</p><ol start="4"><li>**<code>SharedInformers</code>**。<code>SharedInformers</code> 提供对具体 <code>resource</code> 的添加、更新、删除事件的钩子。同时提供对共享缓存便利性的函数访问。</li></ol><p>使用 <a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/factory.go">https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/informers/factory.go</a> 工厂方法来保证使用相同的缓存实例。</p><p>这可以使的我们不使用 <code>API server</code>， 重复序列化会消耗服务端资源，重复反序列化会消耗控制器资源以及重复缓存会也会消耗控制器资源。</p><p>你也许发现其他的机制比如 <code>reflectors</code> 和 <code>deltafifos</code> 驱动控制器。 这些已是陈旧的机制，后续我们将构建 <code>SharedInformers</code>。你需要避免在新的控制器中使用这些。</p><ol start="5"><li><strong>切勿转换原始对象</strong>。 控制器建通过缓存来进行共享，这就意味着如果你转换了 <em>“拷贝”</em> 对象，你将使得其与其他的控制器混肴了。</li></ol><p>最常见的就是通过 <em>“浅拷贝”</em> 然后对 <code>map</code> 进行转换导致失败，比如对 <code>Annotations</code>。</p><ol start="6"><li><strong>二级缓存</strong>。许多控制器拥有一级资源和二级资源。一级资源对应着那些我们将要更新 <code>Status</code> 的原始对象资源。二级资源对应着将要管理的对象。</li></ol><p>在启用一级更新操作之前使用 <code>framework.WaitFirCacheSync</code> 来等待二级缓存。</p><ol start="7"><li><strong>系统中的其他因素</strong>。因为你没更新对象并不意味着没有其他人更新对象。</li></ol><p>不要忘记当前状态会在任意时刻发生更新–仅仅观察期望的状态是不够的。如果你使用在期望状态下的对象缺失来提示当前状态下的东西被删除，请确保你的可观察代码中没有错误（例如，在你的缓存填充之前进行处理）。</p><ol start="8"><li><strong>过滤错误到顶层以保持一直的重新队列</strong>。我们采用 <code>workqueue.RateLimitingInterface</code> 来允许简单的排队与合理的回退。</li></ol><p>当在排队时，你的主控制器返回结果应该包含 <code>error</code>。当不存在错误时，则应该使用 <code>utilruntime.HandleEroor</code> 并且以返回 <code>nil</code> 代替它。这使的审核人员能够容易地检查错误处理情况，并确信控制器不会丢失它应该重试处理的内容。</p><ol start="9"><li>**<code>Watches、Informers 将会同步</code>**。他们会定期的将集群中匹配的对象进行 <code>Update</code> 更新。这对于你可能需要对对象采取额外的操作是很好的，但是大多数情况下你知道不会存在较多的额外工作。</li></ol><p>你可以通过比对新旧对象中的资源版本来判断他们是否发生变化来决定是否需要进行再次入队处理。如果它们是相同的则跳过重新入队的工作环节。需要你注意的是，如果你曾经在再次入队的时候失败了，应该是失败处理而不是再次入队，并且不要再对它们进行重试。</p><ol start="10"><li>如果你的控制器协调的一级资源在其 <code>Status</code> 中支持 <code>ObservedGeneration</code>，请确保其正确的设置为 <code>MetaData</code> 元数据。当两个字段间不匹配的时候进行生成。</li></ol><p>这将让客户端知道控制器在处理资源。确保你的控制器是负责此资源的，否则如果你需要通过自己的控制器与其通信，你将需要在资源的<code>Status</code> 中创建一个不同类型的<code>ObservedGeneration</code>。</p><ol start="11"><li>考虑到资源创建时对其他资源的所有者引用（例如，<code>ReplicaSet</code> 导致创建 <code>Pods</code>）。因此你得确保被控制器管理的资源被删除时那些依赖的子资源能够很好的呗回收处理。关于所有者引用的更多明细，请参考<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/controller-ref.md">这里</a>。</li></ol><p>需要特别注意的是，当父资源或者子资源被标机为删除时，你不应该采用子资源。如果你对资源使用了缓存，你最好通过直接的 <code>API</code> 绕过缓存，以防你观察到的某个资源的所有者引用已被更新。所以你可以确保你的控制器不会与垃圾回收期产生竞争。</p><p>查看<a href="https://github.com/kubernetes/kubernetes/pull/42938">k8s.io/kubernetes/pull/42938</a>获取更多的细节。</p><h1 id="Rough-Structure"><a href="#Rough-Structure" class="headerlink" title="Rough Structure"></a><code>Rough Structure</code></h1><p><code>Controller</code> 大概如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// podLister is secondary cache of pods which is used for object lookups</span></span><br><span class="line">    podLister cache.StoreToPodLister</span><br><span class="line"></span><br><span class="line">    <span class="comment">// queue is where incoming work is placed to de-dup and to allow &quot;easy&quot;</span></span><br><span class="line">    <span class="comment">// rate limmited requeues on errors</span></span><br><span class="line">    queue workqueue.RateLimitingInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">Run</span><span class="params">(threadiness <span class="keyword">int</span>, stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// don&#x27;t let panics crash the process</span></span><br><span class="line">    <span class="keyword">defer</span> utilruntime.HandleCrash()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure the work queue is shutdown which will trigger workers to end</span></span><br><span class="line">    <span class="keyword">defer</span> c.queue.ShutDown()</span><br><span class="line"></span><br><span class="line">    glog.Infof(<span class="string">&quot;Starting &lt;NAME&gt; controller&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for your secondary caches to fill before starting your work</span></span><br><span class="line">    <span class="keyword">if</span> !framework.WaitFirCacheSync(stopCh, c.PodStoreSunced) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start up your worker threads based on threadiness. Some controllers</span></span><br><span class="line">    <span class="comment">// have multiple kinds of workers</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;threadiness;i++&#123;</span><br><span class="line">        <span class="comment">// runWorker will loop until &quot;something bad&quot; happens. The .Until will</span></span><br><span class="line">        <span class="comment">// then rekick the worker after one second</span></span><br><span class="line">        <span class="keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait until we&#x27;re told to stop</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line">    glog.Infof(<span class="string">&quot;Shutting down &lt;NAME&gt; controller&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">runWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// hot loop until we&#x27;re told to stop. processNextWorkItem will</span></span><br><span class="line">    <span class="comment">// automatically wait until there&#x27;s work available, so we don&#x27;t worry </span></span><br><span class="line">    <span class="comment">// about secondary waits</span></span><br><span class="line">    <span class="keyword">for</span> c.processNextWorkItem() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// processNextWorkItem deals with one key off the queue. It returns false</span></span><br><span class="line"><span class="comment">// when it&#x27;s time to quit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">processNextWorkItem</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// pull the next work item from queue. It should be a key we use to lookup</span></span><br><span class="line">    <span class="comment">// something in a cache</span></span><br><span class="line">    key, quit := c.queue.Get()</span><br><span class="line">    <span class="keyword">if</span> quit &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// you always have to indicate to the queue that you&#x27;ve completed a piece of </span></span><br><span class="line">    <span class="comment">// work</span></span><br><span class="line">    <span class="keyword">defer</span> c.queue.Done(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do your work on the key. This method will contains your &quot;do stuff&quot; logic</span></span><br><span class="line">    err := c.syncHandler(key.(<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// if you had no error, thll the queue to stop tracking history for your</span></span><br><span class="line">        <span class="comment">// key. This will reset things like failuer counts for per-item rate</span></span><br><span class="line">        <span class="comment">// limiting</span></span><br><span class="line">        c.queue.Forget(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// there was a failure so be sure to report it. This method allows for </span></span><br><span class="line">    <span class="comment">// pluggable error handling which can be used for things like</span></span><br><span class="line">    <span class="comment">// cluster-monitoring</span></span><br><span class="line">    utilruntime.HandleError(fmt.Errorf(<span class="string">&quot;%v failed with : %v&quot;</span>, key, err))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since we failed, we should requeue the item to work on later. This</span></span><br><span class="line">    <span class="comment">// method will add a backoff to avoid hotlooping on particular items</span></span><br><span class="line">    <span class="comment">// (they&#x27;re probably still not going to work right away) and overall</span></span><br><span class="line">    <span class="comment">// controller protection (everything I&#x27;ve done is broken, this controller</span></span><br><span class="line">    <span class="comment">// needs to calm down or it can starve other usefull work) cases.</span></span><br><span class="line">    c.queue.AddRateLimited(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;翻译自&lt;a href=&quot;https://github.com/kubernetes/community/blob/8cafef897a22026d42f5e5bb3f104febe7e29830/contributors/devel/control</summary>
      
    
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/categories/Kubernetes/"/>
    
    <category term="Controller" scheme="http://kiragoo.github.com/categories/Kubernetes/Controller/"/>
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/tags/Kubernetes/"/>
    
    <category term="Controller" scheme="http://kiragoo.github.com/tags/Controller/"/>
    
  </entry>
  
  <entry>
    <title>PersistentVolumnes 单Pod 访问模式</title>
    <link href="http://kiragoo.github.com/archives/96e8d00f.html"/>
    <id>http://kiragoo.github.com/archives/96e8d00f.html</id>
    <published>2021-09-28T03:08:05.000Z</published>
    <updated>2022-04-21T12:46:07.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译自<a href="https://kubernetes.io/blog/2021/09/13/read-write-once-pod-access-mode-alpha/">Introducing Single Pod Access Mode for PersistentVolumes</a></p></blockquote><h1 id="访问模式及重要意义"><a href="#访问模式及重要意义" class="headerlink" title="访问模式及重要意义"></a>访问模式及重要意义</h1><p>当使用持久化储存时，对于存储有多种模式进行访问使用。</p><p>例如，存储系统中的网络文件可以同时被多个用户进行读写数据。在另一种场景下，也许每个用户允许进行读而不具备写的权限。对于高敏数据，可能只允许一个用户用户进行读写操作而不是所有的用户。</p><p>在 <code>Kubernetes</code> 的世界中，<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes"><code>access mode</code></a>就是我们定义持久化存储如何使用的方式。这些访问方式作为 <code>PVs</code> 和 <code>PVCs</code> 中 <code>spec</code> 描述的一部分内容。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">shared-cache</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span> <span class="comment"># Allow many pods to access shared-cache simultaneously.</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure><p>在 <code>v1.22</code> 版本之前， <code>Kubernetes</code> 为 <code>PVs</code> 和 <code>PVCs</code>提供如下三种访问模式:</p><ul><li><code>ReadWriteOnce</code> - <code>volume</code> 只允许被单个 <strong><code>node</code></strong> 进行读写</li><li><code>ReadOnlyMany</code> - <code>volume</code> 允许被多个 <strong><code>node</code></strong> 进行读操作</li><li><code>ReadWriteMany</code> - <code>volume</code> 允许被多个 <strong><code>node</code></strong> 进行读写操作</li></ul><p>这些访问模式通过 <code>Kubernetes</code> 组件如 <code>kube-controller-manager</code> 和 <code>kubelet</code> 来保证相应的 <code>Pods</code> 能够访问所应用的 <code>PersistentVolume</code>.</p><h1 id="新的访问模式及运行原理"><a href="#新的访问模式及运行原理" class="headerlink" title="新的访问模式及运行原理"></a>新的访问模式及运行原理</h1><p><code>Kubernetes v1.22</code> 介绍了 <code>PVs</code> 和 <code>PVCs</code> 的第四种访问模式：</p><ul><li><code>ReadWriteOncePod</code> - <code>volume</code> 允许单个 <strong><code>Pod</code></strong> 进行读写操作</li></ul><p>如果你对使用了 <code>PVC</code> 的 <code>Pod</code> 配置了 <code>ReadWriteOncePod</code> 的访问模式，<code>Kubernetes</code> 将确保此 <code>Pod</code> 是集群中唯一能够对此 <code>PVC</code> 进行读写的唯一 <code>Pod</code>.</p><p>如果你将另一个 <code>Pod</code> 对同一个 <code>PVC</code> 进行配置关联且也是配置了此访问模式，那么此 <code>Pod</code> 将无法启动，因为此 <code>PVC</code> 已经被另一个 <code>Pod</code> 使用了。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type     Reason            Age   From               Message</span><br><span class="line">  ----     ------            ----  ----               -------</span><br><span class="line">  Warning  FailedScheduling  1s    default-scheduler  0/1 nodes are available: 1 node has pod using PersistentVolumeClaim with the same name and ReadWriteOncePod access mode.</span><br></pre></td></tr></table></figure><h2 id="此访问模式与-ReadWriteOnce-的区别？"><a href="#此访问模式与-ReadWriteOnce-的区别？" class="headerlink" title="此访问模式与 ReadWriteOnce 的区别？"></a>此访问模式与 <code>ReadWriteOnce</code> 的区别？</h2><p><code>ReadWriteOnce</code> 访问模式约束 <code>volume</code> 对应单个 <code>node</code>，这意味着在同一个节点上的多个 <code>Pods</code> 能够读写通过一个 <code>volume</code>。对于某些应用此访问模式可能是个潜在的重大问题，尤其是对那些要求至多要求保证只有一个数据写入而言。</p><p>对 <code>PVC</code> 设置 <code>ReadWriteOncePod</code> 访问策略，那么 <code>Kubernetes</code> 将保证只有一个 <code>Pod</code> 能够进行访问。</p><h1 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h1><p><code>ReadWriteOncePod</code> 访问模式在 <code>v1.22</code> 版本中是 <code>alpha</code> 版本，并且支持 <code>CSI volume</code>。首先你得在 <code>kube-apiserver</code>, <code>kube-scheduler</code>, <code>kubelet</code> 中开启对 <code>ReadWriteOncePod</code> 的<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates">特性</a>。你可以通过设置如下命令行参数进行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--feature-gates=<span class="string">&quot;...,ReadWriteOncePod=true&quot;</span></span><br><span class="line"></span><br><span class="line">另外你的将如下 `CSI sidecars` 升级到如下版本或更高：</span><br><span class="line">- [csi-provisioner:v3.0.0+](https://github.com/kubernetes-csi/external-provisioner/releases/tag/v3.0.0)</span><br><span class="line">- [csi-attacher:v3.3.0+](https://github.com/kubernetes-csi/external-attacher/releases/tag/v3.3.0)</span><br><span class="line">- [csi-resizer:v1.3.0+](https://github.com/kubernetes-csi/external-resizer/releases/tag/v1.3.0)</span><br></pre></td></tr></table></figure><h2 id="创建-PersistentVolumeClaim"><a href="#创建-PersistentVolumeClaim" class="headerlink" title="创建 PersistentVolumeClaim"></a>创建 <code>PersistentVolumeClaim</code></h2><p>对 <code>PVs</code> 和 <code>PVCs</code> 使用 <code>ReadWriteOncePod</code> 访问模式，你需创建一个新的 <code>PVC</code> 配置如下的访问模式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">single-writer-only</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOncePod</span> <span class="comment"># Allow only a single pod to access single-writer-only.</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure><p>如果你的存储插件支持 <a href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/"><code>dynamic provisioning</code></a>，新的 <code>PersistentVolumes</code> 将会应用<code>ReadWriteOncePod</code>访问模式。</p><h2 id="迁移已有的-PersistentVolumes"><a href="#迁移已有的-PersistentVolumes" class="headerlink" title="迁移已有的 PersistentVolumes"></a>迁移已有的 <code>PersistentVolumes</code></h2><p>如果你已经有了存在的 <code>PersistentVolumes</code>，也可以将它们迁移使用 <code>ReadWriteOncePod</code> 访问模式。</p><p>在此例子中，我们已经拥有了与 <code>cat-pictures-pv</code> 绑定的 <code>cat-pictures-pvc PersistentVolumeClaim</code>，另外 <code>cat-pictures-writer Deployment</code> 已经使用了此 <code>PersistentVolumeClaim</code>。</p><p>第一步，你需要编辑你的 <code>PersistentVolume</code> 中的 <code>spec.persistentVolumeReclaimPolicy</code> 将其改为 **<code>Retain</code>**。这是为了保证当我们相关 <code>PersistentVolumeClaim</code> 的时候 <code>PersistentVolume</code> 将不会被删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch pv cat-pictures-pv -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;persistentVolumeReclaimPolicy&quot;:&quot;Retain&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>下一步你需要停止那些使用了你想做迁移的 <code>PersistentVolume</code> 想关联的 <code>PersistentVolumeClaim</code> 的工作平面，同事删除这些 <code>PersistentVolumeClaim</code>。</p><p>一旦如上步骤已经完成，你需要清除与你相关的 <code>PersistenVolume</code> 相关的 <code>spec.claimRef.uid</code> 字段内容，以便确保 <code>PersistentVolumeClaims</code> 能够在再次创建过程中能够被绑定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=0 deployment cat-pictures-writer</span><br><span class="line">kubectl delete pvc cat-pictures-pvc</span><br><span class="line">kubectl patch pv cat-pictures-pv -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;claimRef&quot;:&#123;&quot;uid&quot;:&quot;&quot;&#125;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>结束之后你需要将 <code>PersistentVolume</code> 的访问模式替换为 <code>ReadWriteOncePod</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch pv cat-pictures-pv -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;accessModes&quot;:[&quot;ReadWriteOncePod&quot;]&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Note</strong>：<code>ReadWriteOncePod</code> 访问模式无法与其他的访问模式进行结合使用。确保在更新 <code>PersistentVolume</code> 的时候 <code>ReadWriteOncePod</code>是唯一的访问模式，否则将会放生请求失败。</p></blockquote><p>下一步你的得将你的 <code>PersistentVolumeClaim</code> 修改为 <code>ReadWriteOncePod</code> 作为唯一的访问模式。同时你还得将配置 <code>PersistentVolumeClaim</code> 中的 <code>spec.volumeName</code> 对应到你的 <code>PersistentVolume</code>。</p><p>一旦以上步骤都已经完成，你可以重新创建你的 <code>PersistenVolumeClaim</code> 并且启动你的工作平面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># IMPORTANT: Make sure to edit your PVC in cat-pictures-pvc.yaml before applying. You need to:</span></span><br><span class="line"><span class="comment"># - Set ReadWriteOncePod as the only access mode</span></span><br><span class="line"><span class="comment"># - Set spec.volumeName to &quot;cat-pictures-pv&quot;</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f cat-pictures-pvc.yaml</span><br><span class="line">kubectl apply -f cat-pictures-writer-deployment.yaml</span><br></pre></td></tr></table></figure><p>最后你可能需要编辑的你的 <code>PersistentVolume</code> 中 <code>spec.persistentVolumeReclaimPolicy</code> 字段并将其配置为 <code>Delete</code> 如果你确实改动过它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch pv cat-pictures-pv -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;persistentVolumeReclaimPolicy&quot;:&quot;Delete&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>你可以阅读<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/">Configure a Pod to Use a PersistentVolume for Storage</a>了解更多的细节。</p>]]></content>
    
    
    <summary type="html">介绍与迁移示例</summary>
    
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/categories/Kubernetes/"/>
    
    <category term="PersistentVolumes" scheme="http://kiragoo.github.com/categories/Kubernetes/PersistentVolumes/"/>
    
    
    <category term="Kubernetes" scheme="http://kiragoo.github.com/tags/Kubernetes/"/>
    
    <category term="PersistentVolumes" scheme="http://kiragoo.github.com/tags/PersistentVolumes/"/>
    
  </entry>
  
  <entry>
    <title>深入理解k8s网络原理之-Service原理</title>
    <link href="http://kiragoo.github.com/archives/1d9c7e0d.html"/>
    <id>http://kiragoo.github.com/archives/1d9c7e0d.html</id>
    <published>2021-09-13T02:05:16.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>收集整理，转载自<a href="https://zhuanlan.zhihu.com/p/404837363">深入理解kubernetes（k8s）网络原理之二-service原理</a></p></blockquote><p>在<a href="https://kiragoo.github.io/archives/1d9a37c9.html">深入理解k8s网路原理之-POD连接主机</a>中主要介绍了<code>POD</code>与主机及<code>POD</code>访问外网的原理。</p><h2 id="Linux网络基础知识"><a href="#Linux网络基础知识" class="headerlink" title="Linux网络基础知识"></a><code>Linux</code>网络基础知识</h2><h3 id="netfilter"><a href="#netfilter" class="headerlink" title="netfilter"></a><code>netfilter</code></h3><p><code>netfileter</code>子系统5个关键扩展点：</p><ul><li><code>PREROUTING</code>，数据包刚到达时会经过这个点，通常用来完成DNAT的功能。</li><li><code>INPUT</code>，数据包要进入本机的传输层时会经过这个点，通常用来完成防火墙入站检测。</li><li><code>FORWARD</code>，数据包要通过本机转发时会经过这个点，通常用来完成防火墙转发过滤。</li><li><code>OUTPUT</code>，从本机的数据包要出去的时候会经过这个点，通常用来做DNAT和防火墙出站检测。</li><li><code>POSTROUTING</code>，数据包离开本机前会经过这个点，通常用来做SNAT。</li></ul><p><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/netfilter.drawio.png" alt="netfilter"><br>1、 主机的应用程序接收外部的数据包会经过的点: PREROUTING -&gt; INPUT</p><p>2、 主机的应用程序发送数据包到外部经过的点: OUTPUT -&gt; POSTROUTING</p><p>3、 主机的<code>POD</code>发送的数据包去外部或者去主机的另外一个<code>POD</code>: PREROUTING -&gt; FORWARD -&gt; POSTROUTING</p><blockquote><p>主机上运行的<code>POD</code>虽然也是主机上的一个进程，但是<code>POD</code>发送数据包出去的流程去和主机的其他进程不一样，由于<code>POD</code>在新的<code>NS</code>中，所以他的发包流程适合主机收到另一台主机的数据然后转发的流程是一样的。</p></blockquote><p>4、<strong>注意图中的<code>IPIsLocal</code>？的判断，如果数据包的目标<code>IP</code>是本机<code>IP</code>,则往<code>INPUT</code>点走，否则查看<code>net.ipv4.ip_forward</code>是否为1，是则往<code>FORWARD</code>走，0则丢弃。</strong></p><h3 id="iptables-基础知识"><a href="#iptables-基础知识" class="headerlink" title="iptables 基础知识"></a><code>iptables</code> 基础知识</h3><p><code>iptables</code> 初识别</p><p><code>iptables -A INPUT -t filter -s 192.168.1.10 -j DROP</code><br>意思是指不允许来源为<code>192.168.1.10</code>的<code>ip</code>访问本机的服务。</p><p>命令详解：</p><ul><li>-A 是指后面加一条规则,其他为<ul><li>-I 是前面加一条规则，优先级更高</li><li>-D 删除规则</li><li>-N 新增加链</li><li>-F 清除链上的所有规则或者所有链</li><li>-X 删除一条用户的自定义链</li><li>-P 更改链的默认策略</li><li>-L 真是指定链上的规则</li></ul></li><li>防火墙规则一般制工作在<code>INPUT/OUTPUT/FORWARD</code>三个扩展点</li><li>-t 指定当前命令操作所属的表，主要有：<ul><li><code>filter</code> 表，主要用于拦截或者房型，不修改包，如果不指定，则默认为<code>filter</code>表</li><li><code>nat</code> 表，用于修改<code>ip</code>包的源/目的地址</li><li><code>mangle</code> 表，用于给数据包打标记</li><li><code>raw</code> 表，#TODO</li><li><code>security</code> 表， #TODO</li></ul></li><li>-s 数据包的匹配规则，规则可以一个或者多个，多个是与的效果，这里 -s 是匹配来源的的意思，其他的还有<ul><li>-d 匹配目标地址</li><li>–sport 匹配来源端口</li><li>–dport 匹配目标端口</li><li>-p tcp 匹配协议类型</li></ul></li><li>-j <code>DROP</code>是执行的动作，这里是跳转到（<code>jump</code>）<code>DROP</code> 链，<code>iptables</code> 有几个预定义的链:<ul><li><code>DROP</code> 丢弃进入该链的包</li><li><code>ACCEPT</code> 接收进入该链的包</li><li><code>RETURN</code> 返回上一级链</li><li><code>SNAT</code> 源地址转换，要指定转换后的源地址</li><li><code>DNAT</code> 目标地址转换，要指定转换后目标地址</li><li><code>MASQUEREDE</code> 对进入该链的包进行源地址转换，与<code>SNAT</code> 类似，但不用指定具体的转换后的源地址，会自动应用网卡的地址作为原地址，通常都用这条链完成<code>SNAT</code>。<br>进阶示例：<br>— 把本机应用发往10.96.0.100的数据包的目标地址转换为10.244.3.10上，注意使要影响本机应用，</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A OUTPUT -t nat -d 10.96.0.100 -j DNAT --to-distination 10.244.3.10</span><br></pre></td></tr></table></figure><ul><li>上面的规则支队本机的应用程序发送的流量有影响， 对于本机的<code>POD</code>发出的流量乜有影响，如果要影响本机的<code>POD</code>，还要加一条，规则都一样，只是工作在<code>PREROUTING</code>链.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A RPEROTING -t nat -d 10.96.0.100 -j DNAT --to-distination 10.244.3.10</span><br></pre></td></tr></table></figure><ul><li>对本机发送的数据包中来源<code>ip</code> 为172.20.1.10 的数据包进行源地址伪装，注意修改源地址只有个一个点可以用，就是<code>POSTROUTING</code>，下面的规则就是配置<code>POD</code>上外网时使用的：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptabels -A POSTROUTING -t NAT -S 172.20.1.10 -j MASQUEREDE</span><br></pre></td></tr></table></figure><ul><li>允许来源<code>IP</code>为192.168.6.166并访问本机的<code>TCP</code>80 端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A  INPUT -t filter -s 192.168.8.166 -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><blockquote><p><code>iptables</code> 上的规则创建会有一些限制，如无法在<code>POSTROUTING</code>链上创建<code>DNAT</code>的规则，因为饿在<code>POSTROUTING</code>之前，数据包要进行路由判决，内核会根据当前的目的地选择一个最合适的出口，而<code>POSTROUTING</code>链的规则是在路由判决后发生，在这里修改数据包的目的地会造成数据包不可到达的后果。</p></blockquote><h3 id="K8S-的-Service-设计"><a href="#K8S-的-Service-设计" class="headerlink" title="K8S 的 Service 设计"></a><code>K8S</code> 的 <code>Service</code> 设计</h3><p>主要考虑如下两个原因：</p><ul><li><code>pod</code> 的特性是快速创建销毁，所以<code>pod</code>的<code>ip</code>是不固定的，要让调用方有个固定依赖，所以需要一个<code>VIP</code>来代表服务</li><li>一般来说为了追求应用的高可用，一个应用会部署多个<code>POD</code>,这时需要一个<code>VIP</code>充当多个<code>pod</code>的流量负载</li></ul><h4 id="service-几种类型的使用场景"><a href="#service-几种类型的使用场景" class="headerlink" title="service 几种类型的使用场景"></a><code>service</code> 几种类型的使用场景</h4><ul><li><code>clusterIP</code>: 只能在集群的节点和<code>pod</code>中访问，解决的就是集群内应用间的相互访问的问题</li><li><code>nodeport</code>: 通过节点的地址和端口将<code>pod</code>暴露到集群外，让集群外的应用能够访问集群内的应用，设置服务类型为<code>nodeport</code>时，是在<code>clusterIP</code>的基础上再给节点开个端口转发，所以<code>nodeport</code>的服务也会有一个<code>clusterIP</code></li><li><code>loadBalancer</code>: 因为使用<code>nodeport</code>方式时，需要在应用的调用方写死一个集群节点的<code>IP</code>,此方式并非为高可用方式，这个时候使用第三方负载均衡器的方式，转发到多个节点的<code>nodeport</code>，<code>loadBanlancer</code>是在<code>nodeport</code>的基础上再创建一个<code>lb</code>，所以也会先分配一个<code>clusterIP</code>,再创建节点的端口转发。</li><li><code>headless</code>: 应用多个副本彼此间相互访问，比如要部署到<code>mysql</code>的主从，从的副本想要找主的副本:</li><li><code>externalName</code>: 相当于<code>coredns</code>里面的<code>cname</code>记录</li></ul><blockquote><p>在<code>iptables</code> 模式下，<code>clusterIP</code>都是<code>ping</code>不通的，这是因为 <code>kube-proxy</code> 在实现时之根据<code>ip</code>+端口+协议精确匹配才转发，这才导致<code>clusterIP</code>不能<code>ping</code></p></blockquote><p><strong><code>hairpin flow</code>场景: <code>pod</code>通过<code>clusterIP</code>访问自己</strong></p><blockquote><p>推荐一篇万字长文<a href="https://mp.weixin.qq.com/s/Dgv5BU9YU0tuSMxtzcuiVw"><code>iptables</code>长文详解</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;收集整理，转载自&lt;a href=&quot;https://zhuanlan.zhihu.com/p/404837363&quot;&gt;深入理解kubernetes（k8s）网络原理之二-service原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a hr</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="network" scheme="http://kiragoo.github.com/categories/kubernetes/network/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="iptables" scheme="http://kiragoo.github.com/tags/iptables/"/>
    
    <category term="network" scheme="http://kiragoo.github.com/tags/network/"/>
    
    <category term="service" scheme="http://kiragoo.github.com/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>深入理解k8s网路原理之-POD连接主机</title>
    <link href="http://kiragoo.github.com/archives/1d9a37c9.html"/>
    <id>http://kiragoo.github.com/archives/1d9a37c9.html</id>
    <published>2021-09-03T07:58:47.000Z</published>
    <updated>2022-04-21T12:46:07.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://zhuanlan.zhihu.com/p/403856388">深入理解kubernetes（k8s）网络原理之一-pod连接主机</a></p></blockquote><h1 id="关于Linux网络的知识"><a href="#关于Linux网络的知识" class="headerlink" title="关于Linux网络的知识"></a>关于<code>Linux</code>网络的知识</h1><h2 id="向外发送一个数据包，执行步骤："><a href="#向外发送一个数据包，执行步骤：" class="headerlink" title="向外发送一个数据包，执行步骤："></a>向外发送一个数据包，执行步骤：</h2><p>1、查找该数据包的目的地的路由信息，如果是直连，则在邻居表中查找该目的地的<code>Mac</code>地址<br>2、如果非直连路由，则在邻居表中查找下一跳的<code>Mac</code>地址<br>3、如果找不到对应的路由，则报<code>&quot;network is unreachable&quot;</code><br>4、如果在邻居表中没有查到相应的<code>MAC</code>地址信息，则向外发送<code>ARP</code>请求询问<br>5、发送出去的数据帧，源<code>MAC</code>地址为发送网卡的<code>MAC</code>地址，目标<code>MAC</code>则是下一跳的<code>MAC</code>，只要不经过<code>NAT</code>，那么源目的<code>IP</code>全程不会变化，而<code>MAC</code>地址则每一跳都会变化</p><h2 id="收到数据帧，执行步骤"><a href="#收到数据帧，执行步骤" class="headerlink" title="收到数据帧，执行步骤"></a>收到数据帧，执行步骤</h2><p>1、如果数据帧目标<code>MAC</code>地址不是收包网卡的<code>MAC</code>，也不是<code>ARP</code>广播地址，且网卡未开启混杂模式，则拒绝收包<br>2、如果数据帧目标<code>MAC</code>为<code>ff:ff:ff:ff:ff:ff</code>，则进入<code>ARP</code>请求处理流程<br>3、如果数据帧目标<code>MAC</code>地址是收包网卡的<code>MAC</code>，且是<code>IP</code>包则：<br>    1、目标<code>IP</code>地址在本机，则上送到上一层协议继续处理<br>    2、目标<code>IP</code>地址不在本机，则看<code>net.ipv4.ip_forward</code>是否为1，若是1，则查找目标<code>IP</code>的路由信息，进行转发<br>    3、目标<code>IP</code>不在本机，且<code>net.ipv4.ip_forward</code>为0，则丢弃</p><h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡信息</span></span><br><span class="line">ip link </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡ip地址</span></span><br><span class="line">ip addr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看邻居表信息</span></span><br><span class="line">ip neigh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有iptables规则</span></span><br><span class="line">iptables-save</span><br></pre></td></tr></table></figure><blockquote><p>为了让多个进程高效互不影响地运行，衍生出容器技术，其中以<code>Docker</code>最为流行：<br>1、资源隔离： 使用<code>linux control group</code> 解决各种进程<code>CPU</code>和<code>Memory</code>、<code>io</code>的资源分配问题<br>2、网络隔离： 使用<code>linux network group</code>让各个进程运行在独立的网络命名空间，使各个进程运行在独立的网络命名空间<br>3、文件系统隔离：使用<code>union fs</code>，让各个进程运行在独立的根文件系统中</p></blockquote><p><strong><code>POD</code>即共享同一个<code>ns</code>的多个容器</strong></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><code>docker</code> 运行一个容器时，都会为当前容器创建一个<code>ns</code>，多个容器只能相互访问对方的<code>ip</code>地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=pause busybox</span><br><span class="line">docker run --name=nginx -d nginx  </span><br></pre></td></tr></table></figure><p>此时要在 <code>pause</code> 中访问 <code>nginx</code>，先查找下<code>nginx</code>容器的<code>ip</code>地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker inspect nginx | grep IPAddress</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br></pre></td></tr></table></figure><p>然后在<code>pause</code>容器中用刚查到的<code>ip</code>地址进行访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it pause curl 172.17.0.8</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">....</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这里可以让 <code>nginx</code> 容器加入<code>pause</code>容器的<code>ns</code>，用下面的命令可以模拟：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name=pause busybox</span><br><span class="line">docker run --name=nginx --network=container:pause -d nginx</span><br></pre></td></tr></table></figure><p>此时<code>pause</code>容器和<code>nginx</code>容器是在相同的<code>ns</code>中，相互间访问就可以使用`localhost进行访问了，可以用下面的命令进行验证:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it pause culr localhost</span><br></pre></td></tr></table></figure><p><em><code>pause</code>容器和<code>nginx</code>容器就是共享一个<code>ns</code>的两个容器，所以<code>pause</code>和<code>nginx</code>两个容器加起来就是<code>k8s</code>的<code>pod</code></em></p><blockquote><p>在<code>k8s</code>集群的节点中使用<code>docker ps</code>，总会发现一堆名为<code>pause</code>的容器，<code>pause</code>是为多个业务容器提供共享的<code>ns</code>的。</p></blockquote><p>1、进入<code>docker</code>创建的<code>pause</code>容器的<code>ns 先获取</code>pause<code>容器的</code>pid`</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect pause | grep Pid</span><br></pre></td></tr></table></figure><p>2、进入指定<code>pid</code>的`ns</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nsenter --net=/proc/3083138/ns/net</span><br></pre></td></tr></table></figure><p>3、此时已经在<code>pause</code>容器的<code>ns</code>中了，可以查看该<code>ns</code>的网卡，路由表，邻居表等信息了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br><span class="line">ip route</span><br></pre></td></tr></table></figure><h1 id="认识ns"><a href="#认识ns" class="headerlink" title="认识ns"></a>认识<code>ns</code></h1><p>影响网络方面的配置主要有以下几个：<br>— 网卡：启动时初始化，后期可以添加虚拟设备</p><ul><li>端口：1到65535，所有进程共享</li><li><code>iptables</code>规则： 配置进出主机的防火墙策略和<code>NAT</code>规则</li><li>路由表：到目标地址的路由信息</li><li>邻居表：与主机在同个二层网络的其他主机的<code>MAC</code>地址与<code>IP</code>地址的映射关系</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>1、创建新的<code>ns</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns add ns1</span><br></pre></td></tr></table></figure><p>然后可以使用<code>ip netns exec ns1</code>前缀来执行命令，这样显示的结果就都是<code>ns1</code>的网络相关的配置了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip link show</span><br></pre></td></tr></table></figure><p>2、主机与<code>pod</code>相互访问<br>首先给<code>ns1</code>正价一张与主机相连的网卡，这里用到<code>linux</code>虚拟网络设备<code>veth</code>网卡对，对于<code>veth</code>，基本可以理解为中间连着线的两张网卡：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 增加一对veth网卡，名为 ns1-eth0 和 veth-ns1</span></span><br><span class="line">ip link add ns1-eth0 type veth peer name veth-ns1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中一端挪到刚才创建的ns1中，另一端留在主机端，这样主机和ns就连接起来了</span></span><br><span class="line">ip link set ns1-eth0 netns ns1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动主机端的网卡veth-ns1</span></span><br><span class="line">ip link set veth-ns1 up</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行设置网卡的ip</span></span><br><span class="line">ip netns exec ns1 ip addr add 172.20.1.10/24 dev ns1-eth0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动ns1端的网卡ns1-eth0</span></span><br><span class="line">ip netns exec ns1 ip link set ns1-eth0 up</span><br></pre></td></tr></table></figure><p>3、测试与主机<code>ip</code>是否能<code>ping</code>通</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ping xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><p>此时发现不能<code>ping</code>通主机，这是因为没有到目的地的路由，所以在这里给<code>ns1</code>增加一条默认路由</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip route add default via 172.20.1.1. dev ns-eth0</span><br></pre></td></tr></table></figure><p>通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netsns exec ns1 ip route</span><br></pre></td></tr></table></figure><p>查看路由信息<br>此时去<code>ping</code>发现还是不行，这是因为<em>如果是非直连路由，会先去拿下一跳的<code>mac</code>地址，下一跳是<code>172..20.1.1</code>，能获取到它的<code>MAC</code>地址吗？</em><br>用如下命令查一下路由表:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns1 ip neigh</span><br></pre></td></tr></table></figure><p>会发现获取不到，以为网关<code>ip</code>地址确实是个不存在的地址，网关<code>IP</code>是不会出现在<code>pod</code>发送的数据包中的，真正需要用的是网关的<code>mac</code>地址，我们的目的是要得到主机端<code>veth-ns1</code>的<code>mac</code>地址，有两个方法：<br>·、设置对端的网卡<code>apr</code>代答，<code>ns1-eth0</code>的对端是主机上的<code>veth-ns1</code>网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这样就开启了veth-ns1的arp代答，只要收到arp请求，不管目标IP是什么，veth-ns1网卡都会把自己MAC地址回复回去</span></span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/veth-ns1/proxy_arp </span><br></pre></td></tr></table></figure><p>或者把网关地址设置在对端的网卡上<br>4、此时拿到网关的<code>mac</code>地址但是<code>ping</code>之后发现还是不行。这是因为主机上没有添加到<code>pod</code>的直连路由</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add 172.20.1.10 dev veth-ns1</span><br></pre></td></tr></table></figure><p>此时只能保证主机与<code>pod</code>进行互通，此时<code>pod</code>是没法访问外网的，这个时候需要做原地址转换，所以我们需要在主机上也要配置针对刚才创建的<code>pod</code>的原地址转换规则。</p><h2 id="pod访问外网"><a href="#pod访问外网" class="headerlink" title="pod访问外网"></a><code>pod</code>访问外网</h2><ul><li>首先第一步需要打开本机的<code>ip</code>转发功能<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure></li><li>设置<code>snat</code>规则<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A POSTROUTING -t nat -s 172.20.1.10 -j MASQUERADE</span><br></pre></td></tr></table></figure>此时发现可以<code>ping</code>通百度</li></ul>]]></content>
    
    
    <summary type="html">温顾而知新，最近在做公司产品 `MQ` 场景的 `Operator` 开发设计，好久没更新博客了。</summary>
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="network" scheme="http://kiragoo.github.com/categories/kubernetes/network/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="network" scheme="http://kiragoo.github.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Istio初体验之后续补充</title>
    <link href="http://kiragoo.github.com/archives/ffa85151.html"/>
    <id>http://kiragoo.github.com/archives/ffa85151.html</id>
    <published>2021-05-12T10:33:02.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<p>继<a href="https://kiragoo.github.io/archives/b47cf59d.html">docker desktop之Istio初体验</a>中完成集群内部基础组件部署之后，我们有了大概的认知。其中关于如何将服务对外暴露并没有明细说明太多，此篇补充下<em>如何对外开放应用服务</em>。</p><h1 id="对外开放应用程序"><a href="#对外开放应用程序" class="headerlink" title="对外开放应用程序"></a>对外开放应用程序</h1><p>此时我们查看如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  kubectl get pods                                                ✔  18:28:42</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-79c697d759-smfhp       2/2     Running   0          5m56s</span><br><span class="line">productpage-v1-65576bb7bf-k6797   2/2     Running   0          5m54s</span><br><span class="line">ratings-v1-7d99676f7f-xjr74       2/2     Running   0          5m55s</span><br><span class="line">reviews-v1-987d495c-2hqcg         2/2     Running   0          5m55s</span><br><span class="line">reviews-v2-6c5bf657cf-s4db5       2/2     Running   0          5m56s</span><br><span class="line">reviews-v3-5f7b9f4f77-7rt5t       2/2     Running   0          5m55s</span><br><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  kubectl <span class="built_in">exec</span> <span class="string">&quot;<span class="subst">$(kubectl get pod -l app=ratings -o jsonpath=&#x27;&#123;.items[0].metadata.name&#125;&#x27;)</span>&quot;</span> -c ratings -- curl -s productpage:9080/productpage | grep -o <span class="string">&quot;&lt;title&gt;.*&lt;/title&gt;&quot;</span> </span><br><span class="line"></span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure><p>确保服务状态都是正常的。</p><p>此时，<code>BookInfo</code> 应用已经部署，但还不能被外界访问。 要开放访问，你需要创建 <a href="https://kiragoo.github.io/archives/c3a53ddf.html"><code>Istio</code> 入站网关（<code>Ingress Gateway</code>）</a>, 它会在网格边缘把一个路径映射到路由。</p><blockquote><p>如对基础概念还不清楚的，可以参考<a href="https://kiragoo.github.io/archives/6a996a50.html">Istio-文档-概念</a></p></blockquote><ol><li>把应用关联到<code>Istio</code>网关：<br>先看下 <code>bookinfo-gateway.yaml</code> 中内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io&#x2F;v1alpha3</span><br><span class="line">kind: Gateway</span><br><span class="line">metadata:</span><br><span class="line">  name: bookinfo-gateway</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    istio: ingressgateway # use istio default controller</span><br><span class="line">  servers:</span><br><span class="line">  - port:</span><br><span class="line">      number: 80</span><br><span class="line">      name: http</span><br><span class="line">      protocol: HTTP</span><br><span class="line">    hosts:</span><br><span class="line">    - &quot;*&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: networking.istio.io&#x2F;v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: bookinfo</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">  - &quot;*&quot;</span><br><span class="line">  gateways:</span><br><span class="line">  - bookinfo-gateway</span><br><span class="line">  http:</span><br><span class="line">  - match:</span><br><span class="line">    - uri:</span><br><span class="line">        exact: &#x2F;productpage</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: &#x2F;static</span><br><span class="line">    - uri:</span><br><span class="line">        exact: &#x2F;login</span><br><span class="line">    - uri:</span><br><span class="line">        exact: &#x2F;logout</span><br><span class="line">    - uri:</span><br><span class="line">        prefix: &#x2F;api&#x2F;v1&#x2F;products</span><br><span class="line">    route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: productpage</span><br><span class="line">        port:</span><br><span class="line">          number: 9080</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml </span><br><span class="line">gateway.networking.istio.io/bookinfo-gateway created</span><br><span class="line">virtualservice.networking.istio.io/bookinfo created</span><br></pre></td></tr></table></figure></li><li>确保配置文件没有问题：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  istioctl analyze                                                ✔  18:43:44</span><br><span class="line">✔ No validation issues found when analyzing namespace: default.</span><br></pre></td></tr></table></figure><h2 id="确定入站-IP-和端口"><a href="#确定入站-IP-和端口" class="headerlink" title="确定入站 IP 和端口"></a>确定入站 <code>IP</code> 和端口</h2>为访问网关设置两个变量：<code>INGRESS_HOST</code> 和 <code>INGRESS_PORT</code>。*由于我的环境是<code>Mac</code>，通过<code>docker desktop</code>部署的<code>k8s</code>*，所以如下的为此环境的处理方式。</li></ol><p>执行下面命令进行判断：你的 <code>Kubernetes</code> 集群环境是否支持外部负载均衡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  kubectl get svc istio-ingressgateway -n istio-system                                                   ✔  18:50:32</span><br><span class="line"></span><br><span class="line">NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.106.247.46   localhost     15021:30307/TCP,80:30353/TCP,443:30695/TCP,31400:30328/TCP,15443:32035/TCP   28m</span><br></pre></td></tr></table></figure><p>设置 <code>EXTERNAL-IP</code> 的值之后， 你的环境就有了一个外部的负载均衡，可以用它做入站网关。 但如果 <code>EXTERNAL-IP</code> 的值为 &lt;<code>none</code>&gt; (或者一直是 &lt;<code>pending</code>&gt; 状态)， 则你的环境则没有提供可作为入站流量网关的外部负载均衡。 这个情况，你还可以用服务（<code>Service</code>）的 节点端口 访问网关。</p><ul><li><p><strong>由于我的环境中确实存在外部的负载均衡，那么继续往下走。</strong><br>设置入站 <code>IP</code> 地址和端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">export</span> INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.status.loadBalancer.ingress[0].ip&#125;&#x27;</span>) </span><br><span class="line"></span><br><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].port&#125;&#x27;</span>) </span><br><span class="line"></span><br><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;https&quot;)].port&#125;&#x27;</span>) </span><br></pre></td></tr></table></figure><blockquote><p>在某些环境中，负载均衡除了 <code>IP</code> 地址，还可以用主机名访问。 在这种情况下，入站流量网关的<code>EXTERNAL-IP</code> 值不是 <code>IP</code> 地址，而是一个主机名， 那上面设置 <code>INGRESS_HOST</code> 环境变量的操作会失败。 使用下面命令纠正 <code>INGRESS_HOST</code> 的值。<strong>我的环境是出现这样的情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;$ <span class="built_in">export</span> INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.status.loadBalancer.ingress[0].hostname&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>如果没有负载均衡，那就选择一个节点端口来代替</strong><br>设置入站的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].nodePort&#125;&#x27;</span>)</span><br><span class="line">$ <span class="built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[?(@.name==&quot;https&quot;)].nodePort&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><p><code>GKE</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=workerNodeAddress</span><br></pre></td></tr></table></figure><p>你需要创建一个防火墙规则，放行发往 <code>ingressgateway</code> 的 <code>TCP</code> 流量。 再运行下面的命令，单独放行发往 <code>HTTP</code> 端口或 <code>HTTPS</code> 端口的流量，或者都放行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcloud compute firewall-rules create allow-gateway-http --allow <span class="string">&quot;tcp:<span class="variable">$INGRESS_PORT</span>&quot;</span></span><br><span class="line">$ gcloud compute firewall-rules create allow-gateway-https --allow <span class="string">&quot;tcp:<span class="variable">$SECURE_INGRESS_PORT</span>&quot;</span></span><br></pre></td></tr></table></figure><p><code>IBM Cloud Kubernetes Service</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ibmcloud ks workers --cluster cluster-name-or-id</span><br><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=public-IP-of-one-of-the-worker-nodes</span><br></pre></td></tr></table></figure><p><code>Docker For Desktop</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=127.0.0.1</span><br></pre></td></tr></table></figure><p><code>Other environments</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath=<span class="string">&#x27;&#123;.items[0].status.hostIP&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>设置环境变量 <code>GATEWAY_URL</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">export</span> GATEWAY_URL=<span class="variable">$INGRESS_HOST</span>:<span class="variable">$INGRESS_PORT</span>                                                         ✔  18:54:31</span><br></pre></td></tr></table></figure></li><li>确保 <code>IP</code>地址和端口均成功的赋值给了环境变量：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">echo</span> <span class="variable">$GATEWAY_URL</span>                                                                                      ✔  19:03:53</span><br><span class="line">localhost:80</span><br></pre></td></tr></table></figure><h2 id="验证外部访问"><a href="#验证外部访问" class="headerlink" title="验证外部访问"></a>验证外部访问</h2>用浏览器查看 <code>Bookinfo</code> 应用的产品页面，验证 <code>Bookinfo</code> 已经实现了外部访问。</li><li>运行下面命令，获取 <code>Bookinfo</code> 应用的外部访问地址。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ~/Documents/Opts/k8s/addons/istio-1.8.1/v1.8.1  <span class="built_in">echo</span> <span class="string">&quot;http://<span class="variable">$GATEWAY_URL</span>/productpage&quot;</span>                                                                 ✔  19:03:58</span><br><span class="line">http://localhost:80/productpage</span><br></pre></td></tr></table></figure></li><li>把上面命令的输出地址复制粘贴到浏览器并访问，确认 Bookinfo 应用的产品页面是否可以打开。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/bookinfo.png" alt="bookinfo"></li></ol><p>至此结束，后续继续更新<code>Istio</code>相关文章。</p><blockquote><p>参考<a href="https://istio.io/latest/zh/docs/setup/getting-started/">入门</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继&lt;a href=&quot;https://kiragoo.github.io/archives/b47cf59d.html&quot;&gt;docker desktop之Istio初体验&lt;/a&gt;中完成集群内部基础组件部署之后，我们有了大概的认知。其中关于如何将服务对外暴露并没有明细说明太多，此</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="istio" scheme="http://kiragoo.github.com/categories/kubernetes/istio/"/>
    
    
    <category term="kubernetes - istio" scheme="http://kiragoo.github.com/tags/kubernetes-istio/"/>
    
  </entry>
  
  <entry>
    <title>Isotio-文档-流量管理</title>
    <link href="http://kiragoo.github.com/archives/c3a53ddf.html"/>
    <id>http://kiragoo.github.com/archives/c3a53ddf.html</id>
    <published>2021-05-11T03:32:06.000Z</published>
    <updated>2022-04-21T12:56:45.868Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/">istio文档</a></p></blockquote><h1 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h1><p><code>Istio</code> 的流量路由规则可以让您很容易的控制服务之间的流量和 <code>API</code> 调用。<code>Istio</code> 简化了服务级别属性的配置，比如熔断器、超时和重试，并且能轻松的设置重要的任务，如 <code>A/B</code> 测试、金丝雀发布、基于流量百分比切分的概率发布等。它还提供了开箱即用的故障恢复特性，有助于增强应用的健壮性，从而更好地应对被依赖的服务或网络发生故障的情况。</p><p><code>Istio</code> 的流量管理模型源于和服务一起部署的 <a href="https://envoyproxy.github.io/envoy/"><code>Envoy</code> 代理</a>。网格内服务发送和接收的所有流量（<code>data plane</code>流量）都经由 <code>Envoy</code> 代理，这让控制网格内的流量变得异常简单，而且不需要对服务做任何的更改。</p><p>本节中描述的功能特性，如果您对它们是如何工作的感兴趣的话，可以在<a href="https://istio.io/latest/zh/docs/ops/deployment/architecture/">架构概述</a>中找到关于 <code>Istio</code> 的流量管理实现的更多信息。本部分只介绍 <code>Istio</code> 的流量管理特性。</p><h1 id="流量管理介绍"><a href="#流量管理介绍" class="headerlink" title="流量管理介绍"></a>流量管理介绍</h1><p>为了在网格中导流，<code>Istio</code> 需要知道所有的 <code>endpoint</code> 在哪和属于哪个服务。为了定位到<code>service registry</code>(服务注册中心)，<code>Istio</code> 会连接到一个服务发现系统。例如，如果您在 <code>Kubernetes</code> 集群上安装了 <code>Istio</code>，那么它将自动检测该集群中的服务和 <code>endpoint</code>。</p><p>使用此服务注册中心，<code>Envoy</code> 代理可以将流量定向到相关服务。大多数基于微服务的应用程序，每个服务的工作负载都有多个实例来处理流量，称为负载均衡池。默认情况下，<code>Envoy</code> 代理基于轮询调度模型在服务的负载均衡池内分发流量，按顺序将请求发送给池中每个成员，一旦所有服务实例均接收过一次请求后，重新回到第一个池成员。</p><p><code>Istio</code> 基本的服务发现和负载均衡能力为您提供了一个可用的服务网格，但它能做到的远比这多的多。在许多情况下，您可能希望对网格的流量情况进行更细粒度的控制。作为 <code>A/B</code> 测试的一部分，您可能想将特定百分比的流量定向到新版本的服务，或者为特定的服务实例子集应用不同的负载均衡策略。您可能还想对进出网格的流量应用特殊的规则，或者<strong>将网格的外部依赖项添加到服务注册中心</strong>。通过使用 <code>Istio</code> 的流量管理 <code>API</code> 将流量配置添加到 <code>Istio</code>，就可以完成所有这些甚至更多的工作。</p><p>和其他 <code>Istio</code> 配置一样，这些 <code>API</code> 也使用 <code>Kubernetes</code> 的自定义资源定义（<code>CRDs</code>）来声明，您可以像示例中看到的那样使用 <code>YAML</code> 进行配置。</p><p>本章节的其余部分将分别介绍每个流量管理 API 以及如何使用它们。这些资源包括：</p><ul><li>虚拟服务</li><li>目标规则</li><li>网关</li><li>服务入口</li><li><code>Sidecar</code></li></ul><h1 id="虚拟服务"><a href="#虚拟服务" class="headerlink" title="虚拟服务"></a>虚拟服务</h1><p>虚拟服务（<code>Virtual Service</code>） 和目标规则（<code>Destination Rule</code>） 是 <code>Istio</code> 流量路由功能的关键拼图。虚拟服务让您配置如何在服务网格内将请求路由到服务，这基于 <code>Istio</code> 和平台提供的基本的连通性和服务发现能力。每个虚拟服务包含一组路由规则，<code>Istio</code> 按顺序评估它们，<code>Istio</code> 将每个给定的请求匹配到虚拟服务指定的实际目标地址。您的网格可以有多个虚拟服务，也可以没有，取决于您的使用场景。</p><h2 id="为什么使用虚拟服务？"><a href="#为什么使用虚拟服务？" class="headerlink" title="为什么使用虚拟服务？"></a>为什么使用虚拟服务？</h2><p>虚拟服务在增强 <code>Istio</code> 流量管理的灵活性和有效性方面，发挥着至关重要的作用，通过对客户端请求的目标地址与真实响应请求的目标工作负载进行解耦来实现。虚拟服务同时提供了丰富的方式，为发送至这些工作负载的流量指定不同的路由规则。</p><p>为什么这如此有用？就像在介绍中所说，如果没有虚拟服务，<code>Envoy</code> 会在所有的服务实例中使用轮询的负载均衡策略分发请求。您可以用您对工作负载的了解来改善这种行为。例如，有些可能代表不同的版本。这在 <code>A/B</code> 测试中可能有用，您可能希望在其中配置基于不同服务版本的流量百分比路由，或指引从内部用户到特定实例集的流量。</p><p>使用虚拟服务，您可以为一个或多个主机名指定流量行为。在虚拟服务中使用路由规则，告诉 <code>Envoy</code> 如何发送虚拟服务的流量到适当的目标。路由目标地址可以是同一服务的不同版本，也可以是完全不同的服务。</p><p>一个典型的用例是将流量发送到被指定为服务子集的服务的不同版本。客户端将虚拟服务视为一个单一实体，将请求发送至虚拟服务主机，然后 <code>Envoy</code> 根据虚拟服务规则把流量路由到不同的版本。例如，“20% 的调用转到新版本”或“将这些用户的调用转到版本 2”。这允许您创建一个金丝雀发布，逐步增加发送到新版本服务的流量百分比。流量路由完全独立于实例部署，这意味着实现新版本服务的实例可以根据流量的负载来伸缩，完全不影响流量路由。相比之下，像 <code>Kubernetes</code> 这样的容器编排平台只支持基于实例缩放的流量分发，这会让情况变得复杂。您可以在使用 <a href="https://istio.io/latest/zh/blog/2017/0.1-canary/">Istio 进行金丝雀部署</a>的文章里阅读到更多用虚拟服务实现金丝雀部署的内容。</p><p>虚拟服务可以让您：</p><ul><li>通过单个虚拟服务处理多个应用程序服务。如果您的网格使用 <code>Kubernetes</code>，可以配置一个虚拟服务处理特定命名空间中的所有服务。映射单一的虚拟服务到多个“真实”服务特别有用，可以在不需要客户适应转换的情况下，将单体应用转换为微服务构建的复合应用系统。您的路由规则可以指定为“对这些 <code>monolith.com</code> 的 <code>URI</code> 调用转到<code>microservice A</code>”等等。您可以在<a href="##%E8%99%9A%E6%8B%9F%E6%9C%8D%E5%8A%A1%E7%A4%BA%E4%BE%8B">下面的一个示例</a>看到它是如何工作的。</li><li>和<a href="##%E7%BD%91%E5%85%B3">网关</a>整合并配置流量规则来控制出入流量。</li></ul><p>在某些情况下，您还需要配置目标规则来使用这些特性，因为这是指定服务子集的地方。在一个单独的对象中指定服务子集和其它特定目标策略，有利于在虚拟服务之间更简洁地重用这些规则。在下一章节您可以找到更多关于目标规则的内容。</p><h2 id="虚拟服务示例"><a href="#虚拟服务示例" class="headerlink" title="虚拟服务示例"></a>虚拟服务示例</h2><p>下面的虚拟服务根据请求是否来自特定的用户，把它们路由到服务的不同版本。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">        <span class="attr">end-user:</span></span><br><span class="line">          <span class="attr">exact:</span> <span class="string">jason</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><h3 id="hosts字段"><a href="#hosts字段" class="headerlink" title="hosts字段"></a><code>hosts</code>字段</h3><p>使用 <code>hosts</code> 字段列举虚拟服务的主机——即用户指定的目标或是路由规则设定的目标。这是客户端向服务发送请求时使用的一个或多个地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hosts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">reviews</span></span><br></pre></td></tr></table></figure><p>虚拟服务主机名可以是 <code>IP</code> 地址、<code>DNS</code> 名称，或者依赖于平台的一个简称（例如 <code>Kubernetes</code> 服务的短名称），隐式或显式地指向一个完全限定域名（<code>FQDN</code>）。您也可以使用通配符（“*”）前缀，让您创建一组匹配所有服务的路由规则。虚拟服务的 <code>hosts</code> 字段实际上不必是 <code>Istio</code> 服务注册的一部分，它只是虚拟的目标地址。这让您可以为没有路由到网格内部的虚拟主机建模。</p><h3 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a><code>路由规则</code></h3><p>在 <code>http</code> 字段包含了虚拟服务的路由规则，用来描述匹配条件和路由行为，它们把 <code>HTTP/1.1、HTTP2</code> 和 <code>gRPC</code> 等流量发送到 <code>hosts</code> 字段指定的目标（您也可以用 <code>tcp</code> 和 <code>tls</code> 片段为 <code>TCP</code> 和未终止的 <code>TLS</code> 流量设置路由规则）。一个路由规则包含了指定的请求要流向哪个目标地址，具有 0 或多个匹配条件，取决于您的使用场景。</p><h4 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h4><p>示例中的第一个路由规则有一个条件，因此以 <code>match</code> 字段开始。在本例中，您希望此路由应用于来自 ”jason“ 用户的所有请求，所以使用 <code>headers、end-user</code> 和 <code>exact</code> 字段选择适当的请求。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">headers:</span></span><br><span class="line">       <span class="attr">end-user:</span></span><br><span class="line">         <span class="attr">exact:</span> <span class="string">jason</span></span><br></pre></td></tr></table></figure><h4 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a><code>Destination</code></h4><p><code>route</code> 部分的 <code>destination</code> 字段指定了符合此条件的流量的实际目标地址。与虚拟服务的 <code>hosts</code> 不同，<code>destination</code> 的 <code>host</code> 必须是存在于 <code>Istio</code> 服务注册中心的实际目标地址，否则 <code>Envoy</code> 不知道该将请求发送到哪里。可以是一个有代理的服务网格，或者是一个通过服务入口被添加进来的非网格服务。本示例运行在 <code>Kubernetes</code> 环境中，<code>host</code> 名为一个 <code>Kubernetes</code> 服务名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">    <span class="attr">subset:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure><p><em>请注意，在该示例和本页其它示例中，为了简单，我们使用 <code>Kubernetes</code> 的短名称设置 <code>destination</code> 的 <code>host</code>。在评估此规则时，<code>Istio</code> 会添加一个基于虚拟服务命名空间的域后缀，这个虚拟服务包含要获取主机的完全限定名的路由规则。在我们的示例中使用短名称也意味着您可以复制并在任何喜欢的命名空间中尝试它们。</em></p><blockquote><p><strong>只有在目标主机和虚拟服务位于相同的 <code>Kubernetes</code> 命名空间时才可以使用这样的短名称。因为使用 <code>Kubernetes</code> 的短名称容易导致配置出错，我们建议您在生产环境中指定完全限定的主机名。</strong></p></blockquote><p><code>destination</code> 片段还指定了 <code>Kubernetes</code> 服务的子集，将符合此规则条件的请求转入其中。在本例中子集名称是 <code>v2</code>。您可以在<a href="#%E7%9B%AE%E6%A0%87%E8%A7%84%E5%88%99">目标规则章节</a>中看到如何定义服务子集。</p><h3 id="路由规则优先级"><a href="#路由规则优先级" class="headerlink" title="路由规则优先级"></a>路由规则优先级</h3><p>路由规则按从上到下的顺序选择，虚拟服务中定义的第一条规则有最高优先级。本示例中，不满足第一个路由规则的流量均流向一个默认的目标，该目标在第二条规则中指定。因此，第二条规则没有 <code>match</code> 条件，直接将流量导向 <code>v3</code> 子集。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">      <span class="attr">subset:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>我们建议提供一个默认的“无条件”或基于权重的规则（见下文）作为每一个虚拟服务的最后一条规则，如案例所示，从而确保流经虚拟服务的流量至少能够匹配一条路由规则。</p><h2 id="路由规则的更多内容"><a href="#路由规则的更多内容" class="headerlink" title="路由规则的更多内容"></a>路由规则的更多内容</h2><p>正如上面所看到的，路由规则是将特定流量子集路由到指定目标地址的强大工具。您可以在流量端口、<code>header</code> 字段、<code>URI</code> 等内容上设置匹配条件。例如，这个虚拟服务让用户发送请求到两个独立的服务：<code>ratings</code> 和 <code>reviews</code>，就好像它们是 <code>http://bookinfo.com/</code> 这个更大的虚拟服务的一部分。虚拟服务规则根据请求的 URI 和指向适当服务的请求匹配流量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bookinfo.com</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/reviews</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uri:</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">/ratings</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">      <span class="attr">sourceLabels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">reviews</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>有些匹配条件可以使用精确的值，如前缀或正则。</p><p>您可以使用 <code>AND</code> 向同一个 <code>match</code> 块添加多个匹配条件，或者使用 <code>OR</code> 向同一个规则添加多个 <code>match</code> 块。对于任何给定的虚拟服务也可以有多个路由规则。这可以在单个虚拟服务中使路由条件变得随您所愿的复杂或简单。匹配条件字段和备选值的完整列表可以在 <a href="https://istio.io/latest/zh/docs/reference/config/networking/virtual-service/#HTTPMatchRequest"><code>HTTPMatchRequest</code> 参考</a>中找到。</p><p>另外，使用匹配条件您可以按百分比”权重“分发请求。这在 <code>A/B</code> 测试和金丝雀发布中非常有用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">75</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v2</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>您也可以使用路由规则在流量上执行一些操作，例如：</p><ul><li>添加或删除 <code>header</code>。</li><li>重写 <code>URL</code>。</li><li>调用这一目标地址的请求设置<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/#retries">重试策略</a>。<br>想了解如何利用这些操作，查看 <a href="https://istio.io/latest/zh/docs/reference/config/networking/virtual-service/#HTTPRoute"><code>HTTPRoute</code> 参考</a>。</li></ul><h1 id="目标规则"><a href="#目标规则" class="headerlink" title="目标规则"></a>目标规则</h1><p>与虚拟服务一样，目标规则也是 <code>Istio</code> 流量路由功能的关键部分。您可以将虚拟服务视为将流量如何路由到给定目标地址，然后使用目标规则来配置该目标的流量。在评估虚拟服务路由规则之后，目标规则将应用于流量的“真实”目标地址。</p><p>特别是，您可以使用目标规则来指定命名的服务子集，例如按版本为所有给定服务的实例分组。然后可以在虚拟服务的路由规则中使用这些服务子集来控制到服务不同实例的流量。</p><p>目标规则还允许您在调用整个目的地服务或特定服务子集时定制 Envoy 的流量策略，比如您喜欢的负载均衡模型、TLS 安全模式或熔断器设置。在<a href="https://istio.io/latest/zh/docs/reference/config/networking/destination-rule/">目标规则参考</a>中可以看到目标规则选项的完整列表。</p><h2 id="负载均衡选项"><a href="#负载均衡选项" class="headerlink" title="负载均衡选项"></a>负载均衡选项</h2><p>默认情况下，<code>Istio</code> 使用轮询的负载均衡策略，实例池中的每个实例依次获取请求。<code>Istio</code> 同时支持如下的负载均衡模型，可以在 <code>DestinationRule</code> 中为流向某个特定服务或服务子集的流量指定这些模型。</p><ul><li>随机：请求以随机的方式转到池中的实例。</li><li>权重：请求根据指定的百分比转到实例。</li><li>最少请求：请求被转到最少被访问的实例。</li></ul><p>查看 <a href="https://www.envoyproxy.io/docs/envoy/v1.5.0/intro/arch_overview/load_balancing"><code>Envoy</code> 负载均衡文档</a>获取这部分的更多信息。</p><h2 id="目标规则示例"><a href="#目标规则示例" class="headerlink" title="目标规则示例"></a>目标规则示例</h2><p>在下面的示例中，目标规则为 <code>my-svc</code> 目标服务配置了 3 个具有不同负载均衡策略的子集：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-destination-rule</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">my-svc</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span></span><br><span class="line">    <span class="attr">loadBalancer:</span></span><br><span class="line">      <span class="attr">simple:</span> <span class="string">RANDOM</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">loadBalancer:</span></span><br><span class="line">        <span class="attr">simple:</span> <span class="string">ROUND_ROBIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v3</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v3</span></span><br></pre></td></tr></table></figure><p>每个子集都是基于一个或多个 <code>labels</code> 定义的，在 <code>Kubernetes</code> 中它是附加到像 <code>Pod</code> 这种对象上的键/值对。这些标签应用于 `Kubernetes 服务的 Deployment 并作为 metadata 来识别不同的版本。</p><p>除了定义子集之外，目标规则对于所有子集都有默认的流量策略，而对于该子集，则有特定于子集的策略覆盖它。定义在 <code>subsets</code> 上的默认策略，为 <code>v1</code> 和 <code>v3</code> 子集设置了一个简单的随机负载均衡器。在 <code>v2</code> 策略中，轮询负载均衡器被指定在相应的子集字段上。</p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>使用网关为网格来管理入站和出站流量，可以让您指定要进入或离开网格的流量。网关配置被用于运行在网格边界的独立 <code>Envoy</code> 代理，而不是服务工作负载的 <code>sidecar</code> 代理。</p><p>与 <code>Kubernetes Ingress API</code> 这种控制进入系统流量的其他机制不同，<code>Istio</code> 网关让您充分利用流量路由的强大能力和灵活性。您可以这么做的原因是 <code>Istio</code> 的网关资源可以配置 4-6 层的负载均衡属性，如对外暴露的端口、<code>TLS</code> 设置等。作为替代应用层流量路由（L7）到相同的 <code>API</code> 资源，您绑定了一个常规的 <code>Istio</code> 虚拟服务到网关。这让您可以像管理网格中其他数据平面的流量一样去管理网关流量。</p><p>网关主要用于管理进入的流量，但您也可以配置出口网关。出口网关让您为离开网格的流量配置一个专用的出口节点，这可以限制哪些服务可以或应该访问外部网络，或者启用<a href="https://istio.io/latest/zh/blog/2019/egress-traffic-control-in-istio-part-1/">出口流量安全控制</a>为您的网格添加安全性。您也可以使用网关配置一个纯粹的内部代理。</p><p><code>Istio</code> 提供了一些预先配置好的网关代理部署（<code>istio-ingressgateway</code> 和 <code>istio-egressgateway</code>）供您使用——如果使用我们的演示安装它们都已经部署好了；如果使用默认或 <code>sds</code> 配置文件则只部署了入口网关。可以将您自己的网关配置应用到这些部署或配置您自己的网关代理。</p><h2 id="Gateway示例"><a href="#Gateway示例" class="headerlink" title="Gateway示例"></a><code>Gateway</code>示例</h2><p>下面的示例展示了一个外部 <code>HTTPS</code> 入口流量的网关配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Gateway</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ext-host-gwy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-gateway-controller</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">    <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">SIMPLE</span></span><br><span class="line">      <span class="attr">serverCertificate:</span> <span class="string">/tmp/tls.crt</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/tmp/tls.key</span></span><br></pre></td></tr></table></figure><p>这个网关配置让 <code>HTTPS</code> 流量从 <code>ext-host.example.com</code> 通过 443 端口流入网格，但没有为请求指定任何路由规则。为想要工作的网关指定路由，您必须把网关绑定到虚拟服务上。正如下面的示例所示，使用虚拟服务的 <code>gateways</code> 字段进行设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">virtual-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-host.example.com</span></span><br><span class="line">  <span class="attr">gateways:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ext-host-gwy</span></span><br></pre></td></tr></table></figure><p>然后就可以为出口流量配置带有路由规则的虚拟服务。</p><h1 id="服务入口"><a href="#服务入口" class="headerlink" title="服务入口"></a>服务入口</h1><p>使用服务入口（<code>Service Entry</code>） 来添加一个入口到 <code>Istio</code> 内部维护的服务注册中心。添加了服务入口后，<code>Envoy</code> 代理可以向服务发送流量，就好像它是网格内部的服务一样。配置服务入口允许您管理运行在网格外的服务的流量，它包括以下几种能力：</p><ul><li>为外部目标 <code>redirect</code> 和转发请求，例如来自 <code>web</code> 端的 <code>API</code> 调用，或者流向遗留老系统的服务。</li><li>为外部目标定义重试、超时和故障注入策略。</li><li>添加一个运行在虚拟机的服务来扩展您的网格。</li><li>从逻辑上添加来自不同集群的服务到网格，在 <code>Kubernetes</code> 上实现一个多集群 <code>Istio</code> 网格。</li></ul><p><em>您不需要为网格服务要使用的每个外部服务都添加服务入口。默认情况下，Istio 配置 Envoy 代理将请求传递给未知服务。但是，您不能使用 Istio 的特性来控制没有在网格中注册的目标流量。</em></p><h2 id="服务入口示例"><a href="#服务入口示例" class="headerlink" title="服务入口示例"></a>服务入口示例</h2><p>下面示例的 <code>mesh-external</code> 服务入口将 <code>ext-resource</code> 外部依赖项添加到 <code>Istio</code> 的服务注册中心：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceEntry</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">svc-entry</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ext-svc.example.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">number:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">HTTPS</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">MESH_EXTERNAL</span></span><br><span class="line">  <span class="attr">resolution:</span> <span class="string">DNS</span></span><br></pre></td></tr></table></figure><p>您指定的外部资源使用 <code>hosts</code> 字段。可以使用完全限定名或通配符作为前缀域名。</p><p>您可以配置虚拟服务和目标规则，以更细粒度的方式控制到服务入口的流量，这与网格中的任何其他服务配置流量的方式相同。例如，下面的目标规则配置流量路由以使用双向 <code>TLS</code> 来保护到 <code>ext-svc.example.com</code> 外部服务的连接，我们使用服务入口配置了该外部服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ext-res-dr</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">ext-svc.example.com</span></span><br><span class="line">  <span class="attr">trafficPolicy:</span></span><br><span class="line">    <span class="attr">tls:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">MUTUAL</span></span><br><span class="line">      <span class="attr">clientCertificate:</span> <span class="string">/etc/certs/myclientcert.pem</span></span><br><span class="line">      <span class="attr">privateKey:</span> <span class="string">/etc/certs/client_private_key.pem</span></span><br><span class="line">      <span class="attr">caCertificates:</span> <span class="string">/etc/certs/rootcacerts.pem</span></span><br></pre></td></tr></table></figure><p>查看<a href="https://istio.io/latest/zh/docs/reference/config/networking/service-entry">服务入口参考</a>获取更多可能的配置项。</p><h1 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h1><p>默认情况下，<code>Istio</code> 让每个 <code>Envoy</code> 代理都可以访问来自和它关联的工作负载的所有端口的请求，然后转发到对应的工作负载。您可以使用 <code>sidecar</code> 配置去做下面的事情：</p><ul><li>微调 <code>Envoy</code> 代理接受的端口和协议集。</li><li>限制 <code>Envoy</code> 代理可以访问的服务集合。</li></ul><p>您可能希望在较庞大的应用程序中限制这样的 sidecar 可达性，配置每个代理能访问网格中的任意服务可能会因为高内存使用量而影响网格的性能。</p><p>您可以指定将 <code>sidecar</code> 配置应用于特定命名空间中的所有工作负载，或者使用 <code>workloadSelector</code> 选择特定的工作负载。例如，下面的 <code>sidecar</code> 配置将 <code>bookinfo</code> 命名空间中的所有服务配置为仅能访问运行在相同命名空间和 <code>Istio</code> 控制平面中的服务（目前需要使用 <code>Istio</code> 的策略和遥测功能）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Sidecar</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">bookinfo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;./*&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;istio-system/*&quot;</span></span><br></pre></td></tr></table></figure><p>查阅 <a href="https://istio.io/latest/zh/docs/reference/config/networking/sidecar/">Sidecar 参考</a>获取详细信息。</p><h1 id="网络弹性和测试"><a href="#网络弹性和测试" class="headerlink" title="网络弹性和测试"></a>网络弹性和测试</h1><p>除了为您的网格导流之外，<code>Istio</code> 还提供了可选的故障恢复和故障注入功能，您可以在运行时动态配置这些功能。使用这些特性可以让您的应用程序运行稳定，确保服务网格能够容忍故障节点，并防止局部故障级联影响到其他节点。</p><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>超时是 <code>Envoy</code> 代理等待来自给定服务的答复的时间量，以确保服务不会因为等待答复而无限期的挂起，并在可预测的时间范围内调用成功或失败。<code>HTTP</code> 请求的默认超时时间是 15 秒，这意味着如果服务在 15 秒内没有响应，调用将失败。</p><p>对于某些应用程序和服务，<code>Istio</code> 的缺省超时可能不合适。例如，超时太长可能会由于等待失败服务的回复而导致过度的延迟；而超时过短则可能在等待涉及多个服务返回的操作时触发不必要地失败。为了找到并使用最佳超时设置，<code>Istio</code> 允许您使用虚拟服务按服务轻松地动态调整超时，而不必修改您的业务代码。下面的示例是一个虚拟服务，它对 <code>ratings</code> 服务的 <code>v1</code> 子集的调用指定 10 秒超时：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>重试设置指定如果初始调用失败，<code>Envoy</code> 代理尝试连接服务的最大次数。通过确保调用不会因为临时过载的服务或网络等问题而永久失败，重试可以提高服务可用性和应用程序的性能。重试之间的间隔（25ms+）是可变的，并由 <code>Istio</code> 自动确定，从而防止被调用服务被请求淹没。<code>HTTP</code> 请求的默认重试行为是在返回错误之前重试两次。</p><p>与超时一样，<code>Istio</code> 默认的重试行为在延迟方面可能不适合您的应用程序需求（对失败的服务进行过多的重试会降低速度）或可用性。您可以在虚拟服务中按服务调整重试设置，而不必修改业务代码。您还可以通过添加每次重试的超时来进一步细化重试行为，并指定每次重试都试图成功连接到服务所等待的时间量。下面的示例配置了在初始调用失败后最多重试 3 次来连接到服务子集，每个重试都有 2 秒的超时。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">retries:</span></span><br><span class="line">      <span class="attr">attempts:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">perTryTimeout:</span> <span class="string">2s</span></span><br></pre></td></tr></table></figure><h2 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h2><p>熔断器是 <code>Istio</code> 为创建具有弹性的微服务应用提供的另一个有用的机制。在熔断器中，设置一个对服务中的单个主机调用的限制，例如并发连接的数量或对该主机调用失败的次数。一旦限制被触发，熔断器就会“跳闸”并停止连接到该主机。使用熔断模式可以快速失败而不必让客户端尝试连接到过载或有故障的主机。</p><p>熔断适用于在负载均衡池中的“真实”网格目标地址，您可以在目标规则中配置熔断器阈值，让配置适用于服务中的每个主机。下面的示例将 <code>v1</code> 子集的<code>reviews</code>服务工作负载的并发连接数限制为 100：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DestinationRule</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">reviews</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">reviews</span></span><br><span class="line">  <span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">trafficPolicy:</span></span><br><span class="line">      <span class="attr">connectionPool:</span></span><br><span class="line">        <span class="attr">tcp:</span></span><br><span class="line">          <span class="attr">maxConnections:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>您可以在<a href="https://istio.io/latest/zh/docs/tasks/traffic-management/circuit-breaking/">熔断</a>中查看更多相关信息。</p><h2 id="故障注入"><a href="#故障注入" class="headerlink" title="故障注入"></a>故障注入</h2><p>在配置了网络，包括故障恢复策略之后，可以使用 <code>Istio</code> 的故障注入机制来为整个应用程序测试故障恢复能力。故障注入是一种将错误引入系统以确保系统能够承受并从错误条件中恢复的测试方法。使用故障注入特别有用，能确保故障恢复策略不至于不兼容或者太严格，这会导致关键服务不可用。</p><p>与其他错误注入机制（如延迟数据包或在网络层杀掉 <code>Pod</code> 不同，<code>Istio</code> 允许在应用层注入错误。这使您可以注入更多相关的故障，例如 <code>HTTP</code> 错误码，以获得更多相关的结果。</p><p>您可以注入两种故障，它们都使用虚拟服务配置：</p><ul><li><p>延迟：延迟是时间故障。它们模拟增加的网络延迟或一个超载的上游服务。</p></li><li><p>终止：终止是崩溃失败。他们模仿上游服务的失败。终止通常以 HTTP 错误码或 TCP 连接失败的形式出现。</p></li></ul><p>例如，下面的虚拟服务为千分之一的访问 <code>ratings</code> 服务的请求配置了一个 5 秒的延迟：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.istio.io/v1alpha3</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">VirtualService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ratings</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ratings</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">fault:</span></span><br><span class="line">      <span class="attr">delay:</span></span><br><span class="line">        <span class="attr">percentage:</span></span><br><span class="line">          <span class="attr">value:</span> <span class="number">0.1</span></span><br><span class="line">        <span class="attr">fixedDelay:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">route:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">destination:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">ratings</span></span><br><span class="line">        <span class="attr">subset:</span> <span class="string">v1</span></span><br></pre></td></tr></table></figure><p>有关如何配置延迟和终止的详细信息请参考<a href="https://istio.io/latest/zh/docs/tasks/traffic-management/fault-injection/">故障注入</a>。</p><h2 id="和您的应用程序一起运行"><a href="#和您的应用程序一起运行" class="headerlink" title="和您的应用程序一起运行"></a>和您的应用程序一起运行</h2><p><code>Istio</code> 故障恢复功能对应用程序来说是完全透明的。在返回响应之前，应用程序不知道 <code>Envoy sidecar</code> 代理是否正在处理被调用服务的故障。这意味着，如果在应用程序代码中设置了故障恢复策略，那么您需要记住这两个策略都是独立工作的，否则会发生冲突。例如，假设您设置了两个超时，一个在虚拟服务中配置，另一个在应用程序中配置。应用程序为服务的 <code>API</code> 调用设置了 2 秒超时。而您在虚拟服务中配置了一个 3 秒超时和重试。在这种情况下，应用程序的超时会先生效，因此 <code>Envoy</code> 的超时和重试尝试会失效。</p><p>虽然 <code>Istio</code> 故障恢复特性提高了网格中服务的可靠性和可用性，但应用程序必须处理故障或错误并采取适当的回退操作。例如，当负载均衡中的所有实例都失败时，<code>Envoy</code> 返回一个<code>HTTP</code> 503代码。应用程序必须实现回退逻辑来处理<code>HTTP</code> 503错误代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自&lt;a href=&quot;https://istio.io/latest/zh/docs/concepts/traffic-management/&quot;&gt;istio文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;流量管理&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="文档" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%96%87%E6%A1%A3/"/>
    
    <category term="istio" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%96%87%E6%A1%A3/istio/"/>
    
    
    <category term="kubernetes - istio - 文档" scheme="http://kiragoo.github.com/tags/kubernetes-istio-%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Istio-文档-概念</title>
    <link href="http://kiragoo.github.com/archives/6a996a50.html"/>
    <id>http://kiragoo.github.com/archives/6a996a50.html</id>
    <published>2021-05-11T02:44:25.000Z</published>
    <updated>2022-04-21T12:56:45.868Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://istio.io/latest/zh/docs/concepts/what-is-istio/">istio文档</a>,期间加入自己的实践及理解。</p></blockquote><h1 id="Isito是什么"><a href="#Isito是什么" class="headerlink" title="Isito是什么"></a><code>Isito</code>是什么</h1><p>云平台令使用它们的公司受益匪浅。但不可否认的是，上云会给 DevOps 团队带来压力。为了可移植性，开发人员必须使用微服务来构建应用，同时运维人员也正在管理着极端庞大的混合云和多云的部署环境。 Istio 允许您连接、保护、控制和观察服务。</p><p>从较高的层面来说，Istio 有助于降低这些部署的复杂性，并减轻开发团队的压力。它是一个完全开源的服务网格，作为透明的一层接入到现有的分布式应用程序里。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使您能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</p><h1 id="服务网格是什么？"><a href="#服务网格是什么？" class="headerlink" title="服务网格是什么？"></a>服务网格是什么？</h1><p><code>Istio</code> 解决了开发人员和运维人员所面临的从单体应用向分布式微服务架构转变的挑战。了解它是如何做到这一点的可以让我们更详细地理解 <code>Istio</code> 的服务网格。</p><p>术语<strong>服务网格</strong>用来描述组成这些应用程序的微服务网络以及它们之间的交互。随着服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理。它的需求包括服务发现、负载均衡、故障恢复、度量和监控等。服务网格通常还有更复杂的运维需求，比如 <code>A/B</code> 测试、金丝雀发布、速率限制、访问控制和端到端认证。</p><p><code>Istio</code> 提供了对整个服务网格的行为洞察和操作控制的能力，以及一个完整的满足微服务应用各种需求的解决方案。</p><h1 id="为什么使用-Istio？"><a href="#为什么使用-Istio？" class="headerlink" title="为什么使用 Istio？"></a>为什么使用 <code>Istio</code>？</h1><p>通过负载均衡、服务间的身份验证、监控等方法，<code>Istio</code> 可以轻松地创建一个已经部署了服务的网络，而服务的代码只需很少更改甚至无需更改。通过在整个环境中部署一个特殊的 <code>sidecar</code> 代理为服务添加 <code>Istio</code> 的支持，而代理会拦截微服务之间的所有网络通信，然后使用其控制平面的功能来配置和管理 <code>Istio</code>，这包括：</p><ul><li>为 <code>HTTP</code>、<code>gRPC</code>、<code>WebSocket</code> 和 <code>TCP</code> 流量自动负载均衡。</li><li>通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行细粒度控制。</li><li>可插拔的策略层和配置 <code>API</code>，支持访问控制、速率限制和配额。</li><li>集群内（包括集群的入口和出口）所有流量的自动化度量、日志记录和追踪。</li><li>在具有强大的基于身份验证和授权的集群中实现安全的服务间通信。</li></ul><h1 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h1><p><code>Istio</code> 以统一的方式提供了许多跨服务网络的关键功能：</p><h2 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h2><p><code>Istio</code> 简单的规则配置和流量路由允许您控制服务之间的流量和 <code>API</code> 调用过程。<code>Istio</code> 简化了服务级属性（如熔断器、超时和重试）的配置，并且让它轻而易举的执行重要的任务（如 <code>A/B</code> 测试、金丝雀发布和按流量百分比划分的分阶段发布）。</p><p>有了更好的对流量的可视性和开箱即用的故障恢复特性，您就可以在问题产生之前捕获它们，无论面对什么情况都可以使调用更可靠，网络更健壮。<br>请参考<a href="https://istio.io/latest/zh/docs/concepts/traffic-management/">流量管理文档</a>获取更多细节。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><code>Istio</code> 的安全特性解放了开发人员，使其只需要专注于应用程序级别的安全。<code>Istio</code> 提供了底层的安全通信通道，并为大规模的服务通信管理认证、授权和加密。有了 <code>Istio</code>，服务通信在默认情况下就是受保护的，可以让您在跨不同协议和运行时的情况下实施一致的策略——而所有这些都只需要很少甚至不需要修改应用程序。</p><p><code>Istio</code> 是独立于平台的，可以与 <code>Kubernetes</code>（或基础设施）的网络策略一起使用。但它更强大，能够在网络和应用层面保护<code>pod</code>到 <code>pod</code> 或者服务到服务之间的通信。<br>请参考<a href="https://istio.io/latest/zh/docs/concepts/security/">安全文档</a>获取更多细节。</p><h2 id="可观察性"><a href="#可观察性" class="headerlink" title="可观察性"></a>可观察性</h2><p><code>Istio</code> 健壮的追踪、监控和日志特性让您能够深入的了解服务网格部署。通过 <code>Istio</code> 的监控能力，可以真正的了解到服务的性能是如何影响上游和下游的；而它的定制 <code>Dashboard</code> 提供了对所有服务性能的可视化能力，并让您看到它如何影响其他进程。</p><p><code>Istio</code> 的 <code>Mixer</code> 组件负责策略控制和遥测数据收集。它提供了后端抽象和中介，将一部分 <code>Istio</code> 与后端的基础设施实现细节隔离开来，并为运维人员提供了对网格与后端基础实施之间交互的细粒度控制。</p><p>所有这些特性都使您能够更有效地设置、监控和加强服务的 <code>SLO</code>。当然，底线是您可以快速有效地检测到并修复出现的问题。</p><p>请参考<a href="https://istio.io/latest/zh/docs/concepts/observability/">可观察性文档</a>获取更多细节。</p><h1 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h1><p><code>Istio</code> 独立于平台，被设计为可以在各种环境中运行，包括跨云、内部环境、<code>Kubernetes</code>、<code>Mesos</code> 等等。您可以在 <code>Kubernetes</code> 或是装有 <code>Consul</code> 的 <code>Nomad</code> 环境上部署 <code>Istio</code>。<code>Istio</code> 目前支持：</p><ul><li><code>Kubernetes</code> 上的服务部署</li><li>基于 <code>Consul</code> 的服务注册</li><li>服务运行在独立的虚拟机上</li></ul><h1 id="整合和定制"><a href="#整合和定制" class="headerlink" title="整合和定制"></a>整合和定制</h1><p><code>Istio</code> 的策略实施组件可以扩展和定制，与现有的 <code>ACL</code>、日志、监控、配额、审查等解决方案集成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载自&lt;a href=&quot;https://istio.io/latest/zh/docs/concepts/what-is-istio/&quot;&gt;istio文档&lt;/a&gt;,期间加入自己的实践及理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Isi</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="文档" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%96%87%E6%A1%A3/"/>
    
    <category term="istio" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%96%87%E6%A1%A3/istio/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="istio" scheme="http://kiragoo.github.com/tags/istio/"/>
    
    <category term="文档" scheme="http://kiragoo.github.com/tags/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>docker desktop之Istio初体验</title>
    <link href="http://kiragoo.github.com/archives/b47cf59d.html"/>
    <id>http://kiragoo.github.com/archives/b47cf59d.html</id>
    <published>2021-05-08T16:16:48.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<p>本文环境为<code>Mac</code>，其中 <code>Docker Desktop</code>中安装的<code>k8s</code>集群环境的版本为<code>v1.19.7</code>，<code>istio v1.8.1</code></p><h1 id="Istio下载安装"><a href="#Istio下载安装" class="headerlink" title="Istio下载安装"></a><code>Istio</code>下载安装</h1><p>进入<code>Istio</code><a href="https://github.com/istio/istio/releases/tag/1.8.1">发布页面</a>，下载版本<code>istio-1.8.1-osx.tar.gz</code>，然后解压到<code>/usr/local/istio-1.8.1</code>，可以看到下面包含bin及samples文件夹，bin里包含istioctl命令，samples里包含Istio自带的样例应用的部署配置。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/istio-tree.png" alt="istio-tree"></p><h1 id="样例演示"><a href="#样例演示" class="headerlink" title="样例演示"></a>样例演示</h1><p>选择<code>profile=demo</code>，安装命令如下：<br><code>istioctl install --set profile=demo -y</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#会看到如下输出</span></span><br><span class="line">...</span><br><span class="line">✔ Istio core installed                                                                                    </span><br><span class="line">✔ Istiod installed                                                                                        </span><br><span class="line">✔ Egress gateways installed                                                                               </span><br><span class="line">✔ Ingress gateways installed                                                               </span><br><span class="line">✔ Installation complete</span><br></pre></td></tr></table></figure><p>稍等片刻之后，等重要组件<code>Istiod, Ingress Gateway, Egress Gateway</code>都安装完成了。可以发现，其将上述组件安装到了<code>istio-system</code>这个<code>namespace</code>下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods -n istio-system                                                           ✔  00:26:42</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">grafana-784c89f4cf-99bbj                1/1     Running   0          17m</span><br><span class="line">istio-egressgateway-d84f95b69-fkp76     1/1     Running   0          56m</span><br><span class="line">istio-ingressgateway-75f6d79f48-sfqbz   1/1     Running   0          56m</span><br><span class="line">istiod-c9f6864c4-zlmcg                  1/1     Running   0          61m</span><br><span class="line">jaeger-7f78b6fb65-hbhl5                 1/1     Running   0          17m</span><br><span class="line">kiali-7476977cf9-xc7ld                  1/1     Running   0          17m</span><br><span class="line">prometheus-7bfddb8dbf-9gnzl             2/2     Running   0          17m</span><br></pre></td></tr></table></figure><h1 id="Bookinfo样例应用部署"><a href="#Bookinfo样例应用部署" class="headerlink" title="Bookinfo样例应用部署"></a><code>Bookinfo</code>样例应用部署</h1><p>新建一个专门用来演示的<code>namespace istio-demo</code>，且标记该<code>namespace</code>使用<code>istio</code>自动注入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create namespace istio-demo</span><br><span class="line">$ kubectl label namespace istio-demo istio-injection=enabled</span><br></pre></td></tr></table></figure><p>粗略看下<code>Bookinfo</code>的几个模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/istio-1.8.1</span><br><span class="line">$ tree -L 1 samples/bookinfo/src</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── productpage // Bookinfo的页面入口，前后台一体，JavaScript + Python实现</span><br><span class="line">├── details // 图书详情后台服务，Ruby实现</span><br><span class="line">├── reviews // 图书评价后台服务，Java实现，采用Liberty部署</span><br><span class="line">└── ratings // 图书评价等级后台服务，nodejs编写，数据库采用mysql或mongodb</span><br></pre></td></tr></table></figure><p>下面，使用<code>Istio samples</code>文件夹下自带的配置部署<code>Bookinfo</code>应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;istio-1.8.1</span><br><span class="line">$ kubectl apply -n istio-demo -f samples&#x2F;bookinfo&#x2F;platform&#x2F;kube&#x2F;bookinfo.yaml</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">deployment.apps&#x2F;reviews-v1 created</span><br><span class="line">deployment.apps&#x2F;reviews-v2 created</span><br><span class="line">deployment.apps&#x2F;reviews-v3 created</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Bookinfo样例应用访问"><a href="#Bookinfo样例应用访问" class="headerlink" title="Bookinfo样例应用访问"></a><code>Bookinfo</code>样例应用访问</h1><p>查看<code>deployments</code>及<code>pods</code>，发现<code>Bookinfo</code>的各个组件已部署完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n istio-demo     ✔  00:14:09</span><br><span class="line">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">details-v1-79c697d759-fwshg       2/2     Running   0          37m</span><br><span class="line">productpage-v1-65576bb7bf-r7mhk   2/2     Running   0          37m</span><br><span class="line">ratings-v1-7d99676f7f-x4vkn       2/2     Running   0          37m</span><br><span class="line">reviews-v1-987d495c-xc46x         2/2     Running   0          37m</span><br><span class="line">reviews-v2-6c5bf657cf-crsk7       2/2     Running   0          37m</span><br><span class="line">reviews-v3-5f7b9f4f77-nlr7x       2/2     Running   0          37m</span><br></pre></td></tr></table></figure><p>下面我们试着在<code>ratings</code>容器里访问<code>Bookinfo</code>的入口页面<code>productpage</code>。<br>执行命令时，需指定容器为<code>ratings</code>，<code>curl</code>请求<code>productpage</code>，发现页面标题已可正常显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> ratings-v1-7d99676f7f-x4vkn -c ratings -n istio-demo -- curl -s productpage:9080/productpage | grep -o <span class="string">&quot;&lt;title&gt;.*&lt;/title&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">&lt;title&gt;Simple Bookstore App&lt;/title&gt;</span><br></pre></td></tr></table></figure><p>下面看一下该应用如何在集群外部进行访问。涉及到通过配置<code>Istio的Ingress Gateway</code>，从而将流量打到<code>productpage</code>。同样，需要执行下<code>samples</code>文件夹下自带的配置文件。<br><code>$ kubectl apply -n istio-demo -f samples/bookinfo/networking/bookinfo-gateway.yaml</code><br>然后查看下<code>Ingress Gateway</code>的<code>ip</code>及端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get service istio-ingressgateway -n istio-system                                   ✔  00:33:07</span><br><span class="line"></span><br><span class="line">NAME                   TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)                                                                      AGE</span><br><span class="line">istio-ingressgateway   LoadBalancer   10.111.191.125   localhost     15021:31510/TCP,80:32735/TCP,443:32455/TCP,31400:31626/TCP,15443:32135/TCP   64m</span><br></pre></td></tr></table></figure><p>对于本文所采用的<code>Docker Desktop K8s</code>本地部署环境来说，外部IP就是<code>localhost</code>。采用<code>http://localhost/productpage</code>即可访问<code>Bookinfo</code>的<code>productpage</code>页面。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/bookinfo.png" alt="bookinfo"></p><h1 id="Istio-Dashboard安装"><a href="#Istio-Dashboard安装" class="headerlink" title="Istio Dashboard安装"></a><code>Istio Dashboard</code>安装</h1><p>安装一下<code>Istio</code>的几个插件，初步体验里边的一些功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;istio-1.8.1</span><br><span class="line">$ kubectl apply -f samples&#x2F;addons</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">deployment.apps&#x2F;kiali created</span><br><span class="line">deployment.apps&#x2F;prometheus created</span><br><span class="line">deployment.apps&#x2F;jaeger created</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>Kiali 面板<br>输入如下命令打开<code>Kiali</code>面板<br><code>$ istioctl dashboard kiali</code><br>选择对应的<code>namespaces</code>。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/kiali.png" alt="kiali"><br>可以看到，调用关系一目了然，请求由<code>Istio Ingress Gateway</code>进来，首先访问<code>productpage</code>，<code>productpage</code>访问<code>details</code>获取图书详情，<code>productpage</code>访问<code>reviews</code>获取评论，<code>reviews</code>访问<code>ratings</code>获取图书评级。</li><li>打开<code>Jaeger</code>面板<br><code>$ istioctl dashboard jaeger</code><br>左侧<code>Service</code>下拉菜单，选择<code>productpage.istio-demo</code>，从右面的<code>Traces</code>里点击<code>productpage</code>，可以看到如下调用详情。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/jaeger.png" alt="jaeger"><br>调用链以时间序横向展示，同样可以看到请求由<code>istio-ingressgateway</code>进来到达<code>productpage，productpage</code>调用<code>details</code>及<code>reviews</code>，<code>reviews</code>调用<code>ratings</code>，每个调用的时间花费亦显示了出来。<h1 id="Istio卸载"><a href="#Istio卸载" class="headerlink" title="Istio卸载"></a><code>Istio</code>卸载</h1></li><li>卸载<code>addons</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/istio-1.8.1</span><br><span class="line">$ kubectl delete -f samples/addons</span><br></pre></td></tr></table></figure></li><li>卸载<code>Bookinfo</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/istio-1.8.1</span><br><span class="line">$ kubectl delete -n istio-demo -f samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line">$ kubectl delete -n istio-demo -f samples/bookinfo/networking/bookinfo-gateway.yaml</span><br></pre></td></tr></table></figure></li><li>卸载<code>Istio</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istioctl manifest generate --<span class="built_in">set</span> profile=demo | kubectl delete --ignore-not-found=<span class="literal">true</span> -f -</span><br></pre></td></tr></table></figure></li><li>删除<code>namespace istio-system</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete namespace istio-system</span><br></pre></td></tr></table></figure></li><li>取消对<code>istio-demo</code>进行<code>Istio</code>自动注入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label namespace istio-demo istio-injection-</span><br></pre></td></tr></table></figure></li><li>删除<code>namespace istio-demo</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete namespace istio-demo</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>转载<a href="https://leileiluoluo.com/posts/istio-get-started.html">磊磊落落-<code>Isoti使用</code></a>，个人实战踩坑已验证无问题。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文环境为&lt;code&gt;Mac&lt;/code&gt;，其中 &lt;code&gt;Docker Desktop&lt;/code&gt;中安装的&lt;code&gt;k8s&lt;/code&gt;集群环境的版本为&lt;code&gt;v1.19.7&lt;/code&gt;，&lt;code&gt;istio v1.8.1&lt;/code&gt;&lt;/p&gt;
&lt;h1 id</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="istio" scheme="http://kiragoo.github.com/categories/kubernetes/istio/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="istio" scheme="http://kiragoo.github.com/tags/istio/"/>
    
  </entry>
  
  <entry>
    <title>controller-client-go机制简介</title>
    <link href="http://kiragoo.github.com/archives/8e7c42c2.html"/>
    <id>http://kiragoo.github.com/archives/8e7c42c2.html</id>
    <published>2021-05-06T09:43:33.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md">controller-client-go</a>,个人翻译。</p></blockquote><h1 id="client-go-under-the-hood"><a href="#client-go-under-the-hood" class="headerlink" title="client-go under the hood"></a><code>client-go under the hood</code></h1><p><a href="https://github.com/kubernetes/client-go/">client-go</a>库包含了多种机制，我们可以在开发自定义的<code>controllers</code>的时候使用这些机制。这些机制定义在<a href="https://github.com/kubernetes/client-go/tree/master/tools/cache">tools/cache folder</a>库中。<br>下图展示了<code>client-go</code>中的各种组件如何运行以及与我们自定义的<code>controller</code>是如何交互的。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/client-go-controller-interaction.jpeg" alt="client-go-controller-interaction"></p><hr><h1 id="client-go-components"><a href="#client-go-components" class="headerlink" title="client-go components"></a><code>client-go components</code></h1><ul><li><code>Reflector</code>：定义在<a href="https://github.com/kubernetes/client-go/blob/master/tools/cache/reflector.go">type Reflector inside package cache</a>,<code>watch</code>着<code>Kubernetes API</code>中具体的<code>resource type(kind)</code>。此功能是在 <em><code>ListAndWatch</code></em> 中实现的。<code>watch</code> 的资源可以是内置的<code>k8s</code>资源也可以是自定义的资源。当<code>reflector</code>通过<code>watch API</code>接收到新的资源实例的存在的话，它将通过相关<code>listing API</code>接口获取到新创建的资源，并将其放在<code>Delta Fifo</code>队列中。</li><li><code>Informer</code>：定义在<a href="https://github.com/kubernetes/client-go/blob/master/tools/cache/controller.go">base controller inside package cache</a>将从<code>Delta Fifo</code>队列中<code>pop</code>出对象。此功能通过<code>processLoop</code>实现。<code>base controller</code>的工作即保存此对象以便后续的检索，以便调用我们的控制器并将对象传递给它们。</li><li><code>Indexer</code>：提供对象的索引功能。其定义在<a href="https://github.com/kubernetes/client-go/blob/master/tools/cache/index.go">type Indexer inside package cache</a>。<br>一个典型的<code>indexing</code>使用场景就是基于对象的<code>labels</code>来创建索引。<code>Indexer</code>是线程安全的来存储对象以及它们的<code>key</code>，在<a href="https://github.com/kubernetes/client-go/blob/master/tools/cache/store.go">type Store inside package cache</a>定义了默认的 <em><code>MetaNamespaceKeyFunc</code></em> 的方法来生成该对象的 <code>key</code>，形如<code>&lt;namespace&gt;/&lt;name&gt;</code>的组合。</li></ul><h1 id="Custom-Controller-components"><a href="#Custom-Controller-components" class="headerlink" title="Custom Controller components"></a><code>Custom Controller components</code></h1><ul><li><code>Informer reference</code>：<code>Informer reference</code> 知晓如何与自定义的资源对象协同工作。在我们自定义的<code>controller</code>中需要构建相关的<code>Informer</code>。</li><li><code>Indexer reference</code>：<code>Indexer reference</code> 知晓如何与自定义的资源对象协同工作。我们自定义的<code>controller</code>需要创建它们。我们将使用这个引用来检索对象，以便以后进行处理。</li></ul><p><code>client-go</code> 提供的<code>base controller</code>中已经提供了<code>NewIndexerInformer</code>函数来创建<code>Informer</code>和<code>Indexer</code>，我们也可以通过<a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go#L174">直接调用此函数</a>或者<a href="https://github.com/kubernetes/sample-controller/blob/master/main.go#L61">使用工厂方法来创建通知者</a>。</p><ul><li><code>Resource Event Handlers</code>：<code>Informer</code>将会调用其中的回调函数将其中的对象传递给我们的<code>controller</code>。函数中典型的参数维护着那些将要分发的对象的<code>key</code>并将此<code>key</code>入队列以便后续处理。</li><li><code>Work Queue</code>：此<code>work queue</code>主要用于解耦作用。资源事件处理器函数用于提取对象的<code>key</code>并将其添加到工作队列中。</li><li><code>Process Item</code>：用于处理工作队列中的元素项目。在其中可以有一个或者多个执行实际处理逻辑的行数。这些函数通常使用<a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go#L73"><code>Indexer reference</code></a>或者<code>Listing wrapper</code>来检索与<code>key</code>对应的相关对象。</li></ul>]]></content>
    
    
    <summary type="html">client-go 机制简介</summary>
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="文档" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%96%87%E6%A1%A3/"/>
    
    <category term="翻译" scheme="http://kiragoo.github.com/categories/kubernetes/%E6%96%87%E6%A1%A3/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="client-go" scheme="http://kiragoo.github.com/tags/client-go/"/>
    
    <category term="翻译" scheme="http://kiragoo.github.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 系列之负载均衡（五)</title>
    <link href="http://kiragoo.github.com/archives/16e48aa0.html"/>
    <id>http://kiragoo.github.com/archives/16e48aa0.html</id>
    <published>2021-05-05T12:38:46.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于<a href="https://kiragoo.github.io/archives/c41b2749.html">章节（四）文章</a>中引入了拓展思考，在很多场景下，我们需要自定义 Ribbon 的配置，此篇主要 demo 示例为修改 Ribbon 的负载均衡策略。</p><hr><h1 id="Ribbon-配置自定义"><a href="#Ribbon-配置自定义" class="headerlink" title="Ribbon 配置自定义"></a><code>Ribbon</code> 配置自定义</h1><p>配置自定义可以分为如下两种：</p><ol><li>使用 <code>Java</code> 代码自定义 <code>Ribbon</code> 配置，配置指定名称的 <code>Ribbon Client</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IClientConfig ribbonClientConfig: DefaultClientConfigImpl</span><br><span class="line">IRule ribbonRule: ZoneAvoidanceRule</span><br><span class="line">IPing ribbonPing: DummyPing</span><br><span class="line">ServerList&lt;Server&gt; ribbonServerList: ConfigurationBasedServerList</span><br><span class="line">ServerListFilter&lt;Server&gt; ribbonServerListFilter: ZonePreferenceServerListFilter</span><br><span class="line">ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</span><br><span class="line">ServerlistUpdater ribbonServerListUpdater: PolingServerListUpdater</span><br></pre></td></tr></table></figure>实际上就是通过注解声明式的实现了 <code>Ribbon Client</code> 的负载均衡策略</li><li>使用属性自定义 <code>Ribbon</code> 配置，客观感觉此种方式也是比 <code>Java</code> 代码配置的方式更加方便，此章节的 <code>demo</code> 示例也是基于此种形式实现的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NFLoadBalancerClassName: 配置 ILoadBalancer 的实现类</span><br><span class="line">NFLoadBalancerRuleClassName: 配置 IRule 的实现类</span><br><span class="line">NFLoadBalancePingClassName：配置 IPing 的实现类</span><br><span class="line">NIWSServerlistClassName: 配置 ServerList 的实现类</span><br><span class="line">NIWSServerListFilterClassName：配置 ServerListFilter 的实现类</span><br></pre></td></tr></table></figure><h1 id="项目组织结构"><a href="#项目组织结构" class="headerlink" title="项目组织结构"></a>项目组织结构</h1><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc5-1.png" alt="sc5-1"><h1 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h1><h2 id="microservice-consumer-moive-ribbon"><a href="#microservice-consumer-moive-ribbon" class="headerlink" title="microservice-consumer-moive-ribbon"></a><code>microservice-consumer-moive-ribbon</code></h2></li></ol><ul><li><code>application.yaml</code> 中通过定义配置来实现负载均衡策略，追加如下内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">microservice-provider-user-ribbon:</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalanceerRuleClassName: com.netflix.loadbalancer.RnadomRule</span><br></pre></td></tr></table></figure></li><li>另外两个服务无需改动*<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2>启动 <code>microservice-discovery-eureka</code> 实例一个，<code>microservice-consumer-moive-ribbon-customizing-properties</code> 实例一个，<code>microservice-provider-user-ribbonn</code> 实例一个，如果运行无误的情况下会嗨皮的发下 <code>Eureka Portal</code> 页面如下:<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc5-2.png" alt="sc5-2"></li></ul><p>多次请求 <code>consumer user-log-instance</code> 接口，查看 <code>provider</code> 日志会发现，请求响应的实例确实发生了变化：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc5-3.png" alt="sc5-3"><br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc5-4.png" alt="sc5-4"></p><blockquote><p><a href="https://github.com/Tonyzhangl/spring-cloud-demo/tree/master/chapter3-2">示例代码链接</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;鉴于&lt;a href=&quot;https://kiragoo.github.io/archives/c41b2749.html&quot;&gt;章节（四）文章&lt;/a&gt;中引入了拓展思考，在很多场景下，我们需要自定义 Ribbon 的配置，此篇主要 demo 示例为修改 Ribbon 的负载均衡策略</summary>
      
    
    
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/categories/spring-cloud/"/>
    
    <category term="java" scheme="http://kiragoo.github.com/categories/spring-cloud/java/"/>
    
    
    <category term="java" scheme="http://kiragoo.github.com/tags/java/"/>
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 系列之负载均衡（四）</title>
    <link href="http://kiragoo.github.com/archives/c41b2749.html"/>
    <id>http://kiragoo.github.com/archives/c41b2749.html</id>
    <published>2021-05-03T09:36:58.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<p>通过前几篇章节，初步认识了通过 <code>RestTemplate</code> 调用微服务拆分的服务的 <code>rest</code> 请求，进一步引入了通过 <code>Eureka</code> 来实现服务注册于发现（此部分的拓展内容其实还有很多，牵扯到自定义元数据及 <code>Eureka</code> 的自我保护等）。</p><p>那么问题来了，在实际的场景中我们会遇到很多服务端其实是存在多个副本以实现高可用，那么客户端的请求是如何做分发控制的呢？当然，朋友你肯定第一个想到的是老毛子搞的 <code>nginx</code>。Nice！！nginx 确实很强大，基于 nginx 我们能做很多事情【后续我也会对 nginx 做进一步的分享：）】。在 <code>Spring Cloud</code> 生态圈，其实大佬们早已准备好了开箱即用的组件，就是今天的主角：**<code>Riboon</code>**。</p><hr><h1 id="Eureka-与-Ribbon-配合的架构图"><a href="#Eureka-与-Ribbon-配合的架构图" class="headerlink" title="Eureka 与 Ribbon 配合的架构图"></a><code>Eureka</code> 与 <code>Ribbon</code> 配合的架构图</h1><p><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc4-1.jpeg" alt="sc4-1"></p><h1 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h1><h2 id="microservice-consumer-movie-ribbon"><a href="#microservice-consumer-movie-ribbon" class="headerlink" title="microservice-consumer-movie-ribbon"></a><code>microservice-consumer-movie-ribbon</code></h2><p>将之前的 <code>microservice-consumedr-movie</code> 整合 <code>Ribbon</code> 改造下。</p><ul><li><code>pom</code> 文件<br>由于此微服务还是 <code>Eureka</code> 的 <code>Client</code> 端，所以依赖中还是会存在 <code>eureka client</code> 的依赖，同时加入新的依赖 <code>netflix-ribbon</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.kirago.sc&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;microserver-consumer-movie-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;microserver-consumer-movie-ribbon&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;microserver-consumer-movie-ribbon project for Spring cloud&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Greenwich.SR1&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;&#x2F;dependency&gt;--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure></li><li>为 <code>RestTemplate</code> 添加 <code>@LoadBalanced</code> 的注解进行声明。<br>此部分我是通过 <code>@Configuration</code> 注解 后加入 <code>@Bean</code> 注解，来告知应用生成这个 <code>Bean</code>。<br>此处有个知识点，可以拓展下 <code>@Configuration</code> 的具体作用：</li></ul><ol><li>在实际的项目开发中，我引用的类可能不在当前包中那么如何处理？</li><li>还有我们很多时候会发现一个类被 @Configuration 注解了实际上类的内部为空，那么这个 @Configuration 存在的意思是啥，为啥需要它？<br>以上都是需要掌握的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.kirago.sc.microserverconsumermovieribbon.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RestTemplateCompoment &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate restTemplate()&#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="服务生产者"><a href="#服务生产者" class="headerlink" title="服务生产者"></a>服务生产者</h1><h2 id="microservice-priovider-user-ribbon"><a href="#microservice-priovider-user-ribbon" class="headerlink" title="microservice-priovider-user-ribbon"></a>microservice-priovider-user-ribbon</h2><p>在完善此 <code>demo</code> 的时候由于是单机本地环境，所以我们需要通过对同一个应用启动应用多个端口来来实现生成多个实例来模拟多节点多副本的场景，我是通过 <code>IDEA</code> 中采用配置去实现的。<br>具体的实现方式参考 <a href="https://blog.csdn.net/dyr_1203/article/details/84876380">csdn 上的一篇文章</a>，亲测有效。<br><em>此篇 服务消费者没啥改动，所以我就不贴示例代码了。</em></p><h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="microservice-discovery-eureka"><a href="#microservice-discovery-eureka" class="headerlink" title="microservice-discovery-eureka"></a><code>microservice-discovery-eureka</code></h2><p><em>此服务也未作任何变动，所以此部分就不重复了。：）</em></p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>启动 <code>microservice-discovery-eureka</code>、<code>microservice-consumer-movie-ribbon</code>、<code>microservice-discovery-eureka</code>（我设置的副本数为2），成功运行的情况下去浏览 <code>Eureka</code> 服务的监控页面，会看到如下内容：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc4-2.png" alt="sc4-2"><br>我们会发现服务生产者副本数为2，说明多副本服务创建成功了。</p><blockquote><p>各位老铁应该注意到我特意标注了 A 点，这里就卖个关子，作为自己拓展思考，此处为啥会有红色字体的 Warnninng，以及这种展示是否是可控的，如果是可控的要做什么配置修改？：）<br>下面我们可以发送请求进一步验证下</p></blockquote><ul><li>对服务生产者直接请求：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc4-3.png" alt="sc4-3"><br>此处我故意请求的是我创建的服务生产者多副本实例2，验证下服务确实可用。</li><li>对服务消费者发送请求：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc4-4.png" alt="sc4-4"><br>由此验证最终结果是保持一致的。</li><li>通过后台日志我们其实可以发现最终的请求最终落在那个服务生产者示例上：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc4-5.png" alt="sc4-5"><br>此次通过服务消费者消费的服务是落在服务生产者多副本的实例1上。</li></ul><blockquote><p>多啰嗦几句<br>此偏章节为 Eureka 结合 Ribbon 实现负载均衡，在实际的生产项目中，我们的服务器会处理性能不一致，遵循“能者多劳”的原则，我们可能要适当的对负载分发有一定的可控机制，或者由于目前容器技术 docker 的新起，一台服务器我们会尽量的压榨资源，那么在部署架构上我们已经有了规划，那么对负载分发也要有一定的可控机制去实现，这些在实际的生产过程中我认为都是需要考虑的。<br><a href="https://github.com/Tonyzhangl/spring-cloud-demo/tree/master/chapter3">示例代码链接</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过前几篇章节，初步认识了通过 &lt;code&gt;RestTemplate&lt;/code&gt; 调用微服务拆分的服务的 &lt;code&gt;rest&lt;/code&gt; 请求，进一步引入了通过 &lt;code&gt;Eureka&lt;/code&gt; 来实现服务注册于发现（此部分的拓展内容其实还有很多，牵扯到自定义元</summary>
      
    
    
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/categories/spring-cloud/"/>
    
    <category term="java" scheme="http://kiragoo.github.com/categories/spring-cloud/java/"/>
    
    
    <category term="java" scheme="http://kiragoo.github.com/tags/java/"/>
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud 系列之服务注册与发现（三）</title>
    <link href="http://kiragoo.github.com/archives/a1a3f20a.html"/>
    <id>http://kiragoo.github.com/archives/a1a3f20a.html</id>
    <published>2021-05-03T09:32:01.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于上篇内容提出的思考拓展部分，此部门其实就是做了 application.yaml 的配置文件的更改。此篇的 Demo 通过单节点多端口来模拟多节点分布的 Eureka Server HA 集群。由于篇幅比较简单，我就直接将 microservice-discovery-eureka 做了 yaml 配置文件更改最终输出为 microservice-discovery-eureka-ha 的模块，就暂且不实现生产者服务和消费者服务了。</p><hr><h1 id="Eureka-Server-HA"><a href="#Eureka-Server-HA" class="headerlink" title="Eureka Server HA"></a><code>Eureka Server HA</code></h1><h2 id="microservice-discovery-eureka-ha"><a href="#microservice-discovery-eureka-ha" class="headerlink" title="microservice-discovery-eureka-ha"></a><code>microservice-discovery-eureka-ha</code></h2><ul><li><p><code>application.yaml</code> 文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: microserver-discovery-eureka-ha</span><br><span class="line">#eureka:</span><br><span class="line">#  client:</span><br><span class="line">#    service-url:</span><br><span class="line">#      defaultZone: http:&#x2F;&#x2F;peer1:8001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;peer2:8002&#x2F;eureka&#x2F;</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  profiles: peer1</span><br><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;peer2:8002&#x2F;eureka&#x2F;</span><br><span class="line">#    fetch-registry: true</span><br><span class="line">#    register-with-eureka: true</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  profiles: peer2</span><br><span class="line">server:</span><br><span class="line">  port: 8002</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer2</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;peer1:8001&#x2F;eureka&#x2F;</span><br><span class="line">#    fetch-registry: true</span><br><span class="line">#    register-with-eureka: true</span><br></pre></td></tr></table></figure></li><li><p>配置本地 <code>hosts</code> 文件：</p></li><li><p><em>由于是本地单节点模拟，为了能够解析到 domain 需要加如下配置</em>*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 peer1</span><br><span class="line"></span><br><span class="line">127.0.0.1 peer2</span><br></pre></td></tr></table></figure></li><li><p> 通过 <code>package</code> 打成 <code>jar</code> 包运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar microservice-discovery-eureka-ha&#x2F;target&#x2F;microservice-discovery-eureka-ha-0.0.1-SNAPSHOT.jar --spring.profiles.active&#x3D;peer1</span><br><span class="line">java -jar microservice-discovery-eureka-ha&#x2F;target&#x2F;microservice-discovery-eureka-ha-0.0.1-SNAPSHOT.jar --spring.profiles.active&#x3D;peer2</span><br></pre></td></tr></table></figure></li><li><p>验证<br>成功运行后会嗨皮发现最终页面如下：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc3-1.png" alt="sc3-1"><br>当然这是我在浏览器输入 <a href="http://peer1:8001/">http://peer1:8001</a> 得到的输出,然后我们可以通过启动上篇的生产者服务和消费者服务，然后将其中的一个 Eureka Server 宕掉，发现服务还是可用的，即完成了验证。</p></li></ul><blockquote><p><a href="https://github.com/Tonyzhangl/spring-cloud-demo/tree/master/chapter2-2">示例代码链接</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;鉴于上篇内容提出的思考拓展部分，此部门其实就是做了 application.yaml 的配置文件的更改。此篇的 Demo 通过单节点多端口来模拟多节点分布的 Eureka Server HA 集群。由于篇幅比较简单，我就直接将 microservice-discovery-</summary>
      
    
    
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/categories/spring-cloud/"/>
    
    <category term="java" scheme="http://kiragoo.github.com/categories/spring-cloud/java/"/>
    
    
    <category term="java" scheme="http://kiragoo.github.com/tags/java/"/>
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud系列之服务注册与发现（二）</title>
    <link href="http://kiragoo.github.com/archives/68bcbff6.html"/>
    <id>http://kiragoo.github.com/archives/68bcbff6.html</id>
    <published>2021-05-03T09:18:26.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于<a href="https://kiragoo.github.io/archives/1985234d.html">上篇初识（一）</a>引入如下思考：<br>如果每个组件的服务分布在不同的节点，那么通过每次的硬编码去实现域名（服务识别）解析是多么痛苦的一件事，况且还没有涉及到服务的主动发现。这个时候我们急需引用一种方案来解决此问题，那么此阶段我将引入 EureKa 的应用。而在 Dubbo 体系中是通过 Zookeeper 集群来实现服务注册与发现的，后续有机会将会对 Dubbo 做学习与分析。</p><h1 id="Eureka-架构"><a href="#Eureka-架构" class="headerlink" title="Eureka 架构"></a>Eureka 架构</h1><p><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc2-1.png" alt="sc2-1"><br>通过架构图我们会发现实际上 Eureka 包含两个组件：Eureka Server 和 Eureka Client，它们的作用如下：</p><ul><li>Eureka Server 提供服务发现的能力（这种能力个人理解是被动的），即各个微服务启动的时候会主动向 Server 注册自己的信息（例如IP、端口、微服务名称等）</li><li>Eureka Client 则是一个客户端，与 Eureka Server 进行交互</li><li>微服务启动后会周期性的（默认为30s）向 Server 端发送心跳，以证明自己是存活状态，以此“续约”租期</li><li>如果 Server 端在一定时间内未接收到某个微服务发送的心跳，则 Server 会注销该实例（默认为90s）。【拓展：没有收到心跳可能有多种原因引起的，在业务上可能由于网络抖动或者瞬时高峰引起的问题，面对这种现象实际上在架构时就应该考虑，后面我会做进一步的学习分享。】</li><li>默认情况下，Eureka Server 同时也是 Eureka Client，当时这是配置可控的。多个 Eureka Server 实例之间会通过复制来实现服务注册表中的数据同步。</li><li>Eureka Client 会缓存服务注册表中的信息。这样有利于减轻对 Server 端的压力，而且即使短暂的 Server 端宕掉或者出现问题，Client 也可以通过缓存数据完成调用。</li></ul><p>以下我会根据系列（一）的文章进行拓展，在原来的基础上进行拓展，整体工程组织如下图：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc2-2.png" alt="sc2-2"><br>比系列文章(一)多了 Server 服务。</p><h1 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h1><h2 id="microservice-discover-eureka"><a href="#microservice-discover-eureka" class="headerlink" title="microservice-discover-eureka"></a>microservice-discover-eureka</h2><ul><li><code>pom</code>文件如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.kirago.sc&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;microservice-discovery-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;microservice-discovery-eureka&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;microservice-discovery-eureka project for Spring cloud&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Greenwich.SR1&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;scope&gt;test&lt;&#x2F;scope&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;&#x2F;dependency&gt;--&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure></li><li>启动类通过注解 @EnableEurekaServer 声明为此应用为 Eureka Server<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.kirago.sc.microservicediscoveryeureka;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer</span><br><span class="line">public class MicroserviceDiscoveryEurekaApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MicroserviceDiscoveryEurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>application.yaml 配置文件如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8000</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false    #标识是否将自己注册到 Eureka Server 中，默认为 true。</span><br><span class="line">    fetch-registry: false    #表示是否从 Eureka Server 获取注册信息，默认为 true，由于此 demo 为单点 Server，不需要同步其他的 Server，故配置为 false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8000&#x2F;eureka&#x2F;    #设置与 Eureka Server 交互的地址，默认端口为 8761，这里先卖个关子，就是某些配置问题或者再导入已有项目的时候尤其是如 IDEA 这种工具如果配置没做好的话就会引用默认端口，而没法示例化自己配置的端口，反正我是遇到。</span><br></pre></td></tr></table></figure>这样 Eureka Server 就算是配置好了，如果运行没有问题，我们会嗨皮的发现如下的页面：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc2-3.png" alt="sc2-3"><br>这个时候我们下一步需要做的就是将 Eureka Client 注册到 Eureka Client 中了，话不多说，直接撸起来。</li></ul><h1 id="服务提供者微服务"><a href="#服务提供者微服务" class="headerlink" title="服务提供者微服务"></a>服务提供者微服务</h1><h2 id="microservice-provider-user"><a href="#microservice-provider-user" class="headerlink" title="microservice-provider-user"></a>microservice-provider-user</h2><ul><li><code>pom</code>文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.kirago.sc&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;microservice-provider-user&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;microservice-provider-user&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;microservice-provider-user project for Spring cloud&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Greenwich.SR1&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure></li><li><code>application.yaml</code> 文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: microservice-provider-user    #用于指定注册到 Eureka Server 上的应用名称</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    generate-ddl: false</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line"></span><br><span class="line">  datasource:</span><br><span class="line">    platform: h2</span><br><span class="line">    schema: classpath:sql&#x2F;schema.sql</span><br><span class="line">    data: classpath:sql&#x2F;data.sql</span><br><span class="line">    url: jdbc:h2:mem:dbtest</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: org.h2.Driver</span><br><span class="line">  h2:</span><br><span class="line">    console:</span><br><span class="line">      settings:</span><br><span class="line">        web-allow-others: true</span><br><span class="line">      path: &#x2F;h2</span><br><span class="line">      enabled: true</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: INFO</span><br><span class="line">    org.hibernate: INFO</span><br><span class="line">    org.hibernate.type.descriptor.sql.BasicBinder: TRACE</span><br><span class="line">    org.hibernate.type.descriptor.sql.BasicExtractor: TRACE</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8000&#x2F;eureka&#x2F;</span><br><span class="line">  instance:</span><br><span class="line">    perfer-ip-address: true    #表示将自己的 IP 注册到 Eureka Server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8001</span><br></pre></td></tr></table></figure></li><li>编写启动类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.kirago.sc.microserviceprovideruser;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class MicroserviceProviderUserApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MicroserviceProviderUserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="服务消费者微服务"><a href="#服务消费者微服务" class="headerlink" title="服务消费者微服务"></a>服务消费者微服务</h1><h2 id="microservice-consumer-movie"><a href="#microservice-consumer-movie" class="headerlink" title="microservice-consumer-movie"></a>microservice-consumer-movie</h2>同理我们也需将服务消费者注册到 Eureka Server 中。具体实现就不写了，后面我会在文章的末尾处附上本人 github 上的代码链接。由于是 demo ，在其中 controller 层中，我就直接做了硬编码处理。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc2-4.png" alt="sc2-4"></li><li>单独测试 <code>microservice-provider-user</code> 微服务接口如下：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc2-5.png" alt="sc2-5"></li><li>通过 <code>microservice-consumer-movie</code> 微服务接口如下：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc2-6.png" alt="sc2-6"></li></ul><hr><p>在这里留个思考题，就是上面有解释到 Eureka Server 其实是可以做多副本高可用的，那么可以拓展了解下如何去做配置，还有一般来说 Eureka 在实际的场景中也是需要通过用户认证访问，这些其实在前期都是需要考虑的，有兴趣的可以拓展了解下</p><blockquote><p><a href="https://github.com/Tonyzhangl/spring-cloud-demo/tree/master/chapter2">示例代码链接</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;鉴于&lt;a href=&quot;https://kiragoo.github.io/archives/1985234d.html&quot;&gt;上篇初识（一）&lt;/a&gt;引入如下思考：&lt;br&gt;如果每个组件的服务分布在不同的节点，那么通过每次的硬编码去实现域名（服务识别）解析是多么痛苦的一件事，况且还</summary>
      
    
    
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/categories/spring-cloud/"/>
    
    <category term="java" scheme="http://kiragoo.github.com/categories/spring-cloud/java/"/>
    
    
    <category term="java" scheme="http://kiragoo.github.com/tags/java/"/>
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud系列之初识(一)</title>
    <link href="http://kiragoo.github.com/archives/1985234d.html"/>
    <id>http://kiragoo.github.com/archives/1985234d.html</id>
    <published>2021-05-03T03:16:28.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>由于是开篇，先撇开springcloud的各种核心组件，来个demo 简单的认知下。话不多说直接开撸。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>简单场景如下图</p><p><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc1-1.png" alt="sc1-1"></p><h1 id="编写服务提供者"><a href="#编写服务提供者" class="headerlink" title="编写服务提供者"></a>编写服务提供者</h1><h2 id="microservice-simple-provider-user"><a href="#microservice-simple-provider-user" class="headerlink" title="microservice-simple-provider-user"></a>microservice-simple-provider-user</h2><ul><li>引入pom依赖文件如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.kirago.sc&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;microservice-simple-provider-user&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;microservice-simple-provider-user&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;microservice-simple-provider-user project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;scope&gt;runtime&lt;&#x2F;scope&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;&#x2F;dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.h2database&#x2F;h2 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.h2database&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;h2&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.197&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>数据库访问采用内嵌数据库H2来做 demo 的持久化结合JPA来搞。</li><li>服务提供者的yaml文件配置如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8000</span><br><span class="line">spring:</span><br><span class="line">  jpa:</span><br><span class="line">    generate-ddl: false</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line"></span><br><span class="line">  datasource:</span><br><span class="line">    platform: h2</span><br><span class="line">    schema: classpath:sql&#x2F;schema.sql #数据scchema sql</span><br><span class="line">    data: classpath:sql&#x2F;data.sql #数据初始化sql</span><br><span class="line">    url: jdbc:h2:mem:dbtest</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: org.h2.Driver</span><br><span class="line">  h2:</span><br><span class="line">    console:</span><br><span class="line">      settings:</span><br><span class="line">        web-allow-others: true #开启web页面端</span><br><span class="line">      path: &#x2F;h2 #uri路径</span><br><span class="line">      enabled: true #开启远端访问</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: INFO</span><br><span class="line">    org.hibernate: INFO</span><br><span class="line">    org.hibernate.type.descriptor.sql.BasicBinder: TRACE</span><br><span class="line">    org.hibernate.type.descriptor.sql.BasicExtractor: TRACE </span><br></pre></td></tr></table></figure></li><li>schema sql 如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drop table user if exists;</span><br><span class="line">create table user (</span><br><span class="line">    id bigint generated by default as identity,</span><br><span class="line">    username varchar(48),</span><br><span class="line">    name varchar(20),</span><br><span class="line">    age int(3),</span><br><span class="line">    balance decimal(10,2),</span><br><span class="line">    primary key (id));</span><br></pre></td></tr></table></figure></li><li>data.sql如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into user (id, username, name, age, balance) values (1, &#39;account1&#39;, &#39;张三&#39;, 20, 100.00);</span><br><span class="line">insert into user (id, username, name, age, balance) values (2, &#39;account2&#39;, &#39;李四&#39;, 21, 101.00);</span><br><span class="line">insert into user (id, username, name, age, balance) values (3, &#39;account3&#39;, &#39;王五&#39;, 22, 111.00);</span><br></pre></td></tr></table></figure></li><li>登录H2内存服务器结果显示如下：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc1-2.png" alt="sc1-2"></li><li>controller层如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.kirago.sc.microservicesimpleprovideruser.controller;</span><br><span class="line"></span><br><span class="line">import com.kirago.sc.microservicesimpleprovideruser.entity.User;</span><br><span class="line">import com.kirago.sc.microservicesimpleprovideruser.repository.UserRepository;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public User findById(@PathVariable Long id)&#123;</span><br><span class="line"></span><br><span class="line">        Optional&lt;User&gt; user &#x3D; userRepository.findById(id);</span><br><span class="line">        return user.get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实体类如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.kirago.sc.microservicesimpleprovideruser.entity;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import javax.persistence.*;</span><br><span class="line">import java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@Data</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy &#x3D; GenerationType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Column</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    @Column</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Column</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    @Column</span><br><span class="line">    private BigDecimal balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Dao层：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.kirago.sc.microservicesimpleprovideruser.repository;</span><br><span class="line"></span><br><span class="line">import com.kirago.sc.microservicesimpleprovideruser.entity.User;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过postman 发送请求测试验证如下：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc1-3.png" alt="sc1-3"><h1 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h1><h2 id="microservice-simple-consumer-movie"><a href="#microservice-simple-consumer-movie" class="headerlink" title="microservice-simple-consumer-movie"></a>microservice-simple-consumer-movie</h2>由于此部分内容比较简单就是构建好消费者需要获取的用户，直接构建了一个POJO，然后通过RestTemplate去请求服务提供者。</li></ul><p>重点注意的就是 controller 层中的用法而已，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.kirago.sc.microservicesimpleconsumermovie.controller;</span><br><span class="line"></span><br><span class="line">import com.kirago.sc.microservicesimpleconsumermovie.entity.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class MovieController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;user.userServiceUrl&#125;&quot;)</span><br><span class="line">    private String userServiceUrl;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public User findById(@PathVariable Long id)&#123;</span><br><span class="line">        return restTemplate.getForObject(userServiceUrl + id, User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此 demo 为了避免 userServiceUrl 的硬编码，通过 @Value 注解获取 yaml 配置文件的环境变量实现。</p><ul><li>消费者 yaml 配置如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user:</span><br><span class="line">  userServiceUrl: http:&#x2F;&#x2F;localhost:8000&#x2F;</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8001</span><br></pre></td></tr></table></figure></li><li> 通过 postman 发送请求验证如下：<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/sc1-4.png" alt="sc1-4"><br><a href="https://github.com/Tonyzhangl/spring-cloud-demo/tree/master/chapter1">示例代码链接</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识&quot;&gt;&lt;a href=&quot;#初识&quot; class=&quot;headerlink&quot; title=&quot;初识&quot;&gt;&lt;/a&gt;初识&lt;/h1&gt;&lt;p&gt;由于是开篇，先撇开springcloud的各种核心组件，来个demo 简单的认知下。话不多说直接开撸。&lt;/p&gt;
&lt;h1 id=&quot;场景&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/categories/spring-cloud/"/>
    
    <category term="java" scheme="http://kiragoo.github.com/categories/spring-cloud/java/"/>
    
    
    <category term="java" scheme="http://kiragoo.github.com/tags/java/"/>
    
    <category term="spring cloud" scheme="http://kiragoo.github.com/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes跨namespace资源借用及资源归还控制</title>
    <link href="http://kiragoo.github.com/archives/f656d80b.html"/>
    <id>http://kiragoo.github.com/archives/f656d80b.html</id>
    <published>2021-04-30T06:54:16.000Z</published>
    <updated>2022-04-21T12:56:45.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p> 在多租户的场景下，提供一种跨<code>namespace</code>的资源“借用”途径，在资源池建设之后进一步提升资源的利用率。在还资源过程中，期望能够控制对原来跨<code>ns</code>借用资源的应用进行“延迟”释放，控制驱逐<code>Pod</code>的顺序，保障原来优先级较高的应用不会被优先处理。</p><h2 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h2><p>应用类别分为 训练任务和在线任务。<br>训练任务一般采用分布式训练，但是其<code>Pod</code>副本数是可以适当弹性浮动的，即比如副本数为<code>3~6</code>之间都可以接受。在线服务可以理解为服务可能在用户开通之后就一直存在，客观情况下除非用户主动删除在线服务，否则在资源满足的情况下不会主动释放其占用的服务。简单描述即当资源可能不够的情况下，在需要自动释放资源的时候，在线服务是 <strong>“延迟”</strong> 释放资源，优先对那些训练任务“动手”。</p><ul><li>用户A配置了 {<code>resources</code>:{<code>min</code>:6, <code>max</code>:10}} 的资源限额，用户B的资源限额配置为 {<code>resources</code>: {<code>min</code>:12,<code>max</code>:14}}</li><li>用户A <code>Job</code> 应用资源配置为{<code>resources</code>:{<code>requests</code>:2,<code>limits</code>:2}} rs为2，<code>NoteBook</code> 应用资源配额为{<code>resources</code>:{<code>requests</code>:2,<code>limits</code>:2}} rs 为2</li><li>用户B <code>Job-1</code> 应用资源配置为{<code>resources</code>:{<code>requests</code>:3,<code>limits</code>:3}} rs为1，<br><code>Job-2</code> 应用资源配置为{<code>resources</code>:{<code>resources</code>:5,<code>limits</code>:5}} rs为1。</li></ul><p>背景如上，模拟过程步骤及期望如下：</p><ol><li>在<code>ns-A</code>中运行<code>Job</code>,在<code>ns-B</code>中运行<code>Job-1</code>，由于此时<code>requests</code>都没有达到<code>min</code>值，此时在各自的<code>ns</code>中都能正常运行。</li><li>在<code>ns-A</code>中运行<code>NoteBokk</code>服务，这个时候 <code>2*2+2*2&gt;6</code>那么需要向<code>ns-B</code>借用部分资源进行运行</li><li>在<code>ns-B</code>中运行<code>Job-2</code>服务，这个时候<code>ns-B</code>通知<code>ns-A</code>:”大兄嘚，临时借用的资源该还我了，”，此时在<code>ns-A</code>中，由于<code>NoteBook</code>服务是在线服务，需要保障其在 <strong>“不得已”</strong> 情况下才释放资源以备还回借用的资源，此时应该是优先释放<code>Job</code> 资源来还债。</li></ol><h1 id="需求解析"><a href="#需求解析" class="headerlink" title="需求解析"></a>需求解析</h1><ul><li>跨<code>namespace</code>资源借用</li><li>控制<code>pod</code>释放资源的先后顺序。<blockquote><p>以下情况举例以<code>CPU</code>资源为例，<code>Memory</code>,<code>GPU</code>一样适用</p></blockquote></li></ul><h2 id="跨namespace资源调用"><a href="#跨namespace资源调用" class="headerlink" title="跨namespace资源调用"></a>跨<code>namespace</code>资源调用</h2><p>解决方案： 基于<code>scheduler framework</code> 定义 <code>capacityScheduling</code> 调度策略。<a href="https://kubernetes.io/zh/docs/concepts/scheduling-eviction/scheduling-framework/"><code>scheduler framework</code></a>。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/scheduling-framework-extensions.png" alt="scheduler-framework-extension"><br>通过在调度框架中完成对应的<code>Points</code>逻辑，<em>详细的代码分析后续分析<code>scheduler framework</code>进行介绍</em>。</p><h2 id="控制资源释放的先后顺序"><a href="#控制资源释放的先后顺序" class="headerlink" title="控制资源释放的先后顺序"></a>控制资源释放的先后顺序</h2><p>解决方案: 基于<code>PriorityClass</code>的优先级与抢占式，<a href="https://kiragoo.github.io/archives/1bff6d5.html"><code>PriorityClass优先级与抢占</code></a>。</p><p>优先级的概念我们都可以理解，即优先级越高则优先抢占资源，固引入对<code>NoteBook</code>关联的<code>PriorityClass</code>的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: scheduling.k8s.io&#x2F;v1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: priority-class-for-notebook</span><br><span class="line">value: 1000000</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;This priority class should be used for notebook service pods only.</span><br></pre></td></tr></table></figure><p>注意，这是一个全局性质的定义，不会因为<code>namespace</code>而控制。</p><p>那怎么知道还资源释放是和优先级相关的呢？<br>根据函数名 <code>selectVictimsOnNode</code>，我们可以知道这边是选择那些“倒霉蛋”来释放他们借用的资源，具体关键逻辑性的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  &#x2F;&#x2F; 此处自定义了排序逻辑</span><br><span class="line">sort.Slice(nodeInfo.Pods, func(i, j int) bool &#123; return !util.MoreImportantPod(nodeInfo.Pods[i].Pod, nodeInfo.Pods[j].Pod) &#125;)</span><br><span class="line">var potentialVictims []*v1.Pod</span><br><span class="line">if preemptorWithElasticQuota &#123;</span><br><span class="line">for _, p :&#x3D; range nodeInfo.Pods &#123;</span><br><span class="line">pElasticQuotaInfo, pWithElasticQuota :&#x3D; elasticQuotaInfos[p.Pod.Namespace]</span><br><span class="line">if !pWithElasticQuota &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if moreThanMinWithPreemptor &#123;</span><br><span class="line">&#x2F;&#x2F; If Preemptor.Request + Quota.Used &gt; Quota.Min:</span><br><span class="line">&#x2F;&#x2F; It means that its guaranteed isn&#39;t borrowed by other</span><br><span class="line">&#x2F;&#x2F; quotas. So that we will select the pods which subject to the</span><br><span class="line">&#x2F;&#x2F; same quota(namespace) with the lower priority than the</span><br><span class="line">&#x2F;&#x2F; preemptor&#39;s priority as potential victims in a node.</span><br><span class="line">if p.Pod.Namespace &#x3D;&#x3D; pod.Namespace &amp;&amp; podutil.GetPodPriority(p.Pod) &lt; podPriority &#123;</span><br><span class="line">potentialVictims &#x3D; append(potentialVictims, p.Pod)</span><br><span class="line">if err :&#x3D; removePod(p.Pod); err !&#x3D; nil &#123;</span><br><span class="line">return nil, 0, false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; If Preemptor.Request + Quota.allocated &lt;&#x3D; Quota.min: It</span><br><span class="line">&#x2F;&#x2F; means that its min(guaranteed) resource is used or</span><br><span class="line">&#x2F;&#x2F; &#96;borrowed&#96; by other Quota. Potential victims in a node</span><br><span class="line">&#x2F;&#x2F; will be chosen from Quotas that allocates more resources</span><br><span class="line">&#x2F;&#x2F; than its min, i.e., borrowing resources from other</span><br><span class="line">&#x2F;&#x2F; Quotas.</span><br><span class="line">if p.Pod.Namespace !&#x3D; pod.Namespace &amp;&amp; moreThanMin(*pElasticQuotaInfo.Used, *pElasticQuotaInfo.Min) &#123;</span><br><span class="line">          &#x2F;&#x2F; 将选择好的 POD 添加到Victims数组中</span><br><span class="line">potentialVictims &#x3D; append(potentialVictims, p.Pod)</span><br><span class="line">if err :&#x3D; removePod(p.Pod); err !&#x3D; nil &#123;</span><br><span class="line">return nil, 0, false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for _, p :&#x3D; range nodeInfo.Pods &#123;</span><br><span class="line">_, pWithElasticQuota :&#x3D; elasticQuotaInfos[p.Pod.Namespace]</span><br><span class="line">if pWithElasticQuota &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">if podutil.GetPodPriority(p.Pod) &lt; podPriority &#123;</span><br><span class="line">potentialVictims &#x3D; append(potentialVictims, p.Pod)</span><br><span class="line">if err :&#x3D; removePod(p.Pod); err !&#x3D; nil &#123;</span><br><span class="line">return nil, 0, false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看 <code>util.MoreImportantPod</code> 这个排序的具体逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func MoreImportantPod(pod1, pod2 *v1.Pod) bool &#123;</span><br><span class="line">p1 :&#x3D; podutil.GetPodPriority(pod1)</span><br><span class="line">p2 :&#x3D; podutil.GetPodPriority(pod2)</span><br><span class="line">if p1 !&#x3D; p2 &#123;</span><br><span class="line">return p1 &gt; p2</span><br><span class="line">&#125;</span><br><span class="line">return GetPodStartTime(pod1).Before(GetPodStartTime(pod2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这边就一切了然了，实际上优先根据优先级排序，如果优先级相同的话则根据<code>StartTime</code>进行排序。</p><p><em>至此算完成了</em>，但是果真如此么？这里我们引入了<code>PriorityClass</code>来控制释放资源的顺序，那么会不会引入其他问题呢？</p><p><strong>谨惕</strong><br>引入高优先级，那么默认情况下会导致资源抢占，那么低优先级的应用在高优先级应用不主动释放资源的情况下永远获取不到资源，最恶劣的结果就是低优先级的<code>Pod</code>一直处于“资源饥饿”状态，始终没法部署运行。那么我们有没有机会在利用优先级的同时，弱化抢占的行为能力呢？答案是肯定的，官方文档中有关于<a href="https://kubernetes.io/zh/docs/concepts/configuration/pod-priority-preemption/#non-preempting-priority-class">非抢占式的 PriorityClass</a>的明细描述，通过以上的组合，可以达到目前我们的需求预期，下面让我们来验证测试。</p><h1 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h1><p>测试环境为<br>1 master unscheable 8核<br>2 slave  scheable  8*2 核<br><code>kube-scheduler</code> 编译完成之后需要对<code>kube-scheduler</code>配置对应的调度策略:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># kube-scheduler.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    component: kube-scheduler</span><br><span class="line">    tier: control-plane</span><br><span class="line">  name: kube-scheduler-with-plugins</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - command:</span><br><span class="line">    - kube-scheduler</span><br><span class="line">    - --authentication-kubeconfig&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;scheduler.conf</span><br><span class="line">    - --authorization-kubeconfig&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;scheduler.conf</span><br><span class="line">    - --bind-address&#x3D;127.0.0.1</span><br><span class="line">    &#x2F;&#x2F; modify</span><br><span class="line">    - --config&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;scheduler-plugins&#x2F;sched-multi.yaml</span><br><span class="line">    - --port&#x3D;0</span><br><span class="line">    image: kirago&#x2F;kube-scheduler:v0.19.8</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    livenessProbe:</span><br><span class="line">      failureThreshold: 8</span><br><span class="line">      httpGet:</span><br><span class="line">        host: 127.0.0.1</span><br><span class="line">        path: &#x2F;healthz</span><br><span class="line">        port: 10259</span><br><span class="line">        scheme: HTTPS</span><br><span class="line">      initialDelaySeconds: 10</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">      timeoutSeconds: 15</span><br><span class="line">    name: kube-scheduler-with-plugins</span><br><span class="line">    resources:</span><br><span class="line">      requests:</span><br><span class="line">        cpu: 100m</span><br><span class="line">    startupProbe:</span><br><span class="line">      failureThreshold: 24</span><br><span class="line">      httpGet:</span><br><span class="line">        host: 127.0.0.1</span><br><span class="line">        path: &#x2F;healthz</span><br><span class="line">        port: 10259</span><br><span class="line">        scheme: HTTPS</span><br><span class="line">      initialDelaySeconds: 10</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">      timeoutSeconds: 15</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: &#x2F;etc&#x2F;kubernetes&#x2F;scheduler.conf</span><br><span class="line">      name: kubeconfig</span><br><span class="line">      readOnly: true</span><br><span class="line">    &#x2F;&#x2F; modify</span><br><span class="line">    - mountPath: &#x2F;etc&#x2F;kubernetes&#x2F;scheduler-plugins&#x2F;sched-multi.yaml</span><br><span class="line">      name: sched-multi</span><br><span class="line">      readOnly: true</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  priorityClassName: system-node-critical</span><br><span class="line">  volumes:</span><br><span class="line">  - hostPath:</span><br><span class="line">      path: &#x2F;etc&#x2F;kubernetes&#x2F;scheduler.conf</span><br><span class="line">      type: FileOrCreate</span><br><span class="line">    name: kubeconfig</span><br><span class="line">  &#x2F;&#x2F; modify</span><br><span class="line">  - hostPath:</span><br><span class="line">      path: &#x2F;etc&#x2F;kubernetes&#x2F;scheduler-plugins&#x2F;sched-multi.yaml</span><br><span class="line">      type: FileOrCreate</span><br><span class="line">    name: sched-multi</span><br><span class="line">status: &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># sched-multi.yaml</span><br><span class="line">apiVersion: kubescheduler.config.k8s.io&#x2F;v1beta1</span><br><span class="line">kind: KubeSchedulerConfiguration</span><br><span class="line">leaderElection:</span><br><span class="line">  leaderElect: false</span><br><span class="line">clientConnection:</span><br><span class="line">  kubeconfig: &#x2F;etc&#x2F;kubernetes&#x2F;scheduler.conf</span><br><span class="line">profiles:</span><br><span class="line">- schedulerName: default-scheduler</span><br><span class="line">  plugins:</span><br><span class="line">    preFilter:</span><br><span class="line">      enabled:</span><br><span class="line">      - name: CapacityScheduling</span><br><span class="line">    postFilter:</span><br><span class="line">      enabled:</span><br><span class="line">      - name: CapacityScheduling</span><br><span class="line">      disabled:</span><br><span class="line">      - name: &quot;*&quot;</span><br><span class="line">    reserve:</span><br><span class="line">      enabled:</span><br><span class="line">      - name: CapacityScheduling</span><br><span class="line">    postBind:</span><br><span class="line">      enabled:</span><br><span class="line">  # pluginConfig is needed for coscheduling plugin to manipulate PodGroup CR objects.</span><br><span class="line">  pluginConfig:</span><br><span class="line">  - name: CapacityScheduling</span><br><span class="line">    args:</span><br><span class="line">      kubeConfigPath: &#x2F;etc&#x2F;kubernetes&#x2F;scheduler.conf</span><br></pre></td></tr></table></figure><p>*由于 <code>scheduler plugins</code>*是<code>sig-scheduling</code>维护，目前这块的文档还是比较少的，这边的插件目前属于<code>out-of-tree</code>，这边的<code>Option</code>是<code>merge</code>到<code>in-tree</code>中的，所以每个<code>Point</code>该怎么配，最直观的就是看下源码，这是最靠谱的，之前在陪<code>coScheduling</code>的时候就遇到一丢丢问题，个人也提交了个<code>ISSUE</code>确认了下，详见<a href="https://github.com/kubernetes-sigs/scheduler-plugins/issues/168"><code>The Pod of kube-scheduler : &quot;found unknown field: unreserve&quot;</code></a>。</p><h2 id="权限准备工作"><a href="#权限准备工作" class="headerlink" title="权限准备工作"></a>权限准备工作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; all-in-one.yaml</span><br><span class="line"># First part</span><br><span class="line"># Apply extra privileges to system:kube-scheduler.</span><br><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: system:kube-scheduler:plugins</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;scheduling.sigs.k8s.io&quot;]</span><br><span class="line">  resources: [&quot;elasticquotas&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;, &quot;update&quot;, &quot;patch&quot;]</span><br><span class="line">---</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io&#x2F;v1</span><br><span class="line">metadata:</span><br><span class="line">  name: system:kube-scheduler:plugins</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:kube-scheduler:plugins</span><br><span class="line">subjects:</span><br><span class="line">- apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: User</span><br><span class="line">  name: system:kube-scheduler</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="创建对应的namespace"><a href="#创建对应的namespace" class="headerlink" title="创建对应的namespace"></a>创建对应的<code>namespace</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; eq-ns.yaml</span><br><span class="line">&#x2F;&#x2F; ns-A</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: eq1</span><br><span class="line">---</span><br><span class="line">&#x2F;&#x2F; ns-B</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: eq2</span><br></pre></td></tr></table></figure><h2 id="创建CRD文件"><a href="#创建CRD文件" class="headerlink" title="创建CRD文件"></a>创建<code>CRD</code>文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; capacityscheduler-crd.yaml</span><br><span class="line">apiVersion: apiextensions.k8s.io&#x2F;v1</span><br><span class="line">kind: CustomResourceDefinition</span><br><span class="line">metadata:</span><br><span class="line">  name: elasticquotas.scheduling.sigs.k8s.io</span><br><span class="line">  annotations:</span><br><span class="line">    &quot;api-approved.kubernetes.io&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;kubernetes-sigs&#x2F;scheduler-plugins&#x2F;pull&#x2F;52&quot;</span><br><span class="line">spec:</span><br><span class="line">  group: scheduling.sigs.k8s.io</span><br><span class="line">  names:</span><br><span class="line">    plural: elasticquotas</span><br><span class="line">    singular: elasticquota</span><br><span class="line">    kind: ElasticQuota</span><br><span class="line">    shortNames:</span><br><span class="line">    - eq</span><br><span class="line">    - eqs</span><br><span class="line">  scope: Namespaced</span><br><span class="line">  versions:</span><br><span class="line">    - name: v1alpha1</span><br><span class="line">      served: true</span><br><span class="line">      storage: true</span><br><span class="line">      schema:</span><br><span class="line">        openAPIV3Schema:</span><br><span class="line">          type: object</span><br><span class="line">          properties:</span><br><span class="line">            spec:</span><br><span class="line">              type: object</span><br><span class="line">              properties:</span><br><span class="line">                min:</span><br><span class="line">                  type: object</span><br><span class="line">                  additionalProperties:</span><br><span class="line">                    anyOf:</span><br><span class="line">                      - type: integer</span><br><span class="line">                      - type: string</span><br><span class="line">                    pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$</span><br><span class="line">                    x-kubernetes-int-or-string: true</span><br><span class="line">                max:</span><br><span class="line">                  type: object</span><br><span class="line">                  additionalProperties:</span><br><span class="line">                    anyOf:</span><br><span class="line">                      - type: integer</span><br><span class="line">                      - type: string</span><br><span class="line">                    pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$</span><br><span class="line">                    x-kubernetes-int-or-string: true</span><br><span class="line">            status:</span><br><span class="line">              type: object</span><br><span class="line">              properties:</span><br><span class="line">                used:</span><br><span class="line">                  type: object</span><br><span class="line">                  additionalProperties:</span><br><span class="line">                    anyOf:</span><br><span class="line">                      - type: integer</span><br><span class="line">                      - type: string</span><br><span class="line">                    pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$</span><br><span class="line">                    x-kubernetes-int-or-string: true</span><br></pre></td></tr></table></figure><h2 id="创建NoteBook关联的PriorityClass"><a href="#创建NoteBook关联的PriorityClass" class="headerlink" title="创建NoteBook关联的PriorityClass"></a>创建<code>NoteBook</code>关联的<code>PriorityClass</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: scheduling.k8s.io&#x2F;v1</span><br><span class="line">kind: PriorityClass</span><br><span class="line">metadata:</span><br><span class="line">  name: priority-class-for-notebook</span><br><span class="line">value: 1000000</span><br><span class="line">preemptionPolicy: Never</span><br><span class="line">globalDefault: false</span><br><span class="line">description: &quot;This priority class should be used for notebook service pods only.&quot;</span><br></pre></td></tr></table></figure><h2 id="模拟场景所需的Deployment"><a href="#模拟场景所需的Deployment" class="headerlink" title="模拟场景所需的Deployment"></a>模拟场景所需的<code>Deployment</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Job</span><br><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx1-1</span><br><span class="line">  namespace: eq1</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx1-1</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx1-1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: nginx1-1</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx1-1</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        command: [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;cat &#x2F;dev&#x2F;urandom | gzip -9 | gzip -d | gzip -9 | gzip -d &gt; &#x2F;dev&#x2F;null&quot;]</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 2</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NoteBooK</span><br><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx2-1</span><br><span class="line">  namespace: eq1</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx2-1</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx2-1</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: nginx2-1</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx2-1</span><br><span class="line">      annotations:</span><br><span class="line">        job: notebook</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        command: [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;cat &#x2F;dev&#x2F;urandom | gzip -9 | gzip -d | gzip -9 | gzip -d &gt; &#x2F;dev&#x2F;null&quot;]</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 2</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 2</span><br><span class="line">      priorityClassName: priority-class-for-notebook</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Job 1</span><br><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx1-2</span><br><span class="line">  namespace: eq2</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx1-2</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx1-2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: nginx1-2</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx1-2</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        command: [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;cat &#x2F;dev&#x2F;urandom | gzip -9 | gzip -d | gzip -9 | gzip -d &gt; &#x2F;dev&#x2F;null&quot;]</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 3</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Job-2</span><br><span class="line">apiVersion: apps&#x2F;v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx2-2</span><br><span class="line">  namespace: eq2</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx2-2</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx2-2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      name: nginx2-2</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx2-2</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        command: [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;cat &#x2F;dev&#x2F;urandom | gzip -9 | gzip -d | gzip -9 | gzip -d &gt; &#x2F;dev&#x2F;null&quot;]</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 5</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 5</span><br></pre></td></tr></table></figure><ol><li>部署 <code>Job</code><br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/ng1-eq1.png" alt="ng1-eq1"></li><li>部署 <code>Job-1</code><br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/ng1-eq2.png" alt="ng1-eq2"></li><li>部署 <code>NoteBook</code>，此时模拟<code>ns-A</code>按照我们的预期 <code>2*2+2*2&gt;6</code>，且 <code>ns-B</code> 空间用户的资源还有剩余满足借用的前提，即使 8&gt;6 但是也是能够将<code>ns-A</code>中所有的应用部署起来的。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/ng2-eq1.png" alt="ng2-eq1"></li><li>部署模拟 <code>ns-B</code> 中的<code>Job-2</code>,此时这个时候<code>ns-B</code>肯定会优先保障自家兄弟的温饱，此时<code>ns-A</code>中借用的资源应该还回来了，但是应该还谁的资源呢？根据上文的分析实际上再<code>ns-A</code>中也分三六九等，需要优先保障<code>NoteBook</code>服务，那么就是对<code>Job</code>进行下手。<br><img src="https://github.com/kiragoo/kimg/raw/master/blogimgs/ng2-eq2.png" alt="ng2-eq2"></li></ol><p>可以看到，一切按照我们的预期在执行，至此，各位大佬可以发现，<em>此处的<code>pod nginx1-1-59457d7fbf-4pkxt</code>是一个<code>pending</code>状态，为啥不是直接被干掉呢？</em> </p><p><strong>后续更新源码分析</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h1&gt;&lt;p&gt; 在多租户的场景下，提供一种跨&lt;code&gt;namespace&lt;/code&gt;的资源“借用”途径，在资源池建设之后进一步提升资源</summary>
      
    
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/categories/kubernetes/"/>
    
    <category term="scheduler" scheme="http://kiragoo.github.com/categories/kubernetes/scheduler/"/>
    
    
    <category term="kubernetes" scheme="http://kiragoo.github.com/tags/kubernetes/"/>
    
    <category term="notebook" scheme="http://kiragoo.github.com/tags/notebook/"/>
    
    <category term="scheduler" scheme="http://kiragoo.github.com/tags/scheduler/"/>
    
  </entry>
  
</feed>
